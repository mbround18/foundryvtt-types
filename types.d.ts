/**
 * A namespace containing the user interface applications which are defined throughout the Foundry VTT ecosystem.
 * @namespace applications
 */
declare let _appId: number;
declare let _maxZ: number;
declare const MIN_WINDOW_WIDTH: 200;
declare const MIN_WINDOW_HEIGHT: 50;
/**
 * @typedef {object} ApplicationOptions
 * @property {string|null} [baseApplication]  A named "base application" which generates an additional hook
 * @property {number|null} [width]         The default pixel width for the rendered HTML
 * @property {number|string|null} [height]  The default pixel height for the rendered HTML
 * @property {number|null} [top]           The default offset-top position for the rendered HTML
 * @property {number|null} [left]          The default offset-left position for the rendered HTML
 * @property {number|null} [scale]         A transformation scale for the rendered HTML
 * @property {boolean} [popOut]            Whether to display the application as a pop-out container
 * @property {boolean} [minimizable]       Whether the rendered application can be minimized (popOut only)
 * @property {boolean} [resizable]         Whether the rendered application can be drag-resized (popOut only)
 * @property {string} [id]                 The default CSS id to assign to the rendered HTML
 * @property {string[]} [classes]          An array of CSS string classes to apply to the rendered HTML
 * @property {string} [title]              A default window title string (popOut only)
 * @property {string|null} [template]      The default HTML template path to render for this Application
 * @property {string[]} [scrollY]          A list of unique CSS selectors which target containers that should have their
 *                                         vertical scroll positions preserved during a re-render.
 * @property {TabsConfiguration[]} [tabs]  An array of tabbed container configurations which should be enabled for the
 *                                         application.
 * @property {DragDropConfiguration[]} dragDrop  An array of CSS selectors for configuring the application's
 *                                               {@link DragDrop} behaviour.
 * @property {SearchFilterConfiguration[]} filters An array of {@link SearchFilter} configuration objects.
 */
/**
 * The standard application window that is rendered for a large variety of UI elements in Foundry VTT.
 * @abstract
 * @param {ApplicationOptions} [options]  Configuration options which control how the application is rendered.
 *                                        Application subclasses may add additional supported options, but these base
 *                                        configurations are supported for all Applications. The values passed to the
 *                                        constructor are combined with the defaultOptions defined at the class level.
 */
declare class Application {
  /**
   * The sequence of rendering states that track the Application life-cycle.
   * @enum {number}
   */
  static RENDER_STATES: Readonly<{
    CLOSING: -2;
    CLOSED: -1;
    NONE: 0;
    RENDERING: 1;
    RENDERED: 2;
    ERROR: 3;
  }>;
  /**
   * Assign the default options configuration which is used by this Application class. The options and values defined
   * in this object are merged with any provided option values which are passed to the constructor upon initialization.
   * Application subclasses may include additional options which are specific to their usage.
   * @returns {ApplicationOptions}
   */
  static get defaultOptions(): ApplicationOptions;
  /**
   * Return the inheritance chain for this Application class up to (and including) it's base Application class.
   * @returns {Function[]}
   * @private
   */
  private static _getInheritanceChain;
  constructor(options?: {});
  /**
   * The options provided to this application upon initialization
   * @type {object}
   */
  options: object;
  /**
   * The application ID is a unique incrementing integer which is used to identify every application window
   * drawn by the VTT
   * @type {number}
   */
  appId: number;
  /**
   * An internal reference to the HTML element this application renders
   * @type {jQuery}
   */
  _element: jQuery;
  /**
   * Track the current position and dimensions of the Application UI
   * @type {object}
   */
  position: object;
  /**
   * DragDrop workflow handlers which are active for this Application
   * @type {DragDrop[]}
   */
  _dragDrop: DragDrop[];
  /**
   * Tab navigation handlers which are active for this Application
   * @type {Tabs[]}
   */
  _tabs: Tabs[];
  /**
   * SearchFilter handlers which are active for this Application
   * @type {SearchFilter[]}
   */
  _searchFilters: SearchFilter[];
  /**
   * Track whether the Application is currently minimized
   * @type {boolean}
   */
  _minimized: boolean;
  /**
   * The current render state of the Application
   * @see {Application.RENDER_STATES}
   * @type {number}
   * @protected
   */
  protected _state: number;
  /**
   * The prior render state of this Application.
   * This allows for rendering logic to understand if the application is being rendered for the first time.
   * @see {Application.RENDER_STATES}
   * @type {number}
   * @protected
   */
  protected _priorState: number;
  /**
   * Track the most recent scroll positions for any vertically scrolling containers
   * @type {object | null}
   */
  _scrollPositions: object | null;
  /**
   * Create drag-and-drop workflow handlers for this Application
   * @returns {DragDrop[]}     An array of DragDrop handlers
   * @private
   */
  private _createDragDropHandlers;
  /**
   * Create tabbed navigation handlers for this Application
   * @returns {Tabs[]}     An array of Tabs handlers
   * @private
   */
  private _createTabHandlers;
  /**
   * Create search filter handlers for this Application
   * @returns {SearchFilter[]}  An array of SearchFilter handlers
   * @private
   */
  private _createSearchFilters;
  /**
   * Return the CSS application ID which uniquely references this UI element
   * @type {string}
   */
  get id(): string;
  /**
   * Return the active application element, if it currently exists in the DOM
   * @type {jQuery}
   */
  get element(): jQuery;
  /**
   * The path to the HTML template file which should be used to render the inner content of the app
   * @type {string}
   */
  get template(): string;
  /**
   * Control the rendering style of the application. If popOut is true, the application is rendered in its own
   * wrapper window, otherwise only the inner app content is rendered
   * @type {boolean}
   */
  get popOut(): boolean;
  /**
   * Return a flag for whether the Application instance is currently rendered
   * @type {boolean}
   */
  get rendered(): boolean;
  /**
   * An Application window should define its own title definition logic which may be dynamic depending on its data
   * @type {string}
   */
  get title(): string;
  /**
   * An application should define the data object used to render its template.
   * This function may either return an Object directly, or a Promise which resolves to an Object
   * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
   * @param {object} options
   * @returns {object|Promise<object>}
   */
  getData(options?: object): object | Promise<object>;
  /**
   * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
   * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
   *
   * @param {boolean} force   Add the rendered application to the DOM if it is not already present. If false, the
   *                          Application will only be re-rendered if it is already present.
   * @param {object} options  Additional rendering options which are applied to customize the way that the Application
   *                          is rendered in the DOM.
   *
   * @param {number} [options.left]           The left positioning attribute
   * @param {number} [options.top]            The top positioning attribute
   * @param {number} [options.width]          The rendered width
   * @param {number} [options.height]         The rendered height
   * @param {number} [options.scale]          The rendered transformation scale
   * @param {boolean} [options.focus=false]   Apply focus to the application, maximizing it and bringing it to the top
   *                                          of the vertical stack.
   * @param {string} [options.renderContext]  A context-providing string which suggests what event triggered the render
   * @param {object} [options.renderData]     The data change which motivated the render request
   *
   * @returns {Application}                 The rendered Application instance
   *
   */
  render(
    force?: boolean,
    options?: {
      left?: number | undefined;
      top?: number | undefined;
      width?: number | undefined;
      height?: number | undefined;
      scale?: number | undefined;
      focus?: boolean | undefined;
      renderContext?: string | undefined;
      renderData?: object | undefined;
    }
  ): Application;
  /**
   * An asynchronous inner function which handles the rendering of the Application
   * @param {boolean} force     Render and display the application even if it is not currently displayed.
   * @param {object} options    Additional options which update the current values of the Application#options object
   * @returns {Promise<void>}   A Promise that resolves to the Application once rendering is complete
   * @protected
   */
  protected _render(force?: boolean, options?: object): Promise<void>;
  /**
   * Persist the scroll positions of containers within the app before re-rendering the content
   * @param {jQuery} html           The HTML object being traversed
   * @protected
   */
  protected _saveScrollPositions(html: jQuery): void;
  /**
   * Restore the scroll positions of containers within the app after re-rendering the content
   * @param {jQuery} html           The HTML object being traversed
   * @protected
   */
  protected _restoreScrollPositions(html: jQuery): void;
  /**
   * Render the outer application wrapper
   * @returns {Promise<jQuery>}   A promise resolving to the constructed jQuery object
   * @protected
   */
  protected _renderOuter(): Promise<jQuery>;
  /**
   * Render the inner application content
   * @param {object} data         The data used to render the inner template
   * @returns {Promise<jQuery>}   A promise resolving to the constructed jQuery object
   * @private
   */
  private _renderInner;
  /**
   * Customize how inner HTML is replaced when the application is refreshed
   * @param {jQuery} element      The original HTML processed as a jQuery object
   * @param {jQuery} html         New updated HTML as a jQuery object
   * @private
   */
  private _replaceHTML;
  /**
   * Customize how a new HTML Application is added and first appears in the DOM
   * @param {jQuery} html       The HTML element which is ready to be added to the DOM
   * @private
   */
  private _injectHTML;
  /**
   * Specify the set of config buttons which should appear in the Application header.
   * Buttons should be returned as an Array of objects.
   * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
   * @typedef {{label: string, class: string, icon: string, onclick: Function|null}} ApplicationHeaderButton
   * @fires Application#hook:getApplicationHeaderButtons
   * @returns {ApplicationHeaderButton[]}
   * @private
   */
  private _getHeaderButtons;
  /**
   * Create a {@link ContextMenu} for this Application.
   * @param {jQuery} html  The Application's HTML.
   * @private
   */
  private _contextMenu;
  /**
   * Activate required listeners which must be enabled on every Application.
   * These are internal interactions which should not be overridden by downstream subclasses.
   * @param {jQuery} html
   * @protected
   */
  protected _activateCoreListeners(html: jQuery): void;
  /**
   * After rendering, activate event listeners which provide interactivity for the Application.
   * This is where user-defined Application subclasses should attach their event-handling logic.
   * @param {JQuery} html
   */
  activateListeners(html: JQuery): void;
  /**
   * Change the currently active tab
   * @param {string} tabName      The target tab name to switch to
   * @param {object} options      Options which configure changing the tab
   * @param {string} options.group    A specific named tab group, useful if multiple sets of tabs are present
   * @param {boolean} options.triggerCallback  Whether to trigger tab-change callback functions
   */
  activateTab(
    tabName: string,
    {
      group,
      triggerCallback,
    }?: {
      group: string;
      triggerCallback: boolean;
    }
  ): void;
  /**
   * Handle changes to the active tab in a configured Tabs controller
   * @param {MouseEvent|null} event   A left click event
   * @param {Tabs} tabs               The Tabs controller
   * @param {string} active           The new active tab name
   * @protected
   */
  protected _onChangeTab(
    event: MouseEvent | null,
    tabs: Tabs,
    active: string
  ): void;
  /**
   * Handle changes to search filtering controllers which are bound to the Application
   * @param {KeyboardEvent} event   The key-up event from keyboard input
   * @param {string} query          The raw string input to the search field
   * @param {RegExp} rgx            The regular expression to test against
   * @param {HTMLElement} html      The HTML element which should be filtered
   * @protected
   */
  protected _onSearchFilter(
    event: KeyboardEvent,
    query: string,
    rgx: RegExp,
    html: HTMLElement
  ): void;
  /**
   * Define whether a user is able to begin a dragstart workflow for a given drag selector
   * @param {string} selector       The candidate HTML selector for dragging
   * @returns {boolean}             Can the current user drag this selector?
   * @protected
   */
  protected _canDragStart(selector: string): boolean;
  /**
   * Define whether a user is able to conclude a drag-and-drop workflow for a given drop selector
   * @param {string} selector       The candidate HTML selector for the drop target
   * @returns {boolean}             Can the current user drop on this selector?
   * @protected
   */
  protected _canDragDrop(selector: string): boolean;
  /**
   * Callback actions which occur at the beginning of a drag start workflow.
   * @param {DragEvent} event       The originating DragEvent
   * @protected
   */
  protected _onDragStart(event: DragEvent): void;
  /**
   * Callback actions which occur when a dragged element is over a drop target.
   * @param {DragEvent} event       The originating DragEvent
   * @protected
   */
  protected _onDragOver(event: DragEvent): void;
  /**
   * Callback actions which occur when a dragged element is dropped on a target.
   * @param {DragEvent} event       The originating DragEvent
   * @protected
   */
  protected _onDrop(event: DragEvent): void;
  /**
   * Bring the application to the top of the rendering stack
   */
  bringToTop(): void;
  /**
   * Close the application and un-register references to it within UI mappings
   * This function returns a Promise which resolves once the window closing animation concludes
   * @param {object} [options={}] Options which affect how the Application is closed
   * @returns {Promise<void>}     A Promise which resolves once the application is closed
   */
  close(options?: object | undefined): Promise<void>;
  /**
   * Minimize the pop-out window, collapsing it to a small tab
   * Take no action for applications which are not of the pop-out variety or apps which are already minimized
   * @returns {Promise<void>}  A Promise which resolves once the minimization action has completed
   */
  minimize(): Promise<void>;
  /**
   * Maximize the pop-out window, expanding it to its original size
   * Take no action for applications which are not of the pop-out variety or are already maximized
   * @returns {Promise<void>}    A Promise which resolves once the maximization action has completed
   */
  maximize(): Promise<void>;
  /**
   * Set the application position and store its new location.
   * Returns the updated position object for the application containing the new values.
   * @param {object} position                   Positional data
   * @param {number|null} position.left            The left offset position in pixels
   * @param {number|null} position.top             The top offset position in pixels
   * @param {number|null} position.width           The application width in pixels
   * @param {number|string|null} position.height   The application height in pixels
   * @param {number|null} position.scale           The application scale as a numeric factor where 1.0 is default
   * @returns {{left: number, top: number, width: number, height: number, scale:number}|void}
   */
  setPosition({
    left,
    top,
    width,
    height,
    scale,
  }?: {
    left: number | null;
    top: number | null;
    width: number | null;
    height: number | string | null;
    scale: number | null;
  }): {
    left: number;
    top: number;
    width: number;
    height: number;
    scale: number;
  } | void;
  /**
   * Handle application minimization behavior - collapsing content and reducing the size of the header
   * @param {Event} ev
   * @private
   */
  private _onToggleMinimize;
  /**
   * Additional actions to take when the application window is resized
   * @param {Event} event
   * @private
   */
  private _onResize;
}
/**
 * The sequence of rendering states that track the Application life-cycle.
 */
type RENDER_STATES = number;
/**
 * Specify the set of config buttons which should appear in the Application header.
 * Buttons should be returned as an Array of objects.
 * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
 */
type ApplicationHeaderButton = {
  label: string;
  class: string;
  icon: string;
  onclick: Function | null;
};
type ApplicationOptions = {
  /**
   * A named "base application" which generates an additional hook
   */
  baseApplication?: string | null | undefined;
  /**
   * The default pixel width for the rendered HTML
   */
  width?: number | null | undefined;
  /**
   * The default pixel height for the rendered HTML
   */
  height?: string | number | null | undefined;
  /**
   * The default offset-top position for the rendered HTML
   */
  top?: number | null | undefined;
  /**
   * The default offset-left position for the rendered HTML
   */
  left?: number | null | undefined;
  /**
   * A transformation scale for the rendered HTML
   */
  scale?: number | null | undefined;
  /**
   * Whether to display the application as a pop-out container
   */
  popOut?: boolean | undefined;
  /**
   * Whether the rendered application can be minimized (popOut only)
   */
  minimizable?: boolean | undefined;
  /**
   * Whether the rendered application can be drag-resized (popOut only)
   */
  resizable?: boolean | undefined;
  /**
   * The default CSS id to assign to the rendered HTML
   */
  id?: string | undefined;
  /**
   * An array of CSS string classes to apply to the rendered HTML
   */
  classes?: string[] | undefined;
  /**
   * A default window title string (popOut only)
   */
  title?: string | undefined;
  /**
   * The default HTML template path to render for this Application
   */
  template?: string | null | undefined;
  /**
   * A list of unique CSS selectors which target containers that should have their
   *           vertical scroll positions preserved during a re-render.
   */
  scrollY?: string[] | undefined;
  /**
   * An array of tabbed container configurations which should be enabled for the
   *   application.
   */
  tabs?: TabsConfiguration[] | undefined;
  /**
   * An array of CSS selectors for configuring the application's
   * {@link DragDrop } behaviour.
   */
  dragDrop: DragDropConfiguration[];
  /**
   * An array of {@link SearchFilter } configuration objects.
   */
  filters: SearchFilterConfiguration[];
};
/**
 * Audio/Video Conferencing Configuration Sheet
 * @extends {FormApplication}
 *
 * @param {AVMaster} object                   The {@link AVMaster} instance being configured.
 * @param {FormApplicationOptions} [options]  Application configuration options.
 */
declare class AVConfig extends FormApplication {
  /** @override */
  static override get defaultOptions(): any;
  constructor(object: any, options: any);
  /** @override */
  override getData(options?: {}): Promise<{
    user: any;
    modes: {
      [x: number]: string;
    };
    voiceModes: any;
    serverTypes: {
      FVTT: string;
      custom: string;
    };
    turnTypes: {
      server: string;
      custom: string;
    };
    settings: any;
    canSelectMode: any;
    noSSL: boolean;
    videoSources: any;
    audioSources: any;
    audioSinks: any;
    videoSrcUnavailable: boolean | "";
    audioSrcUnavailable: boolean | "";
    audioSinkUnavailable: boolean | "";
    audioDisabled: boolean;
    videoDisabled: boolean;
    nameplates: {
      [x: number]: string;
    };
    nameplateSetting: any;
    dockPositions: any;
  }>;
  /**
   * Set a section's input to enabled or disabled
   * @param {string} selector    Selector for the section to enable or disable
   * @param {boolean} enabled    Whether to enable or disable this section
   * @private
   */
  private _setConfigSectionEnabled;
  /**
   * Determine whether a given video or audio source, or audio sink has become
   * unavailable since the last time it was set.
   * @param {object} sources The available devices
   * @param {string} source  The selected device
   * @private
   */
  private _isSourceUnavailable;
  /**
   * Callback when the turn server type changes
   * Will enable or disable the turn section based on whether the user selected a custom turn or not
   * @param {Event} event   The event that triggered the turn server type change
   * @private
   */
  private _onTurnTypeChanged;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * Abstraction of the Application interface to be used with the Draggable class as a substitute for the app
 * This class will represent one popout feed window and handle its positioning and draggability
 * @param {CameraViews} view      The CameraViews application that this popout belongs to
 * @param {string} userId         ID of the user this popout belongs to
 * @param {jQuery} element        The div element of this specific popout window
 */
declare class CameraPopoutAppWrapper {
  constructor(view: any, userId: any, element: any);
  view: any;
  element: any;
  userId: any;
  popOut: boolean;
  options: {};
  /**
   * Get the current position of this popout window
   */
  get position(): any;
  /** @override */
  override setPosition(options?: {}): void | {
    left: number;
    top: number;
    width: number;
    height: number;
    scale: number;
  };
  _onResize(event: any): void;
  /** @override */
  override bringToTop(): void;
}
/**
 * The Camera UI View that displays all the camera feeds as individual video elements.
 * @type {Application}
 *
 * @param {WebRTC} webrtc                 The WebRTC Implementation to display
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class CameraViews extends Application {
  /** @override */
  static override get defaultOptions(): any;
  /**
   * A custom sorting function that orders/arranges the user display frames
   * @return {number}
   * @private
   */
  private static _sortUsers;
  /**
   * A reference to the master AV orchestrator instance
   * @type {AVMaster}
   */
  get webrtc(): AVMaster;
  /**
   * If all camera views are popped out, hide the dock.
   * @type {boolean}
   */
  get hidden(): boolean;
  /**
   * Obtain a reference to the div.camera-view which is used to portray a given Foundry User.
   * @param {string} userId     The ID of the User document
   * @return {HTMLElement|null}
   */
  getUserCameraView(userId: string): HTMLElement | null;
  /**
   * Obtain a reference to the video.user-camera which displays the video channel for a requested Foundry User.
   * If the user is not broadcasting video this will return null.
   * @param {string} userId     The ID of the User document
   * @return {HTMLVideoElement|null}
   */
  getUserVideoElement(userId: string): HTMLVideoElement | null;
  /**
   * Sets whether a user is currently speaking or not
   *
   * @param {string} userId     The ID of the user
   * @param {boolean} speaking  Whether the user is speaking
   */
  setUserIsSpeaking(userId: string, speaking: boolean): void;
  /**
   * Extend the render logic to first check whether a render is necessary based on the context
   * If a specific context was provided, make sure an update to the navigation is necessary before rendering
   */
  render(force: any, context?: {}): any;
  /** @override */
  override _render(force?: boolean, options?: {}): Promise<void>;
  /** @inheritdoc */
  setPosition({
    left,
    top,
    width,
    scale,
  }?: {
    left: any;
    top: any;
    width: any;
    scale: any;
  }): void | {
    left: number;
    top: number;
    width: number;
    height: number;
    scale: number;
  };
  /** @override */
  override getData(options?: {}): {
    self: any;
    muteAll: any;
    borderColors: any;
    dockClass: string;
    hidden: boolean;
    users: any[];
    nameplates: {
      cssClass: any;
      playerName: boolean;
      charname: boolean;
    };
  };
  maxZ: number | undefined;
  /**
   * Prepare rendering data for a single user
   * @private
   */
  private _getDataForUser;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * On hover in a camera container, show/hide the controls.
   * @event {Event} event   The original mouseover or mouseout hover event
   * @private
   */
  private _onCameraViewHover;
  /**
   * On clicking on a toggle, disable/enable the audio or video stream.
   * @event {MouseEvent} event   The originating click event
   * @private
   */
  private _onClickControl;
  /**
   * Change volume control for a stream
   * @param {Event} event   The originating change event from interaction with the range input
   * @private
   */
  private _onVolumeChange;
  /**
   * Dynamically refresh the state of a single camera view
   * @param {string} userId  The ID of the user whose view we want to refresh.
   * @protected
   */
  protected _refreshView(userId: string): void;
  /**
   * Render changes needed to the PlayerList ui.
   * Show/Hide players depending on option.
   * @private
   */
  private _setPlayerListVisibility;
  /**
   * Get the icon class that should be used for various action buttons with different toggled states.
   * The returned icon should represent the visual status of the NEXT state (not the CURRENT state).
   *
   * @param {string} action     The named av-control button action
   * @param {boolean} state     The CURRENT action state.
   * @returns {string}          The icon that represents the NEXT action state.
   * @protected
   */
  protected _getToggleIcon(action: string, state: boolean): string;
  /**
   * Get the text title that should be used for various action buttons with different toggled states.
   * The returned title should represent the tooltip of the NEXT state (not the CURRENT state).
   *
   * @param {string} action     The named av-control button action
   * @param {boolean} state     The CURRENT action state.
   * @returns {string}          The icon that represents the NEXT action state.
   * @protected
   */
  protected _getToggleTooltip(action: string, state: boolean): string;
  /**
   * Show or hide UI control elements
   * This replaces the use of jquery.show/hide as it simply adds a class which has display:none
   * which allows us to have elements with display:flex which can be hidden then shown without
   * breaking their display style.
   * This will show/hide the toggle buttons, volume controls and overlay sidebars
   * @param {jQuery} container    The container for which to show/hide control elements
   * @param {boolean} show        Whether to show or hide the controls
   * @param {string} selector     Override selector to specify which controls to show or hide
   * @private
   */
  private _toggleControlVisibility;
}
/**
 * @typedef {ApplicationOptions} FormApplicationOptions
 * @property {boolean} [closeOnSubmit=true]     Whether to automatically close the application when it's contained
 *                                              form is submitted.
 * @property {boolean} [submitOnChange=false]   Whether to automatically submit the contained HTML form when an input
 *                                              or select element is changed.
 * @property {boolean} [submitOnClose=false]    Whether to automatically submit the contained HTML form when the
 *                                              application window is manually closed.
 * @property {boolean} [editable=true]          Whether the application form is editable - if true, it's fields will
 *                                              be unlocked and the form can be submitted. If false, all form fields
 *                                              will be disabled and the form cannot be submitted.
 * @property {boolean} [sheetConfig=false]      Support configuration of the sheet type used for this application.
 */
/**
 * An abstract pattern for defining an Application responsible for updating some object using an HTML form
 *
 * A few critical assumptions:
 * 1) This application is used to only edit one object at a time
 * 2) The template used contains one (and only one) HTML form as it's outer-most element
 * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
 *
 * @extends {Application}
 * @abstract
 * @interface
 *
 * @param {object} object                     Some object which is the target data structure to be updated by the form.
 * @param {FormApplicationOptions} [options]  Additional options which modify the rendering of the sheet.
 */
declare class FormApplication extends Application {
  constructor(object?: {}, options?: {});
  /**
   * The object target which we are using this form to modify
   * @type {*}
   */
  object: any;
  /**
   * A convenience reference to the form HTMLElement
   * @type {HTMLElement}
   */
  form: HTMLElement;
  /**
   * Keep track of any FilePicker instances which are associated with this form
   * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
   * @type {FilePicker[]}
   */
  filepickers: FilePicker[];
  /**
   * Keep track of any mce editors which may be active as part of this form
   * The values of this object are inner-objects with references to the MCE editor and other metadata
   * @type {Object<string, object>}
   */
  editors: {
    [x: string]: object;
  };
  /**
   * Is the Form Application currently editable?
   * @type {boolean}
   */
  get isEditable(): boolean;
  /**
   * @inheritdoc
   * @returns {object|Promise<object>}
   */
  getData(options?: {}): object | Promise<object>;
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /** @inheritdoc */
  _renderInner(...args: any[]): Promise<jQuery>;
  /** @inheritdoc */
  _activateCoreListeners(html: any): void;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * If the form is not editable, disable its input fields
   * @param {HTMLElement} form    The form HTML
   * @protected
   */
  protected _disableFields(form: HTMLElement): void;
  /**
   * Handle standard form submission steps
   * @param {Event} event               The submit event which triggered this handler
   * @param {object | null} [updateData]  Additional specific data keys/values which override or extend the contents of
   *                                    the parsed form. This can be used to update other flags or data fields at the
   *                                    same time as processing a form submission to avoid multiple database operations.
   * @param {boolean} [preventClose]    Override the standard behavior of whether to close the form on submit
   * @param {boolean} [preventRender]   Prevent the application from re-rendering as a result of form submission
   * @returns {Promise}                 A promise which resolves to the validated update data
   * @protected
   */
  protected _onSubmit(
    event: Event,
    { updateData, preventClose, preventRender }?: object | null | undefined
  ): Promise<any>;
  _submitting: boolean | undefined;
  _state: any;
  /**
   * Get an object of update data used to update the form's target object
   * @param {object} updateData     Additional data that should be merged with the form data
   * @returns {object}               The prepared update data
   * @protected
   */
  protected _getSubmitData(updateData?: object): object;
  /**
   * Handle changes to an input element, submitting the form if options.submitOnChange is true.
   * Do not preventDefault in this handler as other interactions on the form may also be occurring.
   * @param {Event} event  The initial change event
   * @protected
   */
  protected _onChangeInput(event: Event): Promise<any>;
  /**
   * Handle the change of a color picker input which enters it's chosen value into a related input field
   * @param {Event} event   The color picker change event
   * @protected
   */
  protected _onChangeColorPicker(event: Event): void;
  /**
   * Handle changes to a range type input by propagating those changes to the sibling range-value element
   * @param {Event} event  The initial change event
   * @protected
   */
  protected _onChangeRange(event: Event): void;
  /**
   * Additional handling which should trigger when a FilePicker contained within this FormApplication is submitted.
   * @param {string} selection          The target path which was selected
   * @param {FilePicker} filePicker     The FilePicker instance which was submitted
   * @protected
   */
  protected _onSelectFile(selection: string, filePicker: FilePicker): void;
  /**
   * This method is called upon form submission after form data is validated
   * @param {Event} event       The initial triggering submission event
   * @param {object} formData   The object of validated form data with which to update the object
   * @returns {Promise}         A Promise which resolves once the update operation has completed
   * @abstract
   */
  _updateObject(event: Event, formData: object): Promise<any>;
  /**
   * Activate a named TinyMCE text editor
   * @param {string} name             The named data field which the editor modifies.
   * @param {object} options          Editor initialization options passed to {@link TextEditor.create}.
   * @param {string} initialContent   Initial text content for the editor area.
   * @returns {Promise<TinyMCE.Editor|ProseMirror.EditorView>}
   */
  activateEditor(
    name: string,
    options?: object,
    initialContent?: string
  ): Promise<TinyMCE.Editor | ProseMirror.EditorView>;
  /**
   * Handle saving the content of a specific editor by name
   * @param {string} name           The named editor to save
   * @param {boolean} [remove]      Remove the editor after saving its content
   * @returns {Promise<void>}
   */
  saveEditor(name: string, { remove }?: boolean | undefined): Promise<void>;
  /**
   * Activate an editor instance present within the form
   * @param {HTMLElement} div  The element which contains the editor
   * @protected
   */
  protected _activateEditor(div: HTMLElement): void;
  /**
   * Configure ProseMirror plugins for this sheet.
   * @param {string} name                    The name of the editor.
   * @param {object} [options]               Additional options to configure the plugins.
   * @param {boolean} [options.remove=true]  Whether the editor should destroy itself on save.
   * @returns {object}
   * @protected
   */
  protected _configureProseMirrorPlugins(
    name: string,
    {
      remove,
    }?:
      | {
          remove?: boolean | undefined;
        }
      | undefined
  ): object;
  /**
   * Activate a FilePicker instance present within the form
   * @param {PointerEvent} event    The mouse click event on a file picker activation button
   * @protected
   */
  protected _activateFilePicker(event: PointerEvent): Promise<any>;
  /**
   * Determine the configuration options used to initialize a FilePicker instance within this FormApplication.
   * Subclasses can extend this method to customize the behavior of pickers within their form.
   * @param {PointerEvent} event        The initiating mouse click event which opens the picker
   * @returns {object}                  Options passed to the FilePicker constructor
   * @protected
   */
  protected _getFilePickerOptions(event: PointerEvent): object;
  /** @inheritdoc */
  close(options?: {}): Promise<void>;
  /**
   * Submit the contents of a Form Application, processing its content as defined by the Application
   * @param {object} [options]        Options passed to the _onSubmit event handler
   * @returns {FormApplication}       Return a self-reference for convenient method chaining
   */
  submit(options?: object | undefined): FormApplication;
}
/**
 * @typedef {FormApplicationOptions} DocumentSheetOptions
 * @property {number} viewPermission                The default permissions required to view this Document sheet.
 * @property {HTMLSecretConfiguration[]} [secrets]  An array of {@link HTMLSecret} configuration objects.
 */
/**
 * Extend the FormApplication pattern to incorporate specific logic for viewing or editing Document instances.
 * See the FormApplication documentation for more complete description of this interface.
 *
 * @extends {FormApplication}
 * @abstract
 * @interface
 */
declare class DocumentSheet extends FormApplication {
  /**
   * @param {Document} object                    A Document instance which should be managed by this form.
   * @param {DocumentSheetOptions} [options={}]  Optional configuration parameters for how the form behaves.
   */
  constructor(object: Document, options?: ApplicationOptions | undefined);
  /**
   * The list of handlers for secret block functionality.
   * @type {HTMLSecret[]}
   * @protected
   */
  protected _secrets: HTMLSecret[];
  /**
   * A semantic convenience reference to the Document instance which is the target object for this form.
   * @type {ClientDocument}
   */
  get document(): abstract.Document;
  /** @inheritdoc */
  get isEditable(): any;
  /** @inheritdoc */
  getData(options?: {}): {
    cssClass: string;
    editable: any;
    document: abstract.Document;
    data: any;
    limited: any;
    options: object;
    owner: any;
    title: string;
  };
  /** @inheritdoc */
  activateEditor(
    name: any,
    options?: {},
    initialContent?: string
  ): Promise<any>;
  /** @inheritdoc */
  render(force?: boolean, options?: {}): DocumentSheet | Application;
  /**
   * Create an ID link button in the document sheet header which displays the document ID and copies to clipboard
   * @param {jQuery} html
   * @protected
   */
  protected _createDocumentIdLink(html: jQuery): void;
  /**
   * Test whether a certain User has permission to view this Document Sheet.
   * @param {User} user     The user requesting to render the sheet
   * @returns {boolean}     Does the User have permission to view this sheet?
   * @protected
   */
  protected _canUserView(user: User): boolean;
  /**
   * Create objects for managing the functionality of secret blocks within this Document's content.
   * @returns {HTMLSecret[]}
   * @protected
   */
  protected _createSecretHandlers(): HTMLSecret[];
  /**
   * Get the HTML content that a given secret block is embedded in.
   * @param {HTMLElement} secret  The secret block.
   * @returns {string}
   * @protected
   */
  protected _getSecretContent(secret: HTMLElement): string;
  /**
   * Update the HTML content that a given secret block is embedded in.
   * @param {HTMLElement} secret         The secret block.
   * @param {string} content             The new content.
   * @returns {Promise<ClientDocument>}  The updated Document.
   * @protected
   */
  protected _updateSecret(
    secret: HTMLElement,
    content: string
  ): Promise<ClientDocument>;
  /**
   * Handle requests to configure the default sheet used by this Document
   * @param event
   * @private
   */
  private _onConfigureSheet;
  /** @inheritdoc */
  _updateObject(event: any, formData: any): Promise<any>;
}
type FormApplicationOptions = ApplicationOptions;
type DocumentSheetOptions = FormApplicationOptions;
/**
 * The Application responsible for displaying and editing a single Actor document.
 * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
 * @extends {DocumentSheet}
 * @category - Applications
 * @param {Actor} actor                     The Actor instance being displayed within the sheet.
 * @param {DocumentSheetOptions} [options]  Additional application configuration options.
 */
declare class ActorSheet extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  get title(): any;
  /**
   * A convenience reference to the Actor document
   * @type {Actor}
   */
  get actor(): Actor;
  /**
   * If this Actor Sheet represents a synthetic Token actor, reference the active Token
   * @type {Token|null}
   */
  get token(): Function | null;
  /** @inheritdoc */
  close(options: any): Promise<void>;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): object;
  /**
   * Handle requests to configure the Token for the Actor
   * @param {PointerEvent} event      The originating click event
   * @private
   */
  private _onConfigureToken;
  /**
   * Handle changing the actor profile image by opening a FilePicker
   * @param {Event} event     The input field change event
   * @private
   */
  private _onEditImage;
  /** @inheritdoc */
  _canDragStart(selector: any): any;
  /** @inheritdoc */
  _canDragDrop(selector: any): any;
  /** @inheritdoc */
  _onDragStart(event: any): void;
  /** @inheritdoc */
  _onDrop(event: any): Promise<boolean | object | undefined>;
  /**
   * Handle the dropping of ActiveEffect data onto an Actor Sheet
   * @param {DragEvent} event                  The concluding DragEvent which contains drop data
   * @param {object} data                      The data transfer extracted from the event
   * @returns {Promise<ActiveEffect|boolean>}  The created ActiveEffect object or false if it couldn't be created.
   * @protected
   */
  protected _onDropActiveEffect(
    event: DragEvent,
    data: object
  ): Promise<ActiveEffect | boolean>;
  /**
   * Handle dropping of an Actor data onto another Actor sheet
   * @param {DragEvent} event            The concluding DragEvent which contains drop data
   * @param {object} data                The data transfer extracted from the event
   * @returns {Promise<object|boolean>}  A data object which describes the result of the drop, or false if the drop was
   *                                     not permitted.
   * @protected
   */
  protected _onDropActor(
    event: DragEvent,
    data: object
  ): Promise<object | boolean>;
  /**
   * Handle dropping of an item reference or item data onto an Actor Sheet
   * @param {DragEvent} event            The concluding DragEvent which contains drop data
   * @param {object} data                The data transfer extracted from the event
   * @returns {Promise<Item[]|boolean>}  The created or updated Item instances, or false if the drop was not permitted.
   * @protected
   */
  protected _onDropItem(
    event: DragEvent,
    data: object
  ): Promise<Item[] | boolean>;
  /**
   * Handle dropping of a Folder on an Actor Sheet.
   * The core sheet currently supports dropping a Folder of Items to create all items as owned items.
   * @param {DragEvent} event     The concluding DragEvent which contains drop data
   * @param {object} data         The data transfer extracted from the event
   * @returns {Promise<Item[]>}
   * @protected
   */
  protected _onDropFolder(event: DragEvent, data: object): Promise<Item[]>;
  /**
   * Handle the final creation of dropped Item data on the Actor.
   * This method is factored out to allow downstream classes the opportunity to override item creation behavior.
   * @param {object[]|object} itemData     The item data requested for creation
   * @returns {Promise<Item[]>}
   * @private
   */
  private _onDropItemCreate;
  /**
   * Handle a drop event for an existing embedded Item to sort that Item relative to its siblings
   * @param {Event} event
   * @param {Object} itemData
   * @private
   */
  private _onSortItem;
}
/**
 * An interface for packaging Adventure content and loading it to a compendium pack.
 * // TODO - add a warning if you are building the adventure with any missing content
 * // TODO - add a warning if you are building an adventure that sources content from a different package' compendium
 */
declare class AdventureExporter extends DocumentSheet {
  /** @inheritDoc */
  static get defaultOptions(): any;
  constructor(document: any, options?: {});
  /**
   * An alias for the Adventure document
   * @type {Adventure}
   */
  adventure: Adventure;
  /**
   * @typedef {Object} AdventureContentTreeNode
   * @property {string} id        An alias for folder.id
   * @property {string} name      An alias for folder.name
   * @property {Folder} folder    The Folder at this node level
   * @property {string} state     The modification state of the Folder
   * @property {AdventureContentTreeNode[]} children  An array of child nodes
   * @property {{id: string, name: string, document: ClientDocument, state: string}[]} documents  An array of documents
   */
  /**
   * @typedef {AdventureContentTreeNode} AdventureContentTreeRoot
   * @property {null} id                The folder ID is null at the root level
   * @property {string} documentName    The Document name contained in this tree
   * @property {string} collection      The Document collection name of this tree
   * @property {string} name            The name displayed at the root level of the tree
   * @property {string} icon            The icon displayed at the root level of the tree
   * @property {string} collapseIcon    The icon which represents the current collapsed state of the tree
   * @property {string} cssClass        CSS classes which describe the display of the tree
   * @property {number} documentCount   The number of documents which are present in the tree
   */
  /**
   * The prepared document tree which is displayed in the form.
   * @type {Object<AdventureContentTreeRoot>}
   */
  contentTree: any;
  /** @override */
  override getData(options?: {}): Promise<{
    adventure: Adventure;
    contentTree: any;
  }>;
  /** @inheritdoc */
  _onDrop(event: any): Promise<any>;
  /**
   * Stage a document for addition to the Adventure.
   * This adds the document locally, the change is not yet submitted to the database.
   * @param {Folder|ClientDocument} document    Some document to be added to the Adventure.
   */
  addContent(document: Folder | ClientDocument): void;
  /**
   * Remove a single Document from the Adventure.
   * @param {ClientDocument} document       The Document being removed from the Adventure.
   */
  removeContent(document: abstract.Document): any;
  #private;
}
type AdventureContentTreeNode = {
  /**
   * An alias for folder.id
   */
  id: string;
  /**
   * An alias for folder.name
   */
  name: string;
  /**
   * The Folder at this node level
   */
  folder: Folder;
  /**
   * The modification state of the Folder
   */
  state: string;
  /**
   * An array of child nodes
   */
  children: any[];
  /**
   * An array of documents
   */
  documents: {
    id: string;
    name: string;
    document: ClientDocument;
    state: string;
  }[];
};
type AdventureContentTreeRoot = {
  /**
   * An alias for folder.id
   */
  id: string;
  /**
   * An alias for folder.name
   */
  name: string;
  /**
   * The Folder at this node level
   */
  folder: Folder;
  /**
   * The modification state of the Folder
   */
  state: string;
  /**
   * An array of child nodes
   */
  children: any[];
  /**
   * An array of documents
   */
  documents: {
    id: string;
    name: string;
    document: abstract.Document;
    state: string;
  }[];
};
/**
 * An interface for importing an adventure from a compendium pack.
 *
 * ### Hook Events
 * {@link hookEvents.preImportAdventure} emitted by AdventureImporter#_updateObject
 * {@link hookEvents.importAdventure} emitted by AdventureImporter#_updateObject
 */
declare class AdventureImporter extends DocumentSheet {
  /** @inheritDoc */
  static get defaultOptions(): any;
  /**
   * An alias for the Adventure document
   * @type {Adventure}
   */
  adventure: Adventure;
  /** @override */
  override getData(options?: {}): Promise<{
    adventure: Adventure;
    contents: {
      icon: string;
      label: string;
      count: number;
    }[];
  }>;
  /**
   * Prepare a list of content types provided by this adventure.
   * @returns {{icon: string, label: string, count: number}[]}
   * @protected
   */
  protected _getContentList(): {
    icon: string;
    label: string;
    count: number;
  }[];
  /** @override */
  override _updateObject(event: any, formData: any): Promise<void>;
  /**
   * Categorize data which requires import as new document creations or updates to existing documents.
   * @param {object} formData   Processed options from the importer form
   * @returns {Promise<{toCreate: Object<object[]>, toUpdate: Object<object[]>, documentCount: number}>}
   * @protected
   */
  protected _prepareImportData(formData: object): Promise<{
    toCreate: any;
    toUpdate: any;
    documentCount: number;
  }>;
  /**
   * Perform database operations to import content into the World.
   * @param {Object<object[]>} toCreate     Adventure data to be created
   * @param {Object<object[]>} toUpdate     Adventure data to be updated
   * @param {number} documentCount          The total number of Documents being modified
   * @returns {Promise<{created: Object<Document[]>, updated: Object<Document[]>}>} The created and updated Documents
   * @protected
   */
  protected _importContent(
    toCreate: any,
    toUpdate: any,
    documentCount: number
  ): Promise<{
    created: any;
    updated: any;
  }>;
}
/**
 * A DocumentSheet application responsible for displaying and editing a single embedded Card document.
 * @extends {DocumentSheet}
 * @param {Card} object                     The {@link Card} object being configured.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class CardConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  getData(options?: {}): any;
  /**
   * Handle card face control actions which modify single cards on the sheet.
   * @param {PointerEvent} event          The originating click event
   * @returns {Promise}                   A Promise which resolves once the handler has completed
   * @protected
   */
  protected _onFaceControl(event: PointerEvent): Promise<any>;
}
/**
 * A DocumentSheet application responsible for displaying and editing a single Cards stack.
 */
declare class CardsConfig extends DocumentSheet {
  /**
   * The allowed sorting methods which can be used for this sheet
   * @enum {string}
   */
  static SORT_TYPES: {
    STANDARD: string;
    SHUFFLED: string;
  };
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * The CardsConfig sheet is constructed by providing a Cards document and sheet-level options.
   * @param {Cards} object                    The {@link Cards} object being configured.
   * @param {DocumentSheetOptions} [options]  Application configuration options.
   */
  constructor(object: Cards, options?: ApplicationOptions | undefined);
  /** @inheritdoc */
  getData(options?: {}): any;
  /**
   * Handle card control actions which modify single cards on the sheet.
   * @param {PointerEvent} event          The originating click event
   * @returns {Promise}                   A Promise which resolves once the handler has completed
   * @protected
   */
  protected _onCardControl(event: PointerEvent): Promise<any>;
  /**
   * Handle lazy-loading card face images.
   * See {@link SidebarTab#_onLazyLoadImage}
   * @param {IntersectionObserverEntry[]} entries   The entries which are now in the observer frame
   * @param {IntersectionObserver} observer         The intersection observer instance
   * @protected
   */
  protected _onLazyLoadImage(
    entries: IntersectionObserverEntry[],
    observer: IntersectionObserver
  ): any;
  /** @inheritdoc */
  _canDragStart(selector: any): any;
  /** @inheritdoc */
  _onDragStart(event: any): void;
  /** @inheritdoc */
  _canDragDrop(selector: any): any;
  /** @inheritdoc */
  _onDrop(event: any): Promise<any>;
  /**
   * Handle sorting a Card relative to other siblings within this document
   * @param {Event} event     The drag drop event
   * @param {Card} card       The card being dragged
   * @private
   */
  private _onSortCard;
}
/**
 * A subclass of CardsConfig which provides a sheet representation for Cards documents with the "hand" type.
 */
declare class CardsHand extends CardsConfig {}
/**
 * A subclass of CardsConfig which provides a sheet representation for Cards documents with the "pile" type.
 */
declare class CardsPile extends CardsConfig {}
/**
 * The allowed sorting methods which can be used for this sheet
 */
type SORT_TYPES = string;
/**
 * The Application responsible for configuring a single Combatant document within a parent Combat.
 * @extends {DocumentSheet}
 */
declare class CombatantConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
}
/**
 * The Application responsible for configuring the CombatTracker and its contents.
 * @extends {FormApplication}
 */
declare class CombatTrackerConfig extends FormApplication {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): Promise<{
    settings: any;
    attributeChoices: any;
  }>;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<any>;
}
/**
 * The Application responsible for configuring a single ActiveEffect document within a parent Actor or Item.
 * @extends {DocumentSheet}
 *
 * @param {ActiveEffect} object             The target active effect being configured
 * @param {DocumentSheetOptions} [options]  Additional options which modify this application instance
 */
declare class ActiveEffectConfig extends DocumentSheet {
  /** @override */
  static override get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): {
    effect: any;
    data: any;
    isActorEffect: boolean;
    isItemEffect: boolean;
    submitText: string;
    modes: any;
  };
  /**
   * Provide centralized handling of mouse clicks on control buttons.
   * Delegate responsibility out to action-specific handlers depending on the button action.
   * @param {MouseEvent} event      The originating click event
   * @private
   */
  private _onEffectControl;
  /**
   * Handle adding a new change to the changes array.
   * @private
   */
  private _addEffectChange;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): any;
}
/**
 * The Application responsible for configuring a single Folder document.
 * @extends {DocumentSheet}
 * @param {Folder} object                   The {@link Folder} object to configure.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class FolderConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): Promise<{
    folder: any;
    name: any;
    newName: string;
    safeColor: any;
    sortingModes: {
      a: string;
      m: string;
    };
    submitText: string;
  }>;
}
/**
 * @typedef {object} NewFontDefinition
 * @property {string} [family]          The font family.
 * @property {number} [weight=400]      The font weight.
 * @property {string} [style="normal"]  The font style.
 * @property {string} [src=""]          The font file.
 * @property {string} [preview]         The text to preview the font.
 */
/**
 * A class responsible for configuring custom fonts for the world.
 * @extends {FormApplication}
 */
declare class FontConfig extends FormApplication {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Whether a font is distributed to connected clients or found on their OS.
   * @enum {string}
   */
  static FONT_TYPES: {
    FILE: string;
    SYSTEM: string;
  };
  /**
   * Define the setting key where this world's font information will be stored.
   * @type {string}
   */
  static SETTING: string;
  /**
   * A list of fonts that were correctly loaded and are available for use.
   * @type {Set<string>}
   * @private
   */
  private static "__#2@#available";
  /**
   * Get the list of fonts that successfully loaded.
   * @returns {string[]}
   */
  static getAvailableFonts(): string[];
  /**
   * Get the list of fonts formatted for display with selectOptions.
   * @returns {Object<string>}
   */
  static getAvailableFontChoices(): any;
  /**
   * Load a font definition.
   * @param {string} family                    The font family name (case-sensitive).
   * @param {FontFamilyDefinition} definition  The font family definition.
   * @returns {Promise<boolean>}               Returns true if the font was successfully loaded.
   */
  static loadFont(
    family: string,
    definition: {
      /**
       * Whether the font is available in the rich text editor. This will also enable it
       * for notes and drawings.
       */
      editor: boolean;
      /**
       * Individual font face definitions for this font family. If this is empty, the
       * font family may only be loaded from the client's OS-installed fonts.
       */
      fonts: FontFaceDescriptors[];
    }
  ): Promise<boolean>;
  /**
   * Ensure that fonts have loaded and are ready for use.
   * Enforce a maximum timeout in milliseconds.
   * Proceed after that point even if fonts are not yet available.
   * @param {number} [ms=4500]  The maximum time to spend loading fonts before proceeding.
   * @returns {Promise<void>}
   * @internal
   */
  static _loadFonts(ms?: number | undefined): Promise<void>;
  /**
   * Collect all the font definitions and combine them.
   * @returns {Object<FontFamilyDefinition>[]}
   * @protected
   */
  protected static _collectDefinitions(): any[];
  /**
   * Create FontFace object from a FontDefinition.
   * @param {string} family        The font family name.
   * @param {FontDefinition} font  The font definition.
   * @returns {FontFace}
   * @protected
   */
  protected static _createFontFace(
    family: string,
    font: FontFaceDescriptors
  ): FontFace;
  /**
   * Format a font definition for display.
   * @param {string} family              The font family.
   * @param {FontDefinition} definition  The font definition.
   * @returns {string}                   The formatted definition.
   * @private
   */
  private static _formatFont;
  /**
   * An application for configuring custom world fonts.
   * @param {NewFontDefinition} [object]  The default settings for new font definition creation.
   * @param {object} [options]            Additional options to configure behaviour.
   */
  constructor(
    object?: NewFontDefinition | undefined,
    options?: object | undefined
  );
  /** @inheritdoc */
  getData(options?: {}): {
    fonts: any;
    selected: any;
    font: any;
    family: string | undefined;
    weights: any;
  };
  /**
   * Template data for a given font definition.
   * @param {string} family                    The font family.
   * @param {FontFamilyDefinition} definition  The font family definition.
   * @returns {object[]}
   * @protected
   */
  protected _getDataForDefinition(
    family: string,
    definition: {
      /**
       * Whether the font is available in the rich text editor. This will also enable it
       * for notes and drawings.
       */
      editor: boolean;
      /**
       * Individual font face definitions for this font family. If this is empty, the
       * font family may only be loaded from the client's OS-installed fonts.
       */
      fonts: FontFaceDescriptors[];
    }
  ): object[];
  /** @inheritdoc */
  _updateObject(event: any, formData: any): Promise<void>;
  /**
   * Handle application controls.
   * @param {MouseEvent} event  The click event.
   * @protected
   */
  protected _onClickControl(event: MouseEvent): void | Promise<void>;
  /** @inheritdoc */
  _onChangeInput(event: any): Promise<any>;
  /**
   * Update available font fields based on the font type selected.
   * @protected
   */
  protected _updateFontFields(): void;
  /**
   * Add a new custom font definition.
   * @protected
   */
  protected _onAddFont(): Promise<void>;
  /**
   * Delete a font.
   * @param {MouseEvent} event  The click event.
   * @protected
   */
  protected _onDeleteFont(event: MouseEvent): Promise<void>;
  /**
   * Select a font to preview.
   * @param {MouseEvent} event  The click event.
   * @protected
   */
  protected _onSelectFont(event: MouseEvent): void;
  #private;
}
/**
 * Whether a font is distributed to connected clients or found on their OS.
 */
type FONT_TYPES = string;
type NewFontDefinition = {
  /**
   * The font family.
   */
  family?: string | undefined;
  /**
   * The font weight.
   */
  weight?: number | undefined;
  /**
   * The font style.
   */
  style?: string | undefined;
  /**
   * The font file.
   */
  src?: string | undefined;
  /**
   * The text to preview the font.
   */
  preview?: string | undefined;
};
/**
 * A tool for fine-tuning the grid in a Scene
 * @param {Scene} scene                       The scene whose grid is being configured.
 * @param {SceneConfig} sheet                 The Scene Configuration sheet that spawned this dialog.
 * @param {FormApplicationOptions} [options]  Application configuration options.
 */
declare class GridConfig extends FormApplication {
  /** @override */
  static override get defaultOptions(): any;
  constructor(scene: any, sheet: any, ...args: any[]);
  /**
   * Track the Scene Configuration sheet reference
   * @type {SceneConfig}
   */
  sheet: SceneConfig;
  /** @override */
  override getData(options?: {}): {
    gridTypes: object;
    scale: number;
    scene: any;
  };
  /** @override */
  override _getSubmitData(updateData?: {}): object;
  /**
   * Handle keyboard events.
   * @param {KeyboardEvent} event    The original keydown event
   * @private
   */
  private _onKeyDown;
  /**
   * Handle mousewheel events.
   * @param {WheelEvent} event    The original wheel event
   * @private
   */
  private _onWheel;
  /** @override */
  override _onChangeInput(event: any): Promise<void>;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<any>;
  /**
   * Temporarily refresh the display of the BackgroundLayer and GridLayer for the new pending dimensions
   * @param {object} options          Options which define how the refresh is performed
   * @param {boolean} [options.background]      Refresh the background display?
   * @param {object} [options.grid]             Refresh the grid display?
   * @private
   */
  private _refresh;
  /**
   * Reset the scene back to its original settings
   * @private
   */
  private _reset;
  /**
   * Scale the background size relative to the grid size
   * @param {number} delta          The directional change in background size
   * @private
   */
  private _scaleBackgroundSize;
  /**
   * Scale the grid size relative to the background image.
   * When scaling the grid size in this way, constrain the allowed values between 50px and 300px.
   * @param {number} delta          The grid size in pixels
   * @private
   */
  private _scaleGridSize;
  /**
   * Shift the background image relative to the grid layer
   * @param {object} position       The position configuration to preview
   * @param {number} position.deltaX    The number of pixels to shift in the x-direction
   * @param {number} position.deltaY    The number of pixels to shift in the y-direction
   * @private
   */
  private _shiftBackground;
  #private;
}
/**
 * @typedef {FormApplicationOptions} ImagePopoutOptions
 * @property {string} [caption]           Caption text to display below the image.
 * @property {string|null} [uuid=null]    The UUID of some related {@link Document}.
 * @property {boolean} [showTitle]        Force showing or hiding the title.
 */
/**
 * An Image Popout Application which features a single image in a lightbox style frame.
 * Furthermore, this application allows for sharing the display of an image with other connected players.
 * @param {string} src                    The image URL.
 * @param {ImagePopoutOptions} [options]  Application configuration options.
 *
 * @example Creating an Image Popout
 * ```js
 * // Construct the Application instance
 * const ip = new ImagePopout("path/to/image.jpg", {
 *   title: "My Featured Image",
 *   uuid: game.actors.getName("My Hero").uuid
 * });
 *
 * // Display the image popout
 * ip.render(true);
 *
 * // Share the image with other connected players
 * ip.share();
 * ```
 */
declare class ImagePopout extends FormApplication {
  /**
   * Determine the correct position and dimensions for the displayed image
   * @param {string} img  The image URL.
   * @returns {Object}    The positioning object which should be used for rendering
   */
  static getPosition(img: string): Object;
  /**
   * Determine the Image dimensions given a certain path
   * @param {string} path  The image source.
   * @returns {Promise<[number, number]>}
   */
  static getImageSize(path: string): Promise<[number, number]>;
  /**
   * Handle a received request to display an image.
   * @param {ShareImageConfig} config  The image configuration data.
   * @returns {ImagePopout}
   * @internal
   */
  static _handleShareImage({
    image,
    title,
    caption,
    uuid,
    showTitle,
  }?: {
    /**
     * The image URL to share.
     */
    image: string;
    /**
     * The image title.
     */
    title: string;
    /**
     * The UUID of a Document related to the image, used to determine permission to see
     *         the image title.
     */
    uuid?: string | undefined;
    /**
     * If this is provided, the permissions of the related Document will be ignored and
     *   the title will be shown based on this parameter.
     */
    showTitle?: boolean | undefined;
    /**
     * A list of user IDs to show the image to.
     */
    users?: string[] | undefined;
  }): ImagePopout;
  /** @override */
  override getData(options?: {}): Promise<{
    image: any;
    options: object;
    title: string;
    caption: any;
    showTitle: boolean;
  }>;
  /**
   * Test whether the title of the image popout should be visible to the user
   * @returns {boolean}
   */
  isTitleVisible(): boolean;
  /**
   * Provide a reference to the Document referenced by this popout, if one exists
   * @returns {Promise<ClientDocument>}
   */
  getRelatedObject(): Promise<ClientDocument>;
  /** @override */
  override _render(...args: any[]): Promise<void>;
  /**
   * @typedef {object} ShareImageConfig
   * @property {string} image         The image URL to share.
   * @property {string} title         The image title.
   * @property {string} [uuid]        The UUID of a Document related to the image, used to determine permission to see
   *                                  the image title.
   * @property {boolean} [showTitle]  If this is provided, the permissions of the related Document will be ignored and
   *                                  the title will be shown based on this parameter.
   * @property {string[]} [users]     A list of user IDs to show the image to.
   */
  /**
   * Share the displayed image with other connected Users
   */
  shareImage(): void;
  #private;
}
type ShareImageConfig = {
  /**
   * The image URL to share.
   */
  image: string;
  /**
   * The image title.
   */
  title: string;
  /**
   * The UUID of a Document related to the image, used to determine permission to see
   *         the image title.
   */
  uuid?: string | undefined;
  /**
   * If this is provided, the permissions of the related Document will be ignored and
   *   the title will be shown based on this parameter.
   */
  showTitle?: boolean | undefined;
  /**
   * A list of user IDs to show the image to.
   */
  users?: string[] | undefined;
};
type ImagePopoutOptions = FormApplicationOptions;
/**
 * The Application responsible for displaying and editing a single Item document.
 * @param {Item} item                       The Item instance being displayed within the sheet.
 * @param {DocumentSheetOptions} [options]  Additional application configuration options.
 */
declare class ItemSheet extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  get title(): any;
  /**
   * A convenience reference to the Item document
   * @type {Item}
   */
  get item(): Item;
  /**
   * The Actor instance which owns this item. This may be null if the item is unowned.
   * @type {Actor}
   */
  get actor(): Actor;
  /**
   * Handle changing the item image
   * @param {PointerEvent} event     The image click event
   * @private
   */
  private _onEditImage;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage document.
 * @extends {DocumentSheet}
 * @param {JournalEntryPage} object         The JournalEntryPage instance which is being edited.
 * @param {DocumentSheetOptions} [options]  Application options.
 */
declare class JournalPageSheet extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  get title(): any;
  /** @inheritdoc */
  getData(options?: {}): any;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage text document.
 * @extends {JournalPageSheet}
 */
declare class JournalTextPageSheet extends JournalPageSheet {
  /**
   * Bi-directional HTML <-> Markdown converter.
   * @type {showdown.Converter}
   * @protected
   */
  protected static _converter: showdown.Converter;
  /**
   * Declare the format that we edit text content in for this sheet so we can perform conversions as necessary.
   * @type {number}
   */
  static get format(): number;
  /**
   * The table of contents for this JournalTextPageSheet.
   * @type {Object<JournalEntryPageHeading>}
   */
  toc: any;
  /** @inheritdoc */
  getData(options?: {}): Promise<any>;
  /**
   * Determine if any editors are dirty.
   * @returns {boolean}
   */
  isEditorDirty(): boolean;
  /** @inheritdoc */
  _getSecretContent(secret: any): any;
  /** @inheritdoc */
  _updateSecret(secret: any, content: any): any;
  /**
   * Lazily convert text formats if we detect the document being saved in a different format.
   * @param {object} renderData  Render data.
   * @protected
   */
  protected _convertFormats(renderData: object): void;
  /**
   * Update the parent sheet if it is open when the server autosaves the contents of this editor.
   * @param {string} html  The updated editor contents.
   */
  onAutosave(html: string): void;
  /**
   * Update the UI appropriately when receiving new steps from another client.
   */
  onNewSteps(): void;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage image document.
 * @extends {JournalPageSheet}
 */
declare class JournalImagePageSheet extends JournalPageSheet {}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage video document.
 * @extends {JournalPageSheet}
 */
declare class JournalVideoPageSheet extends JournalPageSheet {
  /**
   * Get the YouTube player parameters depending on whether the sheet is being viewed or edited.
   * @returns {object}
   * @protected
   */
  protected _getYouTubeVars(): object;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): object;
  /**
   * Convert time components to a timestamp in seconds.
   * @param {{[h]: number, [m]: number, [s]: number}} components  The time components.
   * @returns {number}                                            The timestamp, in seconds.
   * @protected
   */
  protected _timeComponentsToTimestamp({
    h,
    m,
    s,
  }?: {
    [h]: number;
    [m]: number;
    [s]: number;
  }): number;
  /**
   * Convert a timestamp in seconds into separate time components.
   * @param {number} timestamp                           The timestamp, in seconds.
   * @returns {{[h]: number, [m]: number, [s]: number}}  The individual time components.
   * @protected
   */
  protected _timestampToTimeComponents(timestamp: number): {};
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage PDF document.
 * @extends {JournalPageSheet}
 */
declare class JournalPDFPageSheet extends JournalPageSheet {
  /**
   * Maintain a cache of PDF sizes to avoid making HEAD requests every render.
   * @type {Object<number>}
   * @protected
   */
  protected static _sizes: any;
  /**
   * Handle a request to load a PDF.
   * @param {MouseEvent} event  The triggering event.
   * @protected
   */
  protected _onLoadPDF(event: MouseEvent): void;
  /**
   * Retrieve parameters to pass to the PDF viewer.
   * @returns {URLSearchParams}
   * @protected
   */
  protected _getViewerParams(): URLSearchParams;
}
/**
 * A subclass of {@link JournalTextPageSheet} that implements a markdown editor for editing the text content.
 * @extends {JournalTextPageSheet}
 */
declare class MarkdownJournalPageSheet extends JournalTextPageSheet {
  /** @inheritdoc */
  static get format(): any;
  /**
   * Store the dirty flag for this editor.
   * @type {boolean}
   * @protected
   */
  protected _isDirty: boolean;
  /** @inheritdoc */
  _onDrop(event: any): Promise<void>;
  /**
   * Handle dropping a content link onto the editor.
   * @param {object} eventData  The parsed event data.
   * @protected
   */
  protected _onDropContentLink(eventData: object): Promise<void>;
}
/**
 * A subclass of {@link JournalTextPageSheet} that implements a TinyMCE editor.
 * @extends {JournalTextPageSheet}
 */
declare class JournalTextTinyMCESheet extends JournalTextPageSheet {}
/**
 * @typedef {DocumentSheetOptions} JournalSheetOptions
 * @property {string|null} [sheetMode]  The current display mode of the journal. Either 'text' or 'image'.
 */
/**
 * The Application responsible for displaying and editing a single JournalEntry document.
 * @extends {DocumentSheet}
 * @param {JournalEntry} object            The JournalEntry instance which is being edited
 * @param {JournalSheetOptions} [options]  Application options
 */
declare class JournalSheet extends DocumentSheet {
  /**
   * Available view modes for journal entries.
   * @enum {number}
   */
  static VIEW_MODES: {
    SINGLE: number;
    MULTIPLE: number;
  };
  /**
   * The minimum amount of content that must be visible before the next page is marked as in view. Cannot be less than
   * 25% without also modifying the IntersectionObserver threshold.
   * @type {number}
   */
  static INTERSECTION_RATIO: number;
  /**
   * Icons for page ownership.
   * @enum {string}
   */
  static OWNERSHIP_ICONS: {
    [x: number]: string;
  };
  constructor(object: any, options?: {});
  /**
   * The cached list of processed page entries.
   * @type {object[]}
   */
  _pages: object[];
  /**
   * Get the journal entry's current view mode.
   * @see {@link JournalSheet.VIEW_MODES}
   * @returns {number}
   */
  get mode(): number;
  /**
   * The pages that are currently scrolled into view and marked as 'active' in the sidebar.
   * @type {HTMLElement[]}
   */
  get pagesInView(): HTMLElement[];
  /**
   * The index of the currently viewed page.
   * @type {number}
   */
  get pageIndex(): number;
  /**
   * The currently active IntersectionObserver.
   * @type {IntersectionObserver}
   */
  get observer(): IntersectionObserver;
  /**
   * Is the table-of-contents sidebar currently collapsed?
   * @type {boolean}
   */
  get sidebarCollapsed(): boolean;
  /**
   * Prepare pages for display.
   * @returns {JournalEntryPage[]}  The sorted list of pages.
   * @protected
   */
  protected _getPageData(): JournalEntryPage[];
  /**
   * Activate listeners after page content has been injected.
   * @protected
   */
  protected _activatePageListeners(): void;
  /**
   * @inheritdoc
   * @param {number} [options.mode]       Render the sheet in a given view mode, see {@link JournalSheet.VIEW_MODES}.
   * @param {string} [options.pageId]     Render the sheet with the page with the given ID in view.
   * @param {number} [options.pageIndex]  Render the sheet with the page at the given index in view.
   * @param {string} [options.anchor]     Render the sheet with the given anchor for the given page in view.
   * @param {boolean} [options.tempOwnership]  Whether the journal entry or one of its pages is being shown to players
   *                                           who might otherwise not have permission to view it.
   * @param {boolean} [options.collapsed] Render the sheet with the TOC sidebar collapsed?
   */
  _render(force: any, options?: {}): Promise<void>;
  /**
   * Update child views inside the main sheet.
   * @returns {Promise<void>}
   * @protected
   */
  protected _renderPageViews(): Promise<void>;
  /**
   * Add headings to the table of contents for the given page node.
   * @param {HTMLElement} pageNode                 The HTML node of the page's rendered contents.
   * @param {Object<JournalEntryPageHeading>} toc  The page's table of contents.
   * @protected
   */
  protected _renderHeadings(pageNode: HTMLElement, toc: any): Promise<void>;
  /**
   * Create an intersection observer to maintain a list of headings that are in view. This is much more performant than
   * calling getBoundingClientRect on all headings whenever we want to determine this list.
   * @protected
   */
  protected _observeHeadings(): void;
  /**
   * Handle clicking the previous and next page buttons.
   * @param {JQuery.TriggeredEvent} event  The button click event.
   * @protected
   */
  protected _onAction(event: JQuery.TriggeredEvent): any;
  /**
   * Prompt the user with a Dialog for creation of a new JournalEntryPage
   */
  createPage(): any;
  /**
   * Turn to the previous page.
   */
  previousPage(): Application | JournalSheet | undefined;
  /**
   * Turn to the next page.
   */
  nextPage(): Application | JournalSheet | undefined;
  /**
   * Turn to a specific page.
   * @param {string} pageId    The ID of the page to turn to.
   * @param {string} [anchor]  Optionally an anchor slug to focus within that page.
   */
  goToPage(
    pageId: string,
    anchor?: string | undefined
  ): Application | JournalSheet | undefined;
  /**
   * Retrieve the sheet instance for rendering this page inline.
   * @param {string} pageId  The ID of the page.
   * @returns {JournalPageSheet}
   */
  getPageSheet(pageId: string): JournalPageSheet;
  /**
   * Determine whether a page is visible to the current user.
   * @param {JournalEntryPage} page  The page.
   * @returns {boolean}
   */
  isPageVisible(page: JournalEntryPage): boolean;
  /**
   * Toggle the collapsed or expanded state of the Journal Entry table-of-contents sidebar.
   */
  toggleSidebar(): void;
  /**
   * Update the disabled state of the previous and next page buttons.
   * @protected
   */
  protected _updateButtonState(): void;
  /**
   * Edit one of this JournalEntry's JournalEntryPages.
   * @param {JQuery.TriggeredEvent} event  The originating page edit event.
   * @protected
   */
  protected _onEditPage(event: JQuery.TriggeredEvent): any;
  /**
   * Handle clicking an entry in the sidebar to scroll that heading into view.
   * @param {JQuery.TriggeredEvent} event  The originating click event.
   * @protected
   */
  protected _onClickPageLink(event: JQuery.TriggeredEvent): void;
  /**
   * Handle clicking an image to pop it out for fullscreen view.
   * @param {MouseEvent} event  The click event.
   * @protected
   */
  protected _onClickImage(event: MouseEvent): void;
  /**
   * Handle new pages scrolling into view.
   * @param {IntersectionObserverEntry[]} entries  An Array of elements that have scrolled into or out of view.
   * @param {IntersectionObserver} observer        The IntersectionObserver that invoked this callback.
   * @protected
   */
  protected _onPageScroll(
    entries: IntersectionObserverEntry[],
    observer: IntersectionObserver
  ): void;
  /**
   * Highlights the currently viewed page in the sidebar.
   * @protected
   */
  protected _activatePagesInView(): void;
  /**
   * If the set of active pages has changed, various elements in the sidebar will expand and collapse. For particularly
   * long ToCs, this can leave the scroll position of the sidebar in a seemingly random state. We try to do our best to
   * sync the sidebar scroll position with the current journal viewport.
   * @protected
   */
  protected _synchronizeSidebar(): void;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Handle opening the context menu.
   * @param {HTMLElement} target  The element the context menu has been triggered for.
   * @protected
   */
  protected _onContextMenuOpen(target: HTMLElement): void;
  /**
   * Handle closing the context menu.
   * @param {HTMLElement} target  The element the context menu has been triggered for.
   * @protected
   */
  protected _onContextMenuClose(target: HTMLElement): void;
  /**
   * Get the set of ContextMenu options which should be used for JournalEntryPages in the sidebar.
   * @returns {ContextMenuEntry[]}  The Array of context options passed to the ContextMenu instance.
   * @protected
   */
  protected _getEntryContextOptions(): ContextMenuEntry[];
  /**
   * Handle requests to show the referenced Journal Entry to other Users
   * Save the form before triggering the show request, in case content has changed
   * @param {Event} event   The triggering click event
   */
  _onShowPlayers(event: Event): Promise<void | JournalEntry | JournalEntryPage>;
  /** @inheritdoc */
  _canDragStart(selector: any): any;
  /** @inheritdoc */
  _canDragDrop(selector: any): any;
  /** @inheritdoc */
  _onDragStart(event: any): void;
  /** @inheritdoc */
  _onDrop(event: any): Promise<any>;
  /** @inheritdoc */
  _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  #private;
}
/**
 * Available view modes for journal entries.
 */
type VIEW_MODES = number;
/**
 * Icons for page ownership.
 */
type OWNERSHIP_ICONS = string;
type JournalSheetOptions = DocumentSheetOptions;
/**
 * A Macro configuration sheet
 * @extends {DocumentSheet}
 *
 * @param {Macro} object                    The Macro Document which is being configured
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class MacroConfig extends DocumentSheet {
  /** @override */
  static override get defaultOptions(): any;
  /** @inheritdoc */
  _disableFields(form: any): void;
  /**
   * Handle changing the actor profile image by opening a FilePicker
   * @private
   */
  private _onEditImage;
  /**
   * Save and execute the macro using the button on the configuration sheet
   * @param {MouseEvent} event      The originating click event
   * @return {Promise<void>}
   * @private
   */
  private _onExecute;
}
/**
 * The Application responsible for configuring a single MeasuredTemplate document within a parent Scene.
 * @param {MeasuredTemplate} object         The {@link MeasuredTemplate} being configured.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class MeasuredTemplateConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  getData(): any;
}
/**
 * A generic application for configuring permissions for various Document types
 * @extends {DocumentSheet}
 */
declare class DocumentOwnershipConfig extends DocumentSheet {
  /** @override */
  static override get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): {
    currentDefault: any;
    instructions: string;
    defaultLevels: any;
    playerLevels: any;
    isFolder: boolean;
    users: any;
  };
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class PermissionControl extends DocumentOwnershipConfig {
  constructor(...args: any[]);
}
/**
 * The Application responsible for configuring a single Playlist document.
 * @extends {DocumentSheet}
 * @param {Playlist} object                 The {@link Playlist} to configure.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class PlaylistConfig extends DocumentSheet {
  /** @inheritdoc */
  _getFilePickerOptions(event: any): object;
  /** @inheritdoc */
  _onSelectFile(selection: any, filePicker: any): Promise<any>;
}
/**
 * The Application responsible for configuring a single PlaylistSound document within a parent Playlist.
 * @extends {DocumentSheet}
 *
 * @param {PlaylistSound} sound             The PlaylistSound document being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class PlaylistSoundConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  activateListeners(html: any): any;
  /**
   * Auto-populate the track name using the provided filename, if a name is not already set
   * @param {Event} event
   * @private
   */
  private _onSourceChange;
}
/**
 * The Application responsible for displaying and editing a single RollTable document.
 * @param {RollTable} table                 The RollTable document being configured
 * @param {DocumentSheetOptions} [options]  Additional application configuration options
 */
declare class RollTableConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  getData(options?: {}): any;
  /**
   * Handle creating a TableResult in the RollTable document
   * @param {MouseEvent} event        The originating mouse event
   * @param {object} [resultData]     An optional object of result data to use
   * @returns {Promise}
   * @private
   */
  private _onCreateResult;
  /**
   * Submit the entire form when a table result type is changed, in case there are other active changes
   * @param {Event} event
   * @private
   */
  private _onChangeResultType;
  /**
   * Handle deleting a TableResult from the RollTable document
   * @param {MouseEvent} event        The originating click event
   * @returns {Promise<TableResult>}   The deleted TableResult document
   * @private
   */
  private _onDeleteResult;
  /** @inheritdoc */
  _onDrop(event: any): Promise<any>;
  /**
   * Handle changing the actor profile image by opening a FilePicker
   * @param {Event} event
   * @private
   */
  private _onEditImage;
  /**
   * Handle a button click to re-normalize dice result ranges across all RollTable results
   * @param {Event} event
   * @private
   */
  private _onNormalizeResults;
  /**
   * Handle toggling the drawn status of the result in the table
   * @param {Event} event
   * @private
   */
  private _onLockResult;
  /**
   * Reset the Table to it's original composition with all options unlocked
   * @param {Event} event
   * @private
   */
  private _onResetTable;
  /**
   * Handle drawing a result from the RollTable
   * @param {Event} event
   * @private
   */
  private _onRollTable;
  /**
   * Configure the update object workflow for the Roll Table configuration sheet
   * Additional logic is needed here to reconstruct the results array from the editable fields on the sheet
   * @param {Event} event            The form submission event
   * @param {Object} formData        The validated FormData translated into an Object for submission
   * @returns {Promise}
   * @private
   */
  private _updateObject;
  /**
   * Display a roulette style animation when a Roll Table result is drawn from the sheet
   * @param {TableResult[]} results     An Array of drawn table results to highlight
   * @returns {Promise}                  A Promise which resolves once the animation is complete
   * @protected
   */
  protected _animateRoll(results: TableResult[]): Promise<any>;
  /**
   * Animate a "roulette" through the table until arriving at the final loop and a drawn result
   * @param {HTMLOListElement} ol     The list element being iterated
   * @param {Set<string>} drawnIds    The result IDs which have already been drawn
   * @param {number} nLoops           The number of times to loop through the animation
   * @param {number} animTime         The desired animation time in milliseconds
   * @param {number} animOffset       The desired pixel offset of the result within the list
   * @returns {Promise}               A Promise that resolves once the animation is complete
   * @protected
   */
  protected _animateRoulette(
    ol: HTMLOListElement,
    drawnIds: Set<string>,
    nLoops: number,
    animTime: number,
    animOffset: number
  ): Promise<any>;
  /**
   * Display a flashing animation on the selected result to emphasize the draw
   * @param {HTMLElement} item      The HTML &lt;li> item of the winning result
   * @returns {Promise}              A Promise that resolves once the animation is complete
   * @protected
   */
  protected _flashResult(item: HTMLElement): Promise<any>;
}
/**
 * The Application responsible for configuring a single Scene document.
 * @extends {DocumentSheet}
 * @param {Scene} object                    The Scene Document which is being configured
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class SceneConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Get an enumeration of the available grid types which can be applied to this Scene
   * @returns {object}
   * @internal
   */
  static _getGridTypes(): object;
  /** @inheritdoc */
  render(force: any, options?: {}): Application | SceneConfig;
  /**
   * Get the available weather effect types which can be applied to this Scene
   * @returns {object}
   * @private
   */
  private _getWeatherTypes;
  /**
   * Get the alphabetized Documents which can be chosen as a configuration for the Scene
   * @param {WorldCollection} collection
   * @returns {object[]}
   * @private
   */
  private _getDocuments;
  /**
   * Capture the current Scene position and zoom level as the initial view in the Scene config
   * @param {Event} event   The originating click event
   * @private
   */
  private _onCapturePosition;
  /** @override */
  override _onChangeInput(event: any): Promise<any>;
  /** @override */
  override _onChangeColorPicker(event: any): void;
  /** @override */
  override _onChangeRange(event: any): void;
  /**
   * Live update the scene as certain properties are changed.
   * @param {string} changed  The changed property.
   * @private
   */
  private _previewScene;
  /**
   * Reset the previewed darkness level, background color, grid alpha, and grid color back to their true values.
   * @private
   */
  private _resetScenePreview;
  /**
   * Handle updating the select menu of PlaylistSound options when the Playlist is changed
   * @param {Event} event   The initiating select change event
   * @private
   */
  private _onChangePlaylist;
  /**
   * Handle updating the select menu of JournalEntryPage options when the JournalEntry is changed.
   * @param {Event} event  The initiating select change event.
   * @protected
   */
  protected _onChangeJournal(event: Event): void;
  /**
   * Handle click events to open the grid configuration application
   * @param {Event} event   The originating click event
   * @private
   */
  private _onGridConfig;
}
/**
 * Document Sheet Configuration Application
 */
declare class DocumentSheetConfig extends FormApplication {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * An array of pending sheet assignments which are submitted before other elements of the framework are ready.
   * @type {object[]}
   * @private
   */
  private static "__#6@#pending";
  /**
   * Initialize the configured Sheet preferences for Documents which support dynamic Sheet assignment
   * Create the configuration structure for supported documents
   * Process any pending sheet registrations
   * Update the default values from settings data
   */
  static initializeSheets(): void;
  static _getDocumentTypes(cls: any, types?: any[]): any;
  /**
   * Register a sheet class as a candidate which can be used to display documents of a given type
   * @param {typeof ClientDocument} documentClass  The Document class for which to register a new Sheet option
   * @param {string} scope                     Provide a unique namespace scope for this sheet
   * @param {typeof DocumentSheet} sheetClass  A defined Application class used to render the sheet
   * @param {object} options                   Additional options used for sheet registration
   * @param {string|Function} [options.label]  A human-readable label for the sheet name, which will be localized
   * @param {string[]} [options.types]         An array of document types for which this sheet should be used
   * @param {boolean} [options.makeDefault]    Whether to make this sheet the default for provided types
   */
  static registerSheet(
    documentClass: any,
    scope: string,
    sheetClass: typeof DocumentSheet,
    {
      label,
      types,
      makeDefault,
    }?: {
      label?: string | Function | undefined;
      types?: string[] | undefined;
      makeDefault?: boolean | undefined;
    }
  ): void;
  /**
   * Perform the sheet registration.
   * @param {object} config       Configuration for how the sheet should be un-registered
   * @param {typeof ClientDocument} config.documentClass  The Document class being registered
   * @param {string} config.id                            The sheet ID being registered
   * @param {string} config.label                         The human-readable sheet label
   * @param {typeof DocumentSheet} config.sheetClass      The sheet class definition being registered
   * @param {object[]} config.types                       An array of types for which this sheet is added
   * @param {boolean} config.makeDefault                  Make this sheet the default for provided types?
   * @private
   */
  private static "__#6@#registerSheet";
  /**
   * Unregister a sheet class, removing it from the list of available Applications to use for a Document type
   * @param {typeof ClientDocument} documentClass  The Document class for which to register a new Sheet option
   * @param {string} scope                Provide a unique namespace scope for this sheet
   * @param {typeof DocumentSheet} sheetClass  A defined DocumentSheet subclass used to render the sheet
   * @param {object[]} types             An Array of types for which this sheet should be removed
   */
  static unregisterSheet(
    documentClass: any,
    scope: string,
    sheetClass: typeof DocumentSheet,
    { types }?: object[]
  ): void;
  /**
   * Perform the sheet de-registration.
   * @param {object} config       Configuration for how the sheet should be un-registered
   * @param {typeof ClientDocument} config.documentClass  The Document class being unregistered
   * @param {string} config.id                            The sheet ID being unregistered
   * @param {object[]} config.types                       An array of types for which this sheet is removed
   * @private
   */
  private static "__#6@#unregisterSheet";
  /**
   * Update the current default Sheets using a new core world setting.
   * @param {object} setting
   */
  static updateDefaultSheets(setting?: object): void;
  /**
   * Initialize default sheet configurations for all document types.
   * @private
   */
  private static _registerDefaultSheets;
  /** @inheritDoc */
  getData(options?: {}): {
    isGM: any;
    object: any;
    options: object;
    sheetClass: any;
    sheetClasses: any;
    defaultClass: null;
    blankLabel: string;
  };
  /** @inheritdoc */
  _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single User document.
 * @extends {DocumentSheet}
 *
 * @param {User} user                       The User document being configured.
 * @param {DocumentSheetOptions} [options]  Additional rendering options which modify the behavior of the form.
 */
declare class UserConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  getData(options?: {}): {
    user: any;
    actors: any;
    options: object;
  };
  /**
   * Handle changing the user avatar image by opening a FilePicker
   * @private
   */
  private _onEditAvatar;
}
/**
 * @typedef {Option} ChatBubbleOptions
 * @property {string[]} [cssClasses]    An optional array of CSS classes to apply to the resulting bubble
 * @property {boolean} [pan=true]       Pan to the token speaker for this bubble, if allowed by the client
 * @property {boolean} [requireVisible=false] Require that the token be visible in order for the bubble to be rendered
 */
/**
 * The Chat Bubble Class
 * This application displays a temporary message sent from a particular Token in the active Scene.
 * The message is displayed on the HUD layer just above the Token.
 */
declare class ChatBubbles {
  /**
   * Activate Socket event listeners which apply to the ChatBubbles UI.
   * @param {Socket} socket     The active web socket connection
   * @internal
   */
  static _activateSocketListeners(socket: Socket): void;
  template: string;
  /**
   * Track active Chat Bubbles
   * @type {object}
   */
  bubbles: object;
  /**
   * Track which Token was most recently panned to highlight
   * Use this to avoid repeat panning
   * @type {Token}
   * @private
   */
  private _panned;
  /**
   * A reference to the chat bubbles HTML container in which rendered bubbles should live
   * @returns {jQuery}
   */
  get container(): jQuery;
  /**
   * Create a chat bubble message for a certain token which is synchronized for display across all connected clients.
   * @param {TokenDocument} token           The speaking Token Document
   * @param {string} message                The spoken message text
   * @param {ChatBubbleOptions} [options]   Options which affect the bubble appearance
   * @returns {Promise<jQuery|null>}        A promise which resolves with the created bubble HTML, or null
   */
  broadcast(
    token: TokenDocument,
    message: string,
    options?:
      | (new (
          text?: string | undefined,
          value?: string | undefined,
          defaultSelected?: boolean | undefined,
          selected?: boolean | undefined
        ) => HTMLOptionElement)
      | undefined
  ): Promise<jQuery | null>;
  /**
   * Speak a message as a particular Token, displaying it as a chat bubble
   * @param {Token} token                   The speaking Token
   * @param {string} message                The spoken message text
   * @param {ChatBubbleOptions} [options]   Options which affect the bubble appearance
   * @returns {Promise<jQuery|null>}        A Promise which resolves to the created bubble HTML element, or null
   */
  say(
    token: Function,
    message: string,
    {
      cssClasses,
      requireVisible,
      pan,
    }?:
      | (new (
          text?: string | undefined,
          value?: string | undefined,
          defaultSelected?: boolean | undefined,
          selected?: boolean | undefined
        ) => HTMLOptionElement)
      | undefined
  ): Promise<jQuery | null>;
  /**
   * Clear any existing chat bubble for a certain Token
   * @param {Token} token
   * @private
   */
  private _clearBubble;
  /**
   * Render the HTML template for the chat bubble
   * @param {object} data         Template data
   * @returns {Promise<string>}   The rendered HTML
   * @private
   */
  private _renderHTML;
  /**
   * Before displaying the chat message, determine it's constrained and unconstrained dimensions
   * @param {string} message    The message content
   * @returns {object}          The rendered message dimensions
   * @private
   */
  private _getMessageDimensions;
  /**
   * Assign styling parameters to the chat bubble, toggling either a left or right display (randomly)
   * @param {Token} token             The speaking Token
   * @param {JQuery} html             Chat bubble content
   * @param {Rectangle} dimensions    Positioning data
   * @private
   */
  private _setPosition;
  /**
   * Determine the length of time for which to display a chat bubble.
   * Research suggests that average reading speed is 200 words per minute.
   * Since these are short-form messages, we multiply reading speed by 1.5.
   * Clamp the result between 1 second (minimum) and 20 seconds (maximum)
   * @param {jQuery} html     The HTML message
   * @returns {number}        The number of milliseconds for which to display the message
   */
  _getDuration(html: jQuery): number;
}
type ChatBubbleOptions = new (
  text?: string | undefined,
  value?: string | undefined,
  defaultSelected?: boolean | undefined,
  selected?: boolean | undefined
) => HTMLOptionElement;
/**
 * Render the HUD container
 * @type {Application}
 */
declare class HeadsUpDisplay extends Application {
  constructor(...args: any[]);
  /**
   * Token HUD
   * @type {TokenHUD}
   */
  token: TokenHUD;
  /**
   * Tile HUD
   * @type {TileHUD}
   */
  tile: TileHUD;
  /**
   * Drawing HUD
   * @type {DrawingHUD}
   */
  drawing: DrawingHUD;
  /**
   * Chat Bubbles
   * @type {ChatBubbles}
   */
  bubbles: ChatBubbles;
  /** @inheritdoc */
  getData(options?: {}):
    | {
        width?: undefined;
        height?: undefined;
      }
    | {
        width: any;
        height: any;
      };
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /**
   * Align the position of the HUD layer to the current position of the canvas
   */
  align(): void;
}
/**
 * @typedef {Object} SceneControlTool
 * @property {string} name
 * @property {string} title
 * @property {string} icon
 * @property {boolean} visible
 * @property {boolean} toggle
 * @property {boolean} active
 * @property {boolean} button
 * @property {Function} onClick
 */
/**
 * @typedef {Object} SceneControl
 * @property {string} name
 * @property {string} title
 * @property {string} layer
 * @property {string} icon
 * @property {boolean} visible
 * @property {SceneControlTool[]} tools
 * @property {string} activeTool
 */
/**
 * Scene controls navigation menu
 * @extends {Application}
 */
declare class SceneControls extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * The Array of Scene Control buttons which are currently rendered
   * @type {SceneControl[]}
   */
  controls: SceneControl[];
  /**
   * The currently active control set
   * @type {string}
   */
  get activeControl(): string;
  /**
   * The currently active tool in the control palette
   * @type {string}
   */
  get activeTool(): string;
  /**
   * Return the active control set
   * @type {SceneControl|null}
   */
  get control(): SceneControl | null;
  /**
   * Return the actively controlled tool
   * @type {SceneControlTool|null}
   */
  get tool(): SceneControlTool | null;
  /**
   * Initialize the Scene Controls by obtaining the set of control buttons and rendering the HTML
   * @param {object} options      Options which modify how the controls UI is initialized
   * @param {string} [options.control]      An optional control set to set as active
   * @param {string} [options.layer]        An optional layer name to target as the active control
   * @param {string} [options.tool]         A specific named tool to set as active for the palette
   */
  initialize({
    control,
    layer,
    tool,
  }?: {
    control?: string | undefined;
    layer?: string | undefined;
    tool?: string | undefined;
  }): void;
  /** @inheritdoc */
  getData(options?: {}): {
    active: boolean;
    cssClass: string;
    controls: SceneControl[];
  };
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Handle click events on a Control set
   * @param {Event} event   A click event on a tool control
   * @private
   */
  private _onClickLayer;
  /**
   * Handle click events on Tool controls
   * @param {Event} event   A click event on a tool control
   * @private
   */
  private _onClickTool;
  /**
   * Get the set of Control sets and tools that are rendered as the Scene Controls.
   * These controls may be extended using the "getSceneControlButtons" Hook.
   * @returns {SceneControl[]}
   * @private
   */
  private _getControlButtons;
  /**
   * @deprecated since v10
   * @ignore
   */
  get isRuler(): boolean;
  #private;
}
type SceneControlTool = {
  name: string;
  title: string;
  icon: string;
  visible: boolean;
  toggle: boolean;
  active: boolean;
  button: boolean;
  onClick: Function;
};
type SceneControl = {
  name: string;
  title: string;
  layer: string;
  icon: string;
  visible: boolean;
  tools: SceneControlTool[];
  activeTool: string;
};
/**
 * The global action bar displayed at the bottom of the game view.
 * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
 * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
 *
 * Left-clicking a Macro button triggers its effect.
 * Right-clicking the button displays a context menu of Macro options.
 * The number keys 1 through 0 activate numbered hotbar slots.
 * Pressing the delete key while hovering over a Macro will remove it from the bar.
 *
 * @see {@link Macros}
 * @see {@link Macro}
 */
declare class Hotbar extends Application {
  /** @override */
  static override get defaultOptions(): any;
  /**
   * Handle toggling a document sheet.
   * @param {string} uuid     The Document UUID to display
   * @returns {Promise<void>|Application|*}
   */
  static toggleDocumentSheet(uuid: string): Promise<void> | Application | any;
  constructor(options: any);
  /**
   * The currently viewed macro page
   * @type {number}
   */
  page: number;
  /**
   * The currently displayed set of macros
   * @type {Macro[]}
   */
  macros: Macro[];
  /**
   * Track collapsed state
   * @type {boolean}
   */
  _collapsed: boolean;
  /**
   * Track which hotbar slot is the current hover target, if any
   * @type {number|null}
   */
  _hover: number | null;
  /** @override */
  override getData(options?: {}): {
    page: number;
    macros: Macro[];
    barClass: string;
  };
  /**
   * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
   * @param {number} page
   * @returns {Macro[]}
   * @private
   */
  private _getMacrosByPage;
  /**
   * Collapse the Hotbar, minimizing its display.
   * @returns {Promise}    A promise which resolves once the collapse animation completes
   */
  collapse(): Promise<any>;
  /**
   * Expand the Hotbar, displaying it normally.
   * @returns {Promise}    A promise which resolves once the expand animation completes
   */
  expand(): Promise<any>;
  /**
   * Change to a specific numbered page from 1 to 5
   * @param {number} page     The page number to change to.
   */
  changePage(page: number): void;
  /**
   * Change the page of the hotbar by cycling up (positive) or down (negative)
   * @param {number} direction    The direction to cycle
   */
  cyclePage(direction: number): void;
  /** @override */
  override activateListeners(html: any): void;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Get the Macro entry context options
   * @returns {object[]}  The Macro entry context options
   * @private
   */
  private _getEntryContextOptions;
  /**
   * Handle left-click events to
   * @param {MouseEvent} event    The originating click event
   * @protected
   */
  protected _onClickMacro(event: MouseEvent): Promise<any>;
  /**
   * Handle pagination controls
   * @param {Event} event   The originating click event
   * @private
   */
  private _onClickPageControl;
  /** @override */
  override _canDragStart(selector: any): boolean;
  /** @override */
  override _onDragStart(event: any): false | undefined;
  /** @override */
  override _canDragDrop(selector: any): boolean;
  /** @override */
  override _onDrop(event: any): Promise<any>;
  /**
   * Create a Macro document which can be used to toggle display of a Journal Entry.
   * @param {Document} doc          A Document which should be toggled
   * @returns {Promise<Macro>}      A created Macro document to add to the bar
   * @protected
   */
  protected _createDocumentSheetToggle(doc: Document): Promise<Macro>;
  /**
   * Handle click events to toggle display of the macro bar
   * @param {Event} event
   * @private
   */
  private _onToggleBar;
}
/**
 * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
 * @type {Application}
 * @abstract
 * @interface
 * @param {PlaceableObject} object        The {@link PlaceableObject} this HUD is bound to.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class BasePlaceableHUD extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Reference a PlaceableObject this HUD is currently bound to
   * @type {PlaceableObject}
   */
  object: PlaceableObject;
  /**
   * Convenience access for the canvas layer which this HUD modifies
   * @type {PlaceablesLayer}
   */
  get layer(): PlaceablesLayer;
  /**
   * Bind the HUD to a new PlaceableObject and display it
   * @param {PlaceableObject} object    A PlaceableObject instance to which the HUD should be bound
   */
  bind(object: PlaceableObject): void;
  /**
   * Clear the HUD by fading out it's active HTML and recording the new display state
   */
  clear(): void;
  _state: number | undefined;
  /** @override */
  override _render(...args: any[]): Promise<void>;
  /** @override */
  override getData(options?: {}): any;
  /** @override */
  override setPosition({
    left,
    top,
    width,
    height,
    scale,
  }?: {
    left: any;
    top: any;
    width: any;
    height: any;
    scale: any;
  }): void;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Handle mouse clicks to control a HUD control button
   * @param {PointerEvent} event    The originating click event
   * @protected
   */
  protected _onClickControl(event: PointerEvent): Promise<any> | undefined;
  /**
   * Toggle the visible state of all controlled objects in the Layer
   * @param {PointerEvent} event    The originating click event
   * @private
   */
  private _onToggleVisibility;
  /**
   * Toggle locked state of all controlled objects in the Layer
   * @param {PointerEvent} event    The originating click event
   * @private
   */
  private _onToggleLocked;
  /**
   * Handle sorting the z-order of the object
   * @param {boolean} up            Move the object upwards in the vertical stack?
   * @param {PointerEvent} event    The originating mouse click event
   * @returns {Promise}
   * @protected
   */
  protected _onSort(event: PointerEvent, up: boolean): Promise<any>;
}
/**
 * The main menu application which is toggled via the ESC key.
 * @extends {Application}
 */
declare class MainMenu extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * The structure of menu items
   * @returns {Object<{label: string, icon: string, enabled: boolean, onClick: Function}>}
   */
  get items(): any;
  /** @inheritdoc */
  getData(options?: {}): {
    items: any;
  };
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Toggle display of the menu (or render it in the first place)
   */
  toggle(): void;
}
/**
 * The UI element which displays the Scene documents which are currently enabled for quick navigation.
 */
declare class SceneNavigation extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Display progress of some major operation like loading Scene textures.
   * @param {object} options    Options for how the progress bar is displayed
   * @param {string} options.label  A text label to display
   * @param {number} options.pct    A percentage of progress between 0 and 100
   */
  static displayProgressBar({
    label,
    pct,
  }?: {
    label: string;
    pct: number;
  }): void;
  constructor(options: any);
  /**
   * Navigation collapsed state
   * @type {boolean}
   */
  _collapsed: boolean;
  /**
   * Return an Array of Scenes which are displayed in the Navigation bar
   * @returns {Scene[]}
   */
  get scenes(): Scene[];
  /** @inheritdoc */
  render(force: any, context?: {}): any;
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /** @inheritdoc */
  getData(options?: {}): {
    collapsed: boolean;
    scenes: any[];
  };
  /**
   * A hook event that fires when the SceneNavigation menu is expanded or collapsed.
   * @function collapseSceneNavigation
   * @memberof hookEvents
   * @param {SceneNavigation} sceneNavigation The SceneNavigation application
   * @param {boolean} collapsed               Whether the SceneNavigation is now collapsed or not
   */
  /**
   * Expand the SceneNavigation menu, sliding it down if it is currently collapsed
   */
  expand(): true | Promise<any>;
  /**
   * Collapse the SceneNavigation menu, sliding it up if it is currently expanded
   * @returns {Promise<boolean>}
   */
  collapse(): Promise<boolean>;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Get the set of ContextMenu options which should be applied for Scenes in the menu
   * @returns {object[]}   The Array of context options passed to the ContextMenu instance
   * @private
   */
  private _getContextMenuOptions;
  /**
   * Handle left-click events on the scenes in the navigation menu
   * @param {PointerEvent} event
   * @private
   */
  private _onClickScene;
  /** @override */
  override _onDragStart(event: any): void;
  /** @override */
  override _onDrop(event: any): Promise<any>;
  /**
   * Handle navigation menu toggle click events
   * @param {Event} event
   * @private
   */
  private _onToggleNav;
}
/**
 * Pause notification in the HUD
 * @extends {Application}
 */
declare class Pause extends Application {
  /** @override */
  override getData(options?: {}): {
    paused: boolean;
  };
}
/**
 * The UI element which displays the list of Users who are currently playing within the active World.
 * @extends {Application}
 */
declare class PlayerList extends Application {
  /** @override */
  static override get defaultOptions(): any;
  constructor(options: any);
  /**
   * An internal toggle for whether to show offline players or hide them
   * @type {boolean}
   * @private
   */
  private _showOffline;
  /** @override */
  override render(force: any, context?: {}): any;
  /** @override */
  override getData(options?: {}): {
    users: any;
    hide: boolean;
    showOffline: boolean;
  };
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Return the default context options available for the Players application
   * @returns {object[]}
   * @private
   */
  private _getUserContextOptions;
  /**
   * Toggle display of the Players hud setting for whether or not to display offline players
   * @param {Event} event   The originating click event
   * @private
   */
  private _onToggleOfflinePlayers;
}
/**
 * A helper class which assists with localization and string translation
 * @param {string} serverLanguage       The default language configuration setting for the server
 */
declare class Localization {
  constructor(serverLanguage: any);
  /**
   * The target language for localization
   * @type {string}
   */
  lang: string;
  /**
   * The package authorized to provide default language configurations
   * @type {string}
   */
  defaultModule: string;
  /**
   * The translation dictionary for the target language
   * @type {Object}
   */
  translations: Object;
  /**
   * Fallback translations if the target keys are not found
   * @type {Object}
   */
  _fallback: Object;
  /**
   * Initialize the Localization module
   * Discover available language translations and apply the current language setting
   * @returns {Promise<void>}      A Promise which resolves once languages are initialized
   */
  initialize(): Promise<void>;
  /**
   * Set a language as the active translation source for the session
   * @param {string} lang       A language string in CONFIG.supportedLanguages
   * @returns {Promise<void>}   A Promise which resolves once the translations for the requested language are ready
   */
  setLanguage(lang: string): Promise<void>;
  /**
   * Discover the available supported languages from the set of packages which are provided
   * @returns {object}         The resulting configuration of supported languages
   * @private
   */
  private _discoverSupportedLanguages;
  /**
   * Prepare the dictionary of translation strings for the requested language
   * @param {string} lang         The language for which to load translations
   * @returns {Promise<object>}   The retrieved translations object
   * @private
   */
  private _getTranslations;
  /**
   * Reduce the languages array provided by a package to an array of file paths of translations to load
   * @param {object} pkg          The package data
   * @param {string} lang         The target language to filter on
   * @returns {string[]}           An array of translation file paths
   * @private
   */
  private _filterLanguagePaths;
  /**
   * Load a single translation file and return its contents as processed JSON
   * @param {string} src        The translation file path to load
   * @returns {Promise<object>} The loaded translation dictionary
   * @private
   */
  private _loadTranslationFile;
  /**
   * Return whether a certain string has a known translation defined.
   * @param {string} stringId     The string key being translated
   * @param {boolean} [fallback]  Allow fallback translations to count?
   * @returns {boolean}
   */
  has(stringId: string, fallback?: boolean | undefined): boolean;
  /**
   * Localize a string by drawing a translation from the available translations dictionary, if available
   * If a translation is not available, the original string is returned
   * @param {string} stringId     The string ID to translate
   * @returns {string}             The translated string
   *
   * @example Localizing a simple string in JavaScript
   * ```js
   * {
   *   "MYMODULE.MYSTRING": "Hello, this is my module!"
   * }
   * game.i18n.localize("MYMODULE.MYSTRING"); // Hello, this is my module!
   * ```
   *
   * @example Localizing a simple string in Handlebars
   * ```hbs
   * {{localize "MYMODULE.MYSTRING"}} <!-- Hello, this is my module! -->
   * ```
   */
  localize(stringId: string): string;
  /**
   * Localize a string including variable formatting for input arguments.
   * Provide a string ID which defines the localized template.
   * Variables can be included in the template enclosed in braces and will be substituted using those named keys.
   *
   * @param {string} stringId     The string ID to translate
   * @param {object} data         Provided input data
   * @returns {string}             The translated and formatted string
   *
   * @example Localizing a formatted string in JavaScript
   * ```js
   * {
   *   "MYMODULE.GREETING": "Hello {name}, this is my module!"
   * }
   * game.i18n.format("MYMODULE.GREETING" {name: "Andrew"}); // Hello Andrew, this is my module!
   * ```
   *
   * @example Localizing a formatted string in Handlebars
   * ```hbs
   * {{localize "MYMODULE.GREETING" name="Andrew"}} <!-- Hello, this is my module! -->
   * ```
   */
  format(stringId: string, data?: object): string;
}
/**
 * @typedef {FormApplicationOptions} DrawingConfigOptions
 * @property {boolean} [configureDefault=false]  Configure the default drawing settings, instead of a specific Drawing
 */
/**
 * The Application responsible for configuring a single Drawing document within a parent Scene.
 * @extends {DocumentSheet}
 *
 * @param {Drawing} drawing               The Drawing object being configured
 * @param {DrawingConfigOptions} options  Additional application rendering options
 */
declare class DrawingConfig extends DocumentSheet {
  /** @override */
  override getData(options?: {}): {
    author: any;
    isDefault: any;
    fillTypes: any;
    scaledBezierFactor: number;
    fontFamilies: any;
    object: any;
    options: object;
    submitText: string;
  };
  /** @override */
  override close(options: any): Promise<void>;
  preview: any;
  /**
   * Reset the user Drawing configuration settings to their default values
   * @param {PointerEvent} event      The originating mouse-click event
   * @protected
   */
  protected _onResetDefaults(event: PointerEvent): void;
}
type DrawingConfigOptions = FormApplicationOptions;
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Drawing objects.
 * @extends {BasePlaceableHUD}
 * @param {Drawing} object                The {@link Drawing} this HUD is bound to.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class DrawingHUD extends BasePlaceableHUD {
  /** @inheritdoc */
  setPosition(options: any): void;
}
/**
 * The Application responsible for configuring a single AmbientLight document within a parent Scene.
 * @param {AmbientLight} light              The AmbientLight object for which settings are being configured
 * @param {DocumentSheetOptions} [options]  Additional application configuration options
 */
declare class AmbientLightConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Preserve a copy of the original document before any changes are made.
   * @type {object}
   */
  original: object;
  /** @inheritdoc */
  getData(options?: {}): any;
  /** @inheritdoc */
  _onChangeInput(event: any): Promise<void>;
  /**
   * Reset the values of advanced attributes to their default state.
   * @param {PointerEvent} event    The originating click event
   * @private
   */
  private _onResetForm;
  /**
   * Preview changes to the AmbientLight document as if they were true document updates.
   * @param {object} change         Data which simulates a document update
   * @param {boolean} [reset=false] To know if this preview change is a reset
   * @protected
   */
  protected _previewChanges(change: object, reset?: boolean | undefined): void;
  /**
   * Restore the true data for the AmbientLight document when the form is submitted or closed.
   * @protected
   */
  protected _resetPreview(): void;
  /** @inheritdoc */
  _onChangeTab(event: any, tabs: any, active: any): void;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): object;
}
/**
 * The Application responsible for configuring a single Note document within a parent Scene.
 * @param {NoteDocument} note               The Note object for which settings are being configured
 * @param {DocumentSheetOptions} [options]  Additional Application configuration options
 */
declare class NoteConfig extends DocumentSheet {
  /** @override */
  static override get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): any;
  /** @inheritdoc */
  _onChangeInput(event: any): Promise<any>;
  /**
   * Update disabled state of the custom icon field.
   * @protected
   */
  protected _updateCustomIcon(): void;
  /**
   * Update the list of pages.
   * @protected
   */
  protected _updatePageList(): void;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): object;
  /** @override */
  override close(options: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single AmbientSound document within a parent Scene.
 * @extends {DocumentSheet}
 *
 * @param {AmbientSound} sound              The sound object being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class AmbientSoundConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  close(options: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single Tile document within a parent Scene.
 * @param {Tile} tile                    The Tile object being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class TileConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  _onChangeInput(event: any): Promise<void>;
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Tile objects.
 * @extends {BasePlaceableHUD}
 */
declare class TileHUD extends BasePlaceableHUD {
  /**
   * @inheritdoc
   * @type {Tile}
   */
  object: Function;
  /** @inheritdoc */
  setPosition(options: any): void;
  /** @inheritdoc */
  _onClickControl(event: any): any;
  /**
   * Handle toggling the overhead state of the Tile.
   * @param {PointerEvent} event      The triggering click event
   * @param {boolean} overhead        Should the Tile be overhead?
   * @private
   */
  private _onToggleOverhead;
  /**
   * Control video playback by toggling play or paused state for a video Tile.
   * @param {object} event
   * @private
   */
  private _onControlVideo;
}
/**
 * The Application responsible for configuring a single Token document within a parent Scene.
 * @param {TokenDocument|Actor} object          The {@link TokenDocument} being configured or an {@link Actor} for whom
 *                                              to configure the {@link PrototypeToken}
 * @param {FormApplicationOptions} [options]    Application configuration options.
 */
declare class TokenConfig extends DocumentSheet {
  /** @inheritdoc */
  static get defaultOptions(): any;
  constructor(object: any, options: any);
  /**
   * The placed Token object in the Scene
   * @type {Token}
   */
  token: Function;
  /**
   * A reference to the Actor which the token depicts
   * @type {Actor}
   */
  actor: Actor;
  /**
   * Preserve a copy of the original document before any changes are made.
   * @type {object}
   */
  original: object;
  /**
   * A convenience accessor to test whether we are configuring the prototype Token for an Actor.
   * @type {boolean}
   */
  get isPrototype(): boolean;
  /** @inheritdoc */
  render(force?: boolean, options?: {}): TokenConfig | Application;
  /** @inheritDoc */
  _canUserView(user: any): any;
  /** @inheritdoc */
  getData(options?: {}): Promise<{
    cssClasses: string;
    isPrototype: boolean;
    hasAlternates: boolean;
    alternateImages: object;
    object: any;
    options: object;
    gridUnits: any;
    barAttributes: any;
    bar1: any;
    bar2: any;
    colorationTechniques: {
      [x: string]: ShaderTechnique;
    };
    visionModes: any;
    detectionModes: any;
    basicDetection: any;
    displayModes: any;
    actors: any;
    dispositions: any;
    lightAnimations: any;
    isGM: any;
    randomImgEnabled: any;
    scale: number;
    mirrorX: boolean;
    mirrorY: boolean;
  }>;
  /**
   * Get an Object of image paths and filenames to display in the Token sheet
   * @returns {Promise<object>}
   * @private
   */
  private _getAlternateTokenImages;
  /** @inheritDoc */
  _getSubmitData(updateData?: {}): object;
  /** @inheritDoc */
  _onChangeInput(event: any): Promise<void>;
  /**
   * Mimic changes to the Token document as if they were true document updates.
   * @param {object} change         Data which simulates a document update
   * @param {boolean} [reset=false] To know if this preview change is a reset
   * @protected
   */
  protected _previewChanges(change: object, reset?: boolean | undefined): void;
  /**
   * Reset the temporary preview of the Token when the form is submitted or closed.
   * @protected
   */
  protected _resetPreview(): void;
  /**
   * Handle Token assignment requests to update the default prototype Token
   * @param {MouseEvent} event  The left-click event on the assign token button
   * @private
   */
  private _onAssignToken;
  /**
   * Handle changing the attribute bar in the drop-down selector to update the default current and max value
   * @param {Event} event  The select input change event
   * @private
   */
  private _onBarChange;
  /**
   * Handle click events on a token configuration sheet action button
   * @param {PointerEvent} event    The originating click event
   * @protected
   */
  protected _onClickActionButton(event: PointerEvent): void;
  /**
   * Disable the user's ability to edit the token image field if wildcard images are enabled and that user does not have
   * file browser permissions.
   * @private
   */
  private _disableEditImage;
}
/**
 * A sheet that alters the values of the default Token configuration used when new Token documents are created.
 * @extends {TokenConfig}
 */
declare class DefaultTokenConfig extends TokenConfig {
  /**
   * The named world setting that stores the default Token configuration
   * @type {string}
   */
  static SETTING: string;
  /** @override */
  override getData(options?: {}): Promise<
    {
      cssClasses: string;
      isPrototype: boolean;
      hasAlternates: boolean;
      alternateImages: object;
      object: any;
      options: object;
      gridUnits: any;
      barAttributes: any;
      bar1: any;
      bar2: any;
      colorationTechniques: {
        [x: string]: ShaderTechnique;
      };
      visionModes: any;
      detectionModes: any;
      basicDetection: any;
      displayModes: any;
      actors: any;
      dispositions: any;
      lightAnimations: any;
      isGM: any;
      randomImgEnabled: any;
      scale: number;
      mirrorX: boolean;
      mirrorY: boolean;
    } & {
      object: any;
      isDefault: boolean;
      barAttributes: any;
      bar1: any;
      bar2: any;
    }
  >;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): any;
  /**
   * Reset the form to default values
   * @returns {Promise<void>}
   */
  reset(): Promise<void>;
  /** @inheritdoc */
  _onBarChange(): Promise<void>;
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Token objects.
 * This interface provides controls for visibility, attribute bars, elevation, status effects, and more.
 * @type {BasePlaceableHUD}
 */
declare class TokenHUD extends BasePlaceableHUD {
  /**
   * Track whether the status effects control palette is currently expanded or hidden
   * @type {boolean}
   * @private
   */
  private _statusEffects;
  /** @override */
  override bind(object: any): void;
  /**
   * Refresh the currently active state of all status effect icons in the Token HUD selector.
   */
  refreshStatusIcons(): void;
  /** @override */
  override setPosition(_position: any): void;
  /**
   * Get an array of icon paths which represent valid status effect choices
   * @private
   */
  private _getStatusEffectChoices;
  /** @inheritdoc */
  _onClickControl(event: any): void | Promise<void>;
  /**
   * Handle initial click to focus an attribute update field
   * @private
   */
  private _onAttributeClick;
  /**
   * Force field handling on an Enter keypress even if the value of the field did not change.
   * This is important to suppose use cases with negative number values.
   * @param {KeyboardEvent} event     The originating keydown event
   * @private
   */
  private _onAttributeKeydown;
  /**
   * Handle attribute bar update
   * @private
   */
  private _onAttributeUpdate;
  /**
   * Toggle Token combat state
   * @private
   */
  private _onToggleCombat;
  /**
   * Handle Token configuration button click
   * @private
   */
  private _onTokenConfig;
  /**
   * Handle left-click events to toggle the displayed state of the status effect selection palette
   * @param {MouseEvent }event
   * @private
   */
  private _onToggleStatusEffects;
  /**
   * Assign css selectors for the active state of the status effects selection palette
   * @private
   */
  private _toggleStatusEffects;
  /**
   * Handle toggling a token status effect icon
   * @private
   */
  private _onToggleEffect;
  /**
   * Handle toggling the target state for this Token
   * @private
   */
  private _onToggleTarget;
  #private;
}
/**
 * The Application responsible for configuring a single Wall document within a parent Scene.
 * @param {Wall} object                       The Wall object for which settings are being configured
 * @param {FormApplicationOptions} [options]  Additional options which configure the rendering of the configuration
 *                                            sheet.
 */
declare class WallConfig extends DocumentSheet {
  /**
   * An array of Wall ids that should all be edited when changes to this config form are submitted
   * @type {string[]}
   */
  editTargets: string[];
  /** @inheritdoc */
  render(force: any, options: any): Application | WallConfig;
  /** @inheritDoc */
  _onChangeInput(event: any): Promise<any>;
  #private;
}
/**
 * A simple application which supports popping a ChatMessage out to a separate UI window.
 * @extends {Application}
 * @param {ChatMessage} object            The {@link ChatMessage} object that is being popped out.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class ChatPopout extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  constructor(message: any, options: any);
  /**
   * The displayed Chat Message document
   * @type {ChatMessage}
   */
  message: ChatMessage;
  /** @inheritdoc */
  _renderInner(data: any, options: any): Promise<jQuery>;
}
/**
 * The Application responsible for displaying and editing the client and world settings for this world.
 * This form renders the settings defined via the game.settings.register API which have config = true
 */
declare class SettingsConfig extends PackageConfiguration {
  /**
   * Confirm if the user wishes to reload the application.
   * @param {object} [options]               Additional options to configure the prompt.
   * @param {boolean} [options.world=false]  Whether to reload all connected clients as well.
   * @returns {Promise<void>}
   */
  static reloadConfirm({
    world,
  }?:
    | {
        world?: boolean | undefined;
      }
    | undefined): Promise<void>;
  /** @inheritDoc */
  _prepareCategoryData(): {
    categories: Map<any, any>;
    total: number;
    user: any;
    canConfigure: any;
  };
  /**
   * Handle activating the button to configure User Role permissions
   * @param {Event} event   The initial button click event
   * @private
   */
  private _onClickSubmenu;
  /**
   * Preview font scaling as the setting is changed.
   * @param {Event} event  The triggering event.
   * @private
   */
  private _previewFontScaling;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * An interface for displaying the content of a CompendiumCollection.
 * @extends {Application}
 * @param {CompendiumCollection} collection  The {@link CompendiumCollection} object represented by this interface.
 * @param {ApplicationOptions} [options]     Application configuration options.
 */
declare class Compendium extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  constructor(collection: any, options: any);
  /**
   * The CompendiumCollection instance which is represented in this Compendium interface.
   * @type {CompendiumCollection}
   */
  collection: CompendiumCollection;
  /** @inheritdoc */
  get title(): any;
  /**
   * A convenience redirection back to the metadata object of the associated CompendiumCollection
   * @returns {object}
   */
  get metadata(): object;
  /** @inheritdoc */
  getData(options?: {}): Promise<{
    collection: CompendiumCollection;
    documentCls: any;
    index: any;
    documentPartial: string;
    footerButtons: {
      action: string;
      label: string;
      icon: any;
    }[];
  }>;
  /** @inheritdoc */
  close(options: any): Promise<void>;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Handle opening a single compendium entry by invoking the configured document class and its sheet
   * @param {MouseEvent} event      The originating click event
   * @private
   */
  private _onClickEntry;
  /**
   * Handle clicks on a footer button
   * @param {PointerEvent} event    The originating pointer event
   * @private
   */
  private _onClickFooterButton;
  /** @inheritdoc */
  _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  /** @inheritdoc */
  _canDragStart(selector: any): boolean;
  /** @inheritdoc */
  _canDragDrop(selector: any): any;
  /** @inheritdoc */
  _onDragStart(event: any): void;
  /** @inheritdoc */
  _onDrop(event: any): Promise<false | Document>;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Get Compendium entry context options
   * @returns {object[]}  The Compendium entry context options
   * @private
   */
  private _getEntryContextOptions;
}
/**
 * Game Invitation Links Reference
 * @extends {Application}
 */
declare class InvitationLinks extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /** @inheritdoc */
  getData(options?: {}): Promise<any>;
  /** @inheritdoc */
  activateListeners(html: any): void;
}
/**
 * Allows for viewing and editing of Keybinding Actions
 */
declare class KeybindingsConfig extends PackageConfiguration {
  /**
   * Transforms a Binding into a human-readable string representation
   * @param {KeybindingActionBinding} binding   The Binding
   * @returns {string}                           A human readable string
   * @private
   */
  private static _humanizeBinding;
  /** @inheritDoc */
  _categorizeEntry(namespace: any): {
    id: string;
    title: string;
  };
  /** @inheritDoc */
  _prepareCategoryData():
    | {
        categories: object[];
        total: number;
      }
    | {
        categories: Map<any, any>;
        total: number;
      };
  /**
   * Add faux-keybind actions that represent the possible Mouse Controls
   * @param {Map} categories    The current Map of Categories to add to
   * @returns {number}           The number of Actions added
   * @private
   */
  private _addMouseControlsReference;
  /**
   * Given an Binding and its parent Action, detects other Actions that might conflict with that binding
   * @param {string} actionId                   The namespaced Action ID the Binding belongs to
   * @param {KeybindingActionConfig} action     The Action config
   * @param {KeybindingActionBinding} binding   The Binding
   * @returns {KeybindingAction[]}
   * @private
   */
  private _detectConflictingActions;
  /** @override */
  override _onResetDefaults(event: any): Promise<any>;
  /**
   * Handle Control clicks
   * @param {MouseEvent} event
   * @private
   */
  private _onClickBindingControl;
  /**
   * Handle left-click events to show / hide a certain category
   * @param {MouseEvent} event
   * @private
   */
  private _onClickAdd;
  /**
   * Handle left-click events to show / hide a certain category
   * @param {MouseEvent} event
   * @private
   */
  private _onClickDelete;
  /**
   * Inserts a Binding into the Pending Edits object, creating a new Map entry as needed
   * @param {string} namespace
   * @param {string} action
   * @param {number} bindingIndex
   * @param {KeybindingActionBinding} binding
   * @private
   */
  private _addPendingEdit;
  /**
   * Toggle visibility of the Edit / Save UI
   * @param {MouseEvent} event
   * @private
   */
  private _onClickEditableBinding;
  /**
   * Toggle visibility of the Edit UI
   * @param {MouseEvent} event
   * @private
   */
  private _onDoubleClickKey;
  /**
   * Save the new Binding value and update the display of the UI
   * @param {MouseEvent} event
   * @private
   */
  private _onClickSaveBinding;
  /**
   * Given a clicked Action element, finds the parent Action
   * @param {MouseEvent|KeyboardEvent} event
   * @returns {{namespace: string, action: string, actionHtml: *}}
   * @private
   */
  private _getParentAction;
  /**
   * Given a Clicked binding control element, finds the parent Binding
   * @param {MouseEvent|KeyboardEvent} event
   * @returns {{bindingHtml: *, bindingId: string}}
   * @private
   */
  private _getParentBinding;
  /**
   * Iterates over all Pending edits, merging them in with unedited Bindings and then saving and resetting the UI
   * @returns {Promise<void>}
   * @private
   */
  private _savePendingEdits;
  /**
   * Processes input from the keyboard to form a list of pending Binding edits
   * @param {KeyboardEvent} event   The keyboard event
   * @private
   */
  private _onKeydownBindingInput;
  #private;
}
/**
 * The Module Management Application.
 * This application provides a view of which modules are available to be used and allows for configuration of the
 * set of modules which are active within the World.
 */
declare class ModuleManagement extends FormApplication {
  /**
   * The named game setting which persists module configuration.
   * @type {string}
   */
  static CONFIG_SETTING: string;
  /** @inheritdoc */
  static get defaultOptions(): any;
  constructor(...args: any[]);
  _filter: string;
  _expanded: boolean;
  /** @inheritdoc */
  get isEditable(): any;
  /** @inheritdoc */
  getData(options?: {}): {
    editable: any;
    filters: {
      id: string;
      label: string;
      count: any;
    }[];
    modules: any;
    expanded: boolean;
  };
  /**
   * Given a module, determines if it meets minimum and maximum compatibility requirements.
   * If not, it is marked as being unable to be activated.
   * If the package does not meet verified requirements, it is marked with a warning instead.
   * @param {object} module
   * @private
   */
  private _evaluateCompatibility;
  /** @inheritdoc */
  _getSubmitData(updateData?: {}): object;
  /** @inheritdoc */
  _updateObject(event: any, formData: any): Promise<any>;
  /**
   * Handle changes to a module checkbox to prompt for whether or not to enable dependencies
   * @private
   */
  private _onChangeCheckbox;
  /**
   * Handle a button-click to deactivate all modules
   * @private
   */
  private _onDeactivateAll;
  /**
   * Handle expanding or collapsing the display of descriptive elements
   * @private
   */
  private _onExpandCollapse;
  /**
   * Handle switching the module list filter.
   * @private
   */
  private _onFilterList;
  /** @inheritdoc */
  _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
}
/**
 * An application for configuring the permissions which are available to each User role.
 */
declare class PermissionConfig extends FormApplication {
  /** @override */
  static override get defaultOptions(): any;
  /** @override */
  override getData(options?: {}): Promise<{
    roles: {};
    permissions: object[];
  }>;
  /**
   * Prepare the permissions object used to render the configuration template
   * @param {object} current      The current permission configuration
   * @returns {object[]}          Permission data for sheet rendering
   * @private
   */
  private _getPermissions;
  /**
   * Handle button click to reset default settings
   * @param {Event} event   The initial button click event
   * @private
   */
  private _onResetDefaults;
  /** @override */
  override _onSubmit(event: any, options: any): Promise<any>;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * Support Info and Report
 * @type {Application}
 */
declare class SupportDetails extends Application {
  /**
   * A bundle of metrics for Support
   * @typedef {Object} SupportReportData
   * @property {number} coreVersion
   * @property {string} systemVersion
   * @property {number} activeModuleCount
   * @property {string} os
   * @property {string} client
   * @property {string} gpu
   * @property {number|string} maxTextureSize
   * @property {string} sceneDimensions
   * @property {number} grid
   * @property {float} padding
   * @property {number} walls
   * @property {number} lights
   * @property {number} sounds
   * @property {number} tiles
   * @property {number} tokens
   * @property {number} actors
   * @property {number} items
   * @property {number} journals
   * @property {number} tables
   * @property {number} playlists
   * @property {number} packs
   * @property {number} messages
   */
  /**
   * Collects a number of metrics that is useful for Support
   * @returns {SupportReportData}
   */
  static generateSupportReport(): {
    coreVersion: number;
    systemVersion: string;
    activeModuleCount: number;
    os: string;
    client: string;
    gpu: string;
    maxTextureSize: number | string;
    sceneDimensions: string;
    grid: number;
    padding: float;
    walls: number;
    lights: number;
    sounds: number;
    tiles: number;
    tokens: number;
    actors: number;
    items: number;
    journals: number;
    tables: number;
    playlists: number;
    packs: number;
    messages: number;
  };
  /**
   * Get a WebGL renderer information string
   * @param {WebGLRenderingContext} gl    The rendering context
   * @returns {string}                    The unmasked renderer string
   */
  static getWebGLRendererInfo(gl: WebGLRenderingContext): string;
  /**
   * Returns the support report data
   * @param options
   * @return {Object|Promise}
   */
  getData(options?: {}): Object | Promise<any>;
}
/**
 * A bundle of metrics for Support
 */
type SupportReportData = {
  coreVersion: number;
  systemVersion: string;
  activeModuleCount: number;
  os: string;
  client: string;
  gpu: string;
  maxTextureSize: number | string;
  sceneDimensions: string;
  grid: number;
  padding: float;
  walls: number;
  lights: number;
  sounds: number;
  tiles: number;
  tokens: number;
  actors: number;
  items: number;
  journals: number;
  tables: number;
  playlists: number;
  packs: number;
  messages: number;
};
/**
 * A management app for configuring which Tours are available or have been completed.
 */
declare class ToursManagement extends PackageConfiguration {
  /** @override */
  override _prepareCategoryData(): {
    categories: Map<any, any>;
    total: number;
  };
  /** @override */
  override _onResetDefaults(event: any): Promise<any>;
  /**
   * Handle Control clicks
   * @param {MouseEvent} event
   * @private
   */
  private _onClickControl;
}
/**
 * @typedef {FormApplicationOptions} WorldConfigOptions
 * @property {boolean} [create=false]  Whether the world is being created or updated.
 */
/**
 * The World Management setup application
 * @param {World} object                      The world being configured.
 * @param {WorldConfigOptions} [options]      Application configuration options.
 */
declare class WorldConfig extends FormApplication {
  /**
   * The website knowledge base URL.
   * @type {string}
   * @private
   */
  private static "__#11@#WORLD_KB_URL";
  /**
   * A semantic alias for the World object which is being configured by this form.
   * @type {World}
   */
  get world(): World;
  /** @override */
  override getData(options?: {}): {
    world: World;
    isCreate: any;
    submitText: string;
    nextDate: any;
    nextTime: any;
    worldKbUrl: string;
    inWorld: any;
  };
  /** @inheritDoc */
  _getSubmitData(updateData?: {}): object;
  /** @override */
  override _updateObject(event: any, formData: any): Promise<any>;
  /** @inheritDoc */
  activateEditor(
    name: any,
    options?: {},
    initialContent?: string
  ): Promise<any>;
  #private;
}
type WorldConfigOptions = FormApplicationOptions;
/**
 * An application for configuring data across all installed and active packages.
 */
declare class PackageConfiguration extends FormApplication {
  static get categoryOrder(): string[];
  /** @override */
  static override get defaultOptions(): any;
  /**
   * The name of the currently active tab.
   * @type {string}
   */
  get activeCategory(): string;
  /** @override */
  override getData(options?: {}): {
    categories: never[];
    total: number;
  };
  /**
   * Prepare the structure of category data which is rendered in this configuration form.
   * @abstract
   * @protected
   */
  protected _prepareCategoryData(): {
    categories: never[];
    total: number;
  };
  /**
   * Classify what Category an Action belongs to
   * @param {string} namespace                The entry to classify
   * @returns {{id: string, title: string}}   The category the entry belongs to
   * @protected
   */
  protected _categorizeEntry(namespace: string): {
    id: string;
    title: string;
  };
  /**
   * Reusable logic for how categories are sorted in relation to each other.
   * @param {object} a
   * @param {object} b
   * @protected
   */
  protected _sortCategories(a: object, b: object): any;
  /** @override */
  override _onChangeTab(event: any, tabs: any, active: any): void;
  /** @override */
  override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  /**
   * Handle button click to reset default settings
   * @param {Event} event   The initial button click event
   * @abstract
   * @protected
   */
  protected _onResetDefaults(event: Event): void;
}
/**
 * Render the Sidebar container, and after rendering insert Sidebar tabs.
 */
declare class Sidebar extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * Singleton application instances for each sidebar tab
   * @type {Object<SidebarTab>}
   */
  tabs: any;
  /**
   * Track whether the sidebar container is currently collapsed
   * @type {boolean}
   */
  _collapsed: boolean;
  /**
   * Return the name of the active Sidebar tab
   * @type {string}
   */
  get activeTab(): string;
  /**
   * Singleton application instances for each popout tab
   * @type {Object<SidebarTab>}
   */
  get popouts(): any;
  /** @override */
  override getData(options?: {}): {
    tabs: {
      chat: {
        tooltip: any;
        icon: any;
        notification: string;
      };
      combat: {
        tooltip: any;
        icon: any;
      };
      scenes: {
        tooltip: any;
        icon: any;
      };
      actors: {
        tooltip: any;
        icon: any;
      };
      items: {
        tooltip: any;
        icon: any;
      };
      journal: {
        tooltip: any;
        icon: any;
      };
      tables: {
        tooltip: any;
        icon: any;
      };
      cards: {
        tooltip: any;
        icon: any;
      };
      playlists: {
        tooltip: any;
        icon: any;
      };
      compendium: {
        tooltip: string;
        icon: string;
      };
      settings: {
        tooltip: string;
        icon: string;
      };
    };
  };
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /**
   * Expand the Sidebar container from a collapsed state.
   * Take no action if the sidebar is already expanded.
   */
  expand(): void;
  /**
   * Collapse the sidebar to a minimized state.
   * Take no action if the sidebar is already collapsed.
   */
  collapse(): void;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /** @override */
  override _onChangeTab(event: any, tabs: any, active: any): void;
  /**
   * Handle the special case of left-clicking a tab when the sidebar is collapsed.
   * @param {MouseEvent} event  The originating click event
   * @private
   */
  private _onLeftClickTab;
  /**
   * Handle right-click events on tab controls to trigger pop-out containers for each tab
   * @param {Event} event     The originating contextmenu event
   * @private
   */
  private _onRightClickTab;
  /**
   * Handle toggling of the Sidebar container's collapsed or expanded state
   * @param {Event} event
   * @private
   */
  private _onToggleCollapse;
}
/**
 * An abstract pattern followed by the different tabs of the sidebar
 * @abstract
 * @interface
 */
declare class SidebarTab extends Application {
  /** @override */
  static override get defaultOptions(): any;
  constructor(...args: any[]);
  /**
   * The base name of this sidebar tab
   * @type {string}
   */
  tabName: string;
  /**
   * A reference to the pop-out variant of this SidebarTab, if one exists
   * @type {SidebarTab}
   * @protected
   */
  protected _popout: SidebarTab;
  /**
   * Denote whether this is the original version of the sidebar tab, or a pop-out variant
   * @type {SidebarTab}
   */
  _original: SidebarTab;
  /** @override */
  override getData(options?: {}): Promise<{
    cssId: string;
    cssClass: any;
    tabName: string;
    user: any;
  }>;
  /** @override */
  override _render(force?: boolean, options?: {}): Promise<void>;
  /** @override */
  override _renderInner(data: any): Promise<jQuery>;
  /**
   * Activate this SidebarTab, switching focus to it
   */
  activate(): void;
  /** @override */
  override close(options: any): Promise<void>;
  /**
   * Create a second instance of this SidebarTab class which represents a singleton popped-out container
   * @returns {SidebarTab}   The popped out sidebar tab instance
   */
  createPopout(): SidebarTab;
  /**
   * Render the SidebarTab as a pop-out container
   */
  renderPopout(): void;
  /**
   * Handle lazy loading for sidebar images to only load them once they become observed
   * @param {HTMLElement[]} entries               The entries which are now observed
   * @param {IntersectionObserver} observer       The intersection observer instance
   */
  _onLazyLoadImage(
    entries: HTMLElement[],
    observer: IntersectionObserver
  ): void;
}
/**
 * @typedef {ApplicationOptions} SidebarDirectoryOptions
 * @property {string[]} [renderUpdateKeys]   A list of data property keys that will trigger a re-render of the tab if
 *                                           they are updated on a Document that this tab is responsible for.
 * @property {string} [contextMenuSelector]  The CSS selector that activates the context menu for displayed Documents.
 */
/**
 * A shared pattern for the sidebar directory which Actors, Items, and Scenes all use
 * @extends {SidebarTab}
 * @abstract
 * @interface
 *
 * @param {SidebarDirectoryOptions} [options]  Application configuration options.
 */
declare class SidebarDirectory extends SidebarTab {
  /**
   * A reference to the named Document type that this Sidebar Directory instance displays
   * @type {string}
   */
  static documentName: string;
  /**
   * The path to the template partial which renders a single Document within this directory
   * @type {string}
   */
  static documentPartial: string;
  /**
   * The path to the template partial which renders a single Folder within this directory
   * @type {string}
   */
  static folderPartial: string;
  /**
   * @override
   * @returns {SidebarDirectoryOptions}
   */
  static override get defaultOptions(): ApplicationOptions;
  /**
   * The WorldCollection instance which this Sidebar Directory displays.
   * @type {WorldCollection}
   */
  static get collection(): WorldCollection;
  /**
   * Given a Document type and a list of Document instances, set up the Folder tree
   * @param {Folder[]} folders        The Array of Folder objects to organize
   * @param {ClientDocument[]} documents  The Array of Document objects to organize
   * @returns {object}                A tree structure containing the folders and documents
   */
  static setupFolders(folders: Folder[], documents: ClientDocument[]): object;
  /**
   * Populate a single folder with child folders and content
   * This method is called recursively when building the folder tree
   * @param {Folder|null} folder          A parent folder being populated or null for the root node
   * @param {Folder[]} folders            Remaining unassigned folders which may be children of this one
   * @param {ClientDocument[]} documents  Remaining unassigned documents which may be children of this one
   * @param {object} [options={}]         Options which configure population
   * @param {boolean} [options.allowChildren=true]  Allow additional child folders
   * @private
   */
  private static _classifyFolderContent;
  /**
   * Sort two Documents by name, alphabetically.
   * @param {Document} a    Some Document
   * @param {Document} b    Some other Document
   * @returns {number}      The sort order between documents a and b
   * @private
   */
  private static _sortAlphabetical;
  /**
   * Sort two Documents using their numeric sort fields.
   * @param {Document} a    Some Document
   * @param {Document} b    Some other Document
   * @returns {number}      The sort order between documents a and b
   * @private
   */
  private static _sortStandard;
  constructor(options: any);
  /**
   * References to the set of Documents which are displayed in the Sidebar
   * @type {ClientDocument[]}
   */
  documents: ClientDocument[];
  /**
   * Reference the set of Folders which exist in this Sidebar
   * @type {Folder[]}
   */
  folders: Folder[];
  /**
   * Initialize the content of the directory by categorizing folders and documents into a hierarchical tree structure.
   */
  initialize(): void;
  tree: any;
  /** @inheritdoc */
  _render(force: any, context?: {}): Promise<void | SidebarDirectory>;
  /** @inheritdoc */
  getData(options?: {}): Promise<any>;
  /** @inheritdoc */
  _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  /**
   * Collapse all subfolders in this directory
   */
  collapseAll(): void;
  /** @inheritDoc */
  activateListeners(html: any): void;
  /**
   * Handle clicking on a Document name in the Sidebar directory
   * @param {Event} event   The originating click event
   * @protected
   */
  protected _onClickDocumentName(event: Event): any;
  /**
   * Handle new Document creation request
   * @param {MouseEvent} event    The originating button click event
   * @protected
   */
  protected _onCreateDocument(event: MouseEvent): Promise<any>;
  /**
   * Create a new Folder in this SidebarDirectory
   * @param {MouseEvent} event    The originating button click event
   * @protected
   */
  protected _onCreateFolder(event: MouseEvent): void;
  /**
   * Handle toggling the collapsed or expanded state of a folder within the directory tab
   * @param {MouseEvent} event    The originating click event
   * @protected
   */
  protected _toggleFolder(event: MouseEvent): void;
  /** @override */
  override _onDragStart(event: any): void;
  /** @override */
  override _canDragStart(selector: any): boolean;
  /**
   * Highlight folders as drop targets when a drag event enters or exits their area
   * @param {DragEvent} event     The DragEvent which is in progress
   */
  _onDragHighlight(event: DragEvent): void;
  /** @override */
  override _onDrop(event: any): Promise<any> | undefined;
  /**
   * Handle Document data being dropped into the directory.
   * @param {HTMLElement} target    The target element
   * @param {object} data           The data being dropped
   * @protected
   */
  protected _handleDroppedDocument(
    target: HTMLElement,
    data: object
  ): Promise<any>;
  /**
   * Handle Folder data being dropped into the directory.
   * @param {HTMLElement} target    The target element
   * @param {object} data           The data being dropped
   * @protected
   */
  protected _handleDroppedFolder(
    target: HTMLElement,
    data: object
  ): Promise<any>;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
   * @returns {object[]}   The Array of context options passed to the ContextMenu instance
   * @protected
   */
  protected _getFolderContextOptions(): object[];
  /**
   * Get the set of ContextMenu options which should be used for Documents in a SidebarDirectory
   * @returns {object[]}   The Array of context options passed to the ContextMenu instance
   * @protected
   */
  protected _getEntryContextOptions(): object[];
}
type SidebarDirectoryOptions = ApplicationOptions;
/**
 * The sidebar directory which organizes and displays world-level Actor documents.
 */
declare class ActorDirectory extends SidebarDirectory {
  constructor(...args: any[]);
  /** @override */
  override _canDragStart(selector: any): any;
  /** @override */
  override _onDragStart(event: any): false | undefined;
  /** @override */
  override _canDragDrop(selector: any): any;
  /** @override */
  override _getEntryContextOptions(): {
    name: string;
    icon: string;
    condition: (li: any) => boolean;
    callback: (li: any) => void;
  }[];
}
/**
 * The sidebar directory which organizes and displays world-level Cards documents.
 * @extends {SidebarDirectory}
 */
declare class CardsDirectory extends SidebarDirectory {}
/**
 * @typedef {ApplicationOptions} ChatLogOptions
 * @property {boolean} [stream]  Is this chat log being rendered as part of the stream view?
 */
/**
 * The sidebar directory which organizes and displays world-level ChatMessage documents.
 * @extends {SidebarTab}
 * @see {Sidebar}
 * @param {ChatLogOptions} [options]  Application configuration options.
 */
declare class ChatLog extends SidebarTab {
  /**
   * @override
   * @returns {ChatLogOptions}
   */
  static override get defaultOptions(): ApplicationOptions;
  /**
   * An enumeration of regular expression patterns used to match chat messages.
   * @enum {RegExp}
   */
  static MESSAGE_PATTERNS: {
    roll: RegExp;
    gmroll: RegExp;
    blindroll: RegExp;
    selfroll: RegExp;
    publicroll: RegExp;
    ic: RegExp;
    ooc: RegExp;
    emote: RegExp;
    whisper: RegExp;
    reply: RegExp;
    gm: RegExp;
    players: RegExp;
    macro: RegExp;
    invalid: RegExp;
  };
  /**
   * The set of commands that can be processed over multiple lines.
   * @type {Set<string>}
   */
  static MULTILINE_COMMANDS: Set<string>;
  /**
   * Parse a chat string to identify the chat command (if any) which was used
   * @param {string} message    The message to match
   * @returns {string[]}        The identified command and regex match
   */
  static parse(message: string): string[];
  /**
   * Handle dropping of transferred data onto the chat editor
   * @param {DragEvent} event     The originating drop event which triggered the data transfer
   * @private
   */
  private static _onDropTextAreaData;
  /**
   * Update roll mode select dropdowns when the setting is changed
   * @param {string} mode     The new roll mode setting
   */
  static _setRollMode(mode: string): void;
  constructor(options: any);
  /**
   * Track any pending text which the user has submitted in the chat log textarea
   * @type {string}
   * @private
   */
  private _pendingText;
  /**
   * Track the history of the past 5 sent messages which can be accessed using the arrow keys
   * @type {object[]}
   * @private
   */
  private _sentMessages;
  /**
   * Track which remembered message is being currently displayed to cycle properly
   * @type {number}
   * @private
   */
  private _sentMessageIndex;
  /**
   * Track the time when the last message was sent to avoid flooding notifications
   * @type {number}
   * @private
   */
  private _lastMessageTime;
  /**
   * Track the id of the last message displayed in the log
   * @type {string|null}
   * @private
   */
  private _lastId;
  /**
   * Track the last received message which included the user as a whisper recipient.
   * @type {ChatMessage|null}
   * @private
   */
  private _lastWhisper;
  /**
   * A reference to the chat text entry bound key method
   * @type {Function|null}
   * @private
   */
  private _onChatKeyDownBinding;
  /**
   * A reference to the Messages collection that the chat log displays
   * @type {Messages}
   */
  get collection(): Messages;
  /** @override */
  override getData(options?: {}): Promise<any>;
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /**
   * Render a batch of additional messages, prepending them to the top of the log
   * @param {jQuery} html     The rendered jQuery HTML object
   * @param {number} size     The batch size to include
   * @returns {Promise<void>}
   * @private
   */
  private _renderBatch;
  /**
   * Delete a single message from the chat log
   * @param {string} messageId    The ChatMessage document to remove from the log
   * @param {boolean} [deleteAll] Is this part of a flush operation to delete all messages?
   */
  deleteMessage(messageId: string, { deleteAll }?: boolean | undefined): void;
  /**
   * Trigger a notification that alerts the user visually and audibly that a new chat log message has been posted
   * @param {ChatMessage} message         The message generating a notification
   */
  notify(message: ChatMessage): void;
  /**
   * Post a single chat message to the log
   * @param {ChatMessage} message   A ChatMessage document instance to post to the log
   * @param {object} [options={}]   Additional options for how the message is posted to the log
   * @param {string} [options.before] An existing message ID to append the message before, by default the new message is
   *                                  appended to the end of the log.
   * @param {boolean} [options.notify] Trigger a notification which shows the log as having a new unread message.
   * @returns {Promise<void>}       A Promise which resolves once the message is posted
   */
  postOne(
    message: ChatMessage,
    {
      before,
      notify,
    }?:
      | {
          before?: string | undefined;
          notify?: boolean | undefined;
        }
      | undefined
  ): Promise<void>;
  /**
   * Scroll the chat log to the bottom
   * @param {object} options
   * @param {boolean} options.popout If a popout exists, scroll it too
   * @private
   */
  private scrollBottom;
  /**
   * Update the content of a previously posted message after its data has been replaced
   * @param {ChatMessage} message   The ChatMessage instance to update
   * @param {boolean} notify        Trigger a notification which shows the log as having a new unread message
   */
  updateMessage(message: ChatMessage, notify?: boolean): Promise<void>;
  /**
   * Update the displayed timestamps for every displayed message in the chat log.
   * Timestamps are displayed in a humanized "timesince" format.
   */
  updateTimestamps(): void;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Prepare the data object of chat message data depending on the type of message being posted
   * @param {string} message         The original string of the message content
   * @returns {Promise<Object|void>} The prepared chat data object, or void if we were executing a macro instead
   */
  processMessage(message: string): Promise<Object | void>;
  /**
   * Process messages which are posted using a dice-roll command
   * @param {string} command          The chat command type
   * @param {RegExpMatchArray[]} matches Multi-line matched roll expressions
   * @param {Object} chatData         The initial chat data
   * @param {Object} createOptions    Options used to create the message
   * @private
   */
  private _processDiceCommand;
  /**
   * Process messages which are posted using a chat whisper command
   * @param {string} command          The chat command type
   * @param {RegExpMatchArray} match  The matched RegExp expressions
   * @param {Object} chatData         The initial chat data
   * @param {Object} createOptions    Options used to create the message
   * @private
   */
  private _processWhisperCommand;
  /**
   * Process messages which are posted using a chat whisper command
   * @param {string} command          The chat command type
   * @param {RegExpMatchArray} match  The matched RegExp expressions
   * @param {Object} chatData         The initial chat data
   * @param {Object} createOptions    Options used to create the message
   * @private
   */
  private _processChatCommand;
  /**
   * Process messages which execute a macro.
   * @param {string} command  The chat command typed.
   * @param {RegExpMatchArray} match  The RegExp matches.
   * @private
   */
  private _processMacroCommand;
  /**
   * Add a sent message to an array of remembered messages to be re-sent if the user pages up with the up arrow key
   * @param {string} message    The message text being remembered
   * @private
   */
  private _remember;
  /**
   * Recall a previously sent message by incrementing up (1) or down (-1) through the sent messages array
   * @param {number} direction    The direction to recall, positive for older, negative for more recent
   * @return {string}             The recalled message, or an empty string
   * @private
   */
  private _recall;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Get the ChatLog entry context options
   * @return {object[]}   The ChatLog entry context options
   * @private
   */
  private _getEntryContextOptions;
  /**
   * Handle keydown events in the chat entry textarea
   * @param {KeyboardEvent} event
   * @private
   */
  private _onChatKeyDown;
  /**
   * Handle setting the preferred roll mode
   * @param {Event} event
   * @private
   */
  private _onChangeRollMode;
  /**
   * Handle single message deletion workflow
   * @param {Event} event
   * @private
   */
  private _onDeleteMessage;
  /**
   * Handle clicking of dice tooltip buttons
   * @param {Event} event
   * @private
   */
  private _onDiceRollClick;
  /**
   * Handle click events to export the chat log
   * @param {Event} event
   * @private
   */
  private _onExportLog;
  /**
   * Handle click events to flush the chat log
   * @param {Event} event
   * @private
   */
  private _onFlushLog;
  /**
   * Handle scroll events within the chat log container
   * @param {UIEvent} event   The initial scroll event
   * @private
   */
  private _onScrollLog;
  #private;
}
/**
 * An enumeration of regular expression patterns used to match chat messages.
 */
type MESSAGE_PATTERNS = RegExp;
type ChatLogOptions = ApplicationOptions;
/**
 * The sidebar directory which organizes and displays world-level Combat documents.
 */
declare class CombatTracker extends SidebarTab {
  constructor(options: any);
  /**
   * Record a reference to the currently highlighted Token
   * @type {Token|null}
   * @private
   */
  private _highlighted;
  /**
   * Record the currently tracked Combat encounter
   * @type {Combat|null}
   */
  viewed: Combat | null;
  /**
   * Return an array of Combat encounters which occur within the current Scene.
   * @type {Combat[]}
   */
  get combats(): Combat[];
  /**
   * Initialize the combat tracker to display a specific combat encounter.
   * If no encounter is provided, the tracker will be initialized with the first encounter in the viewed scene.
   * @param {object} [options]                   Additional options to configure behavior.
   * @param {Combat|null} [options.combat=null]  The combat encounter to initialize
   * @param {boolean} [options.render=true]      Whether to re-render the sidebar after initialization
   */
  initialize({
    combat,
    render,
  }?:
    | {
        combat?: Combat | null | undefined;
        render?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Scroll the combat log container to ensure the current Combatant turn is centered vertically
   */
  scrollToTurn(): void;
  /** @inheritdoc */
  getData(options?: {}): Promise<any>;
  /**
   * Retrieve a source image for a combatant.
   * @param {Combatant} combatant         The combatant queried for image.
   * @returns {Promise<string>}           The source image attributed for this combatant.
   * @protected
   */
  protected _getCombatantThumbnail(combatant: Function): Promise<string>;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Handle new Combat creation request
   * @param {Event} event
   * @private
   */
  private _onCombatCreate;
  /**
   * Handle a Combat cycle request
   * @param {Event} event
   * @private
   */
  private _onCombatCycle;
  /**
   * Handle click events on Combat control buttons
   * @private
   * @param {Event} event   The originating mousedown event
   */
  private _onCombatControl;
  /**
   * Handle a Combatant control toggle
   * @private
   * @param {Event} event   The originating mousedown event
   */
  private _onCombatantControl;
  /**
   * Handle toggling the defeated status effect on a combatant Token
   * @param {Combatant} combatant     The combatant data being modified
   * @returns {Promise}                A Promise that resolves after all operations are complete
   * @private
   */
  private _onToggleDefeatedStatus;
  /**
   * Handle pinging a combatant Token
   * @param {Combatant} combatant     The combatant data
   * @returns {Promise}
   * @protected
   */
  protected _onPingCombatant(combatant: Function): Promise<any>;
  /**
   * Handle mouse-down event on a combatant name in the tracker
   * @param {Event} event   The originating mousedown event
   * @returns {Promise}     A Promise that resolves once the pan is complete
   * @private
   */
  private _onCombatantMouseDown;
  _clickTime: number | undefined;
  /**
   * Handle mouse-hover events on a combatant in the tracker
   * @private
   */
  private _onCombatantHoverIn;
  /**
   * Handle mouse-unhover events for a combatant in the tracker
   * @private
   */
  private _onCombatantHoverOut;
  /**
   * Highlight a hovered combatant in the tracker.
   * @param {Combatant} combatant The Combatant
   * @param {boolean} hover       Whether they are being hovered in or out.
   */
  hoverCombatant(combatant: Function, hover: boolean): void;
  /** @inheritdoc */
  _contextMenu(html: any): void;
  /**
   * Get the Combatant entry context options
   * @returns {object[]}   The Combatant entry context options
   * @private
   */
  private _getEntryContextOptions;
  /**
   * Display a dialog which prompts the user to enter a new initiative value for a Combatant
   * @param {jQuery} li
   * @private
   */
  private _onConfigureCombatant;
}
/**
 * A compendium of knowledge arcane and mystical!
 */
declare class CompendiumDirectory extends SidebarTab {
  /** @override */
  override getData(options?: {}): Promise<any>;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Get the sidebar directory entry context options
   * @returns {Object}   The sidebar entry context options
   * @private
   */
  private _getEntryContextOptions;
  /**
   * Handle a Compendium Pack creation request
   * @param {PointerEvent} event      The originating click event
   * @private
   */
  private _onCreateCompendium;
  /**
   * Handle a Compendium Pack deletion request
   * @param {object} pack   The pack object requested for deletion
   * @private
   */
  private _onDeleteCompendium;
  /**
   * Toggle the compendium entry open/closed state in the sidebar.
   * @param {string} pack  The name of the compendium pack.
   * @internal
   */
  _toggleOpenState(pack: string): void;
}
/**
 * The sidebar directory which organizes and displays world-level Item documents.
 */
declare class ItemDirectory extends SidebarDirectory {
  /** @override */
  override _canDragDrop(selector: any): any;
  /** @override */
  override _getEntryContextOptions(): {
    name: string;
    icon: string;
    condition: (li: any) => boolean;
    callback: (li: any) => void;
  }[];
}
/**
 * The sidebar directory which organizes and displays world-level JournalEntry documents.
 * @extends {SidebarDirectory}
 */
declare class JournalDirectory extends SidebarDirectory {}
/**
 * The directory, not displayed in the sidebar, which organizes and displays world-level Macro documents.
 * @extends {SidebarDirectory}
 *
 * @see {@link Macros}        The WorldCollection of Macro Documents
 * @see {@link Macro}         The Macro Document
 * @see {@link MacroConfig}   The Macro Configuration Sheet
 */
declare class MacroDirectory extends SidebarDirectory {
  constructor(options?: {});
}
/**
 * The sidebar directory which organizes and displays world-level Playlist documents.
 * @extends {SidebarDirectory}
 */
declare class PlaylistDirectory extends SidebarDirectory {
  /**
   * Track the playlist IDs which are currently expanded in their display
   * @type {Set<string>}
   */
  _expanded: Set<string>;
  /**
   * Are the global volume controls currently expanded?
   * @type {boolean}
   * @private
   */
  private _volumeExpanded;
  /**
   * Cache the set of Playlist documents that are displayed as playing when the directory is rendered
   * @type {Playlist[]}
   */
  _playingPlaylists: Playlist[];
  /**
   * Cache the set of PlaylistSound documents that are displayed as playing when the directory is rendered
   * @type {PlaylistSound[]}
   */
  _playingSounds: PlaylistSound[];
  /**
   * Initialize the set of Playlists which should be displayed in an expanded form
   * @returns {Set<string>}
   * @private
   */
  private _createExpandedSet;
  /**
   * Return an Array of the Playlist documents which are currently playing
   * @type {Playlist[]}
   */
  get playing(): Playlist[];
  /**
   * Whether the 'currently playing' element is pinned to the top or bottom of the display.
   * @type {string}
   * @private
   */
  private get _playingLocation();
  _playingSoundsData: any[] | undefined;
  /**
   * Augment the tree directory structure with playlist-level data objects for rendering
   * @param {object} node   The tree leaf node being prepared
   * @private
   */
  private _prepareTreeData;
  /**
   * Create an object of rendering data for each Playlist document being displayed
   * @param {Playlist} playlist   The playlist to display
   * @returns {object}            The data for rendering
   * @private
   */
  private _preparePlaylistData;
  /**
   * Get the icon used to represent the "play/stop" icon for the PlaylistSound
   * @param {PlaylistSound} sound   The sound being rendered
   * @returns {string}              The icon that should be used
   * @private
   */
  private _getPlayIcon;
  /**
   * Get the icon used to represent the pause/loading icon for the PlaylistSound
   * @param {PlaylistSound} sound   The sound being rendered
   * @returns {string}              The icon that should be used
   * @private
   */
  private _getPauseIcon;
  /**
   * Given a constant playback mode, provide the FontAwesome icon used to display it
   * @param {number} mode
   * @return {string}
   * @private
   */
  private _getModeIcon;
  /**
   * Given a constant playback mode, provide the string tooltip used to describe it
   * @param {number} mode
   * @return {string}
   * @private
   */
  private _getModeTooltip;
  /**
   * Handle global volume change for the playlist sidebar
   * @param {MouseEvent} event   The initial click event
   * @private
   */
  private _onGlobalVolume;
  /**
   * Handle Playlist collapse toggle
   * @param {MouseEvent} event   The initial click event
   * @private
   */
  private _onPlaylistCollapse;
  /**
   * Handle global volume control collapse toggle
   * @param {MouseEvent} event   The initial click event
   * @private
   */
  private _onVolumeCollapse;
  /**
   * Helper method to render the expansion or collapse of playlists
   * @private
   */
  private _collapse;
  /**
   * Handle Playlist playback state changes
   * @param {MouseEvent} event    The initial click event
   * @param {boolean} playing     Is the playlist now playing?
   * @private
   */
  private _onPlaylistPlay;
  /**
   * Handle advancing the playlist to the next (or previous) sound
   * @param {MouseEvent} event    The initial click event
   * @param {string} action       The control action requested
   * @private
   */
  private _onPlaylistSkip;
  /**
   * Handle cycling the playback mode for a Playlist
   * @param {MouseEvent} event   The initial click event
   * @private
   */
  private _onPlaylistToggleMode;
  /**
   * Handle Playlist track addition request
   * @param {MouseEvent} event   The initial click event
   * @private
   */
  private _onSoundCreate;
  /**
   * Modify the playback state of a Sound within a Playlist
   * @param {MouseEvent} event    The initial click event
   * @param {string} action       The sound control action performed
   * @private
   */
  private _onSoundPlay;
  /**
   * Handle volume adjustments to sounds within a Playlist
   * @param {Event} event   The initial change event
   * @private
   */
  private _onSoundVolume;
  /**
   * Handle changes to the sound playback mode
   * @param {Event} event   The initial click event
   * @private
   */
  private _onSoundToggleMode;
  _onPlayingPin(): Promise<any>;
  /**
   * Update the displayed timestamps for all currently playing audio sources.
   * Runs on an interval every 1000ms.
   * @private
   */
  private _updateTimestamps;
  /**
   * Format the displayed timestamp given a number of seconds as input
   * @param {number} seconds    The current playback time in seconds
   * @returns {string}          The formatted timestamp
   * @private
   */
  private _formatTimestamp;
  /**
   * Get context menu options for individual sound effects
   * @return {Object}   The context options for each sound
   * @private
   */
  private _getSoundContextOptions;
  /** @inheritdoc */
  _onDrop(event: any): Promise<any>;
}
/**
 * The sidebar directory which organizes and displays world-level RollTable documents.
 * @extends {SidebarDirectory}
 */
declare class RollTableDirectory extends SidebarDirectory {}
/**
 * The sidebar directory which organizes and displays world-level Scene documents.
 * @extends {SidebarDirectory}
 */
declare class SceneDirectory extends SidebarDirectory {
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void | SceneDirectory>;
}
/**
 * The sidebar tab which displays various game settings, help messages, and configuration options.
 * The Settings sidebar is the furthest-to-right using a triple-cogs icon.
 * @extends {SidebarTab}
 */
declare class Settings extends SidebarTab {
  /** @override */
  override getData(options?: {}): Promise<any>;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Delegate different actions for different settings buttons
   * @param {MouseEvent} event    The originating click event
   * @private
   */
  private _onSettingsButton;
  /**
   * Executes with the update notification pip is clicked
   * @param {MouseEvent} event    The originating click event
   * @private
   */
  private _onUpdateNotificationClick;
}
/**
 * A simple window application which shows the built documentation pages within an iframe
 * @type {Application}
 */
declare class FrameViewer extends Application {
  constructor(url: any, options: any);
  url: any;
  /** @override */
  override getData(options?: {}): Promise<{
    src: any;
  }>;
  /** @override */
  override close(options: any): Promise<void>;
}
/**
 * Get a template from the server by fetch request and caching the retrieved result
 * @param {string} path           The web-accessible HTML template URL
 * @param {string} [id]           An ID to register the partial with.
 * @returns {Promise<Function>}   A Promise which resolves to the compiled Handlebars template
 */
declare function getTemplate(
  path: string,
  id?: string | undefined
): Promise<Function>;
/**
 * Load and cache a set of templates by providing an Array of paths
 * @param {string[]|Object<string>} paths  An array of template file paths to load, or an object of Handlebars partial
 *                                         IDs to paths.
 * @returns {Promise<Function[]>}
 *
 * @example Loading a list of templates.
 * ```js
 * await loadTemplates(["templates/apps/foo.html", "templates/apps/bar.html"]);
 * ```
 * ```hbs
 * <!-- Include a pre-loaded template as a partial -->
 * {{> "templates/apps/foo.html" }}
 * ```
 *
 * @example Loading an object of templates.
 * ```js
 * await loadTemplates({
 *   foo: "templates/apps/foo.html",
 *   bar: "templates/apps/bar.html"
 * });
 * ```
 * ```hbs
 * <!-- Include a pre-loaded template as a partial -->
 * {{> foo }}
 * ```
 */
declare function loadTemplates(
  paths: string[] | Object<string>
): Promise<Function[]>;
/**
 * Get and render a template using provided data and handle the returned HTML
 * Support asynchronous file template file loading with a client-side caching layer
 *
 * Allow resolution of prototype methods and properties since this all occurs within the safety of the client.
 * @see {@link https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access}
 *
 * @param {string} path             The file path to the target HTML template
 * @param {Object} data             A data object against which to compile the template
 *
 * @returns {Promise<string>}        Returns the compiled and rendered template as a string
 */
declare function renderTemplate(path: string, data: Object): Promise<string>;
/**
 * A collection of Handlebars template helpers which can be used within HTML templates.
 */
declare class HandlebarsHelpers {
  /**
   * For checkboxes, if the value of the checkbox is true, add the "checked" property, otherwise add nothing.
   * @returns {string}
   *
   * @example
   * ```hbs
   * <label>My Checkbox</label>
   * <input type="checkbox" name="myCheckbox" {{checked myCheckbox}}>
   * ```
   */
  static checked(value: any): string;
  /**
   * For use in form inputs. If the supplied value is truthy, add the "disabled" property, otherwise add nothing.
   * @returns {string}
   *
   * @example
   * ```hbs
   * <button type="submit" {{disabled myValue}}>Submit</button>
   * ```
   */
  static disabled(value: any): string;
  /**
   * Concatenate a number of string terms into a single string.
   * This is useful for passing arguments with variable names.
   * @param {string[]} values             The values to concatenate
   * @returns {Handlebars.SafeString}
   *
   * @example Concatenate several string parts to create a dynamic variable
   * ```hbs
   * {{filePicker target=(concat "faces." i ".img") type="image"}}
   * ```
   */
  static concat(...values: string[]): Handlebars.SafeString;
  /**
   * Render a pair of inputs for selecting a color.
   * @param {object} options              Helper options
   * @param {string} [options.name]       The name of the field to create
   * @param {string} [options.value]      The current color value
   * @param {string} [options.default]    A default color string if a value is not provided
   * @returns {Handlebars.SafeString}
   *
   * @example
   * ```hbs
   * {{colorPicker name="myColor" value=myColor default="#000000"}}
   * ```
   */
  static colorPicker(options: {
    name?: string | undefined;
    value?: string | undefined;
    default?: string | undefined;
  }): Handlebars.SafeString;
  /**
   * @typedef {object} TextEditorOptions
   * @property {string} [target]             The named target data element
   * @property {boolean} [button]            Include a button used to activate the editor later?
   * @property {string} [class]              A specific CSS class to add to the editor container
   * @property {boolean} [editable=true]     Is the text editor area currently editable?
   * @property {string} [engine=tinymce]     The editor engine to use, see {@link TextEditor.create}.
   * @property {boolean} [collaborate=false] Whether to turn on collaborative editing features for ProseMirror.
   *
   * The below options are deprecated since v10 and should be avoided.
   * @property {boolean} [owner]             Is the current user an owner of the data?
   * @property {boolean} [documents=true]    Replace dynamic document links?
   * @property {Object|Function} [rollData]  The data object providing context for inline rolls
   * @property {string} [content=""]         The original HTML content as a string
   */
  /**
   * Construct an editor element for rich text editing with TinyMCE or ProseMirror.
   * @param {[string, TextEditorOptions]} args  The content to display and edit, followed by handlebars options.
   * @returns {Handlebars.SafeString}
   *
   * @example
   * ```hbs
   * {{editor world.description target="description" button=false engine="prosemirror" collaborate=false}}
   * ```
   */
  static editor(
    args_0: string,
    args_1: {
      /**
       * The named target data element
       */
      target?: string | undefined;
      /**
       * Include a button used to activate the editor later?
       */
      button?: boolean | undefined;
      /**
       * A specific CSS class to add to the editor container
       */
      class?: string | undefined;
      /**
       * Is the text editor area currently editable?
       */
      editable?: boolean | undefined;
      /**
       * The editor engine to use, see {@link TextEditor.create }.
       */
      engine?: string | undefined;
      /**
       * Whether to turn on collaborative editing features for ProseMirror.
       *
       * The below options are deprecated since v10 and should be avoided.
       */
      collaborate?: boolean | undefined;
      /**
       * Is the current user an owner of the data?
       */
      owner?: boolean | undefined;
      /**
       * Replace dynamic document links?
       */
      documents?: boolean | undefined;
      /**
       * The data object providing context for inline rolls
       */
      rollData?: Object | Function | undefined;
      /**
       * The original HTML content as a string
       */
      content?: string | undefined;
    }
  ): Handlebars.SafeString;
  /**
   * Render a file-picker button linked to an `<input>` field
   * @param {object} options              Helper options
   * @param {string} [options.type]       The type of FilePicker instance to display
   * @param {string} [options.target]     The field name in the target data
   * @returns {Handlebars.SafeString|string}
   *
   * @example
   * ```hbs
   * {{filePicker type="image" target="img"}}
   * ```
   */
  static filePicker(options: {
    type?: string | undefined;
    target?: string | undefined;
  }): Handlebars.SafeString | string;
  /**
   * Translate a provided string key by using the loaded dictionary of localization strings.
   * @returns {string}
   *
   * @example Translate a provided localization string, optionally including formatting parameters
   * ```hbs
   * <label>{{localize "ACTOR.Create"}}</label> <!-- "Create Actor" -->
   * <label>{{localize "CHAT.InvalidCommand" command=foo}}</label> <!-- "foo is not a valid chat message command." -->
   * ```
   */
  static localize(value: any, options: any): string;
  /**
   * A string formatting helper to display a number with a certain fixed number of decimals and an explicit sign.
   * @param {number} value              A numeric value to format
   * @param {object} options            Additional options which customize the resulting format
   * @param {number} [options.decimals=0]   The number of decimal places to include in the resulting string
   * @param {boolean} [options.sign=false]  Whether to include an explicit "+" sign for positive numbers   *
   * @returns {Handlebars.SafeString}   The formatted string to be included in a template
   *
   * @example
   * ```hbs
   * {{formatNumber 5.5}} <!-- 5.5 -->
   * {{formatNumber 5.5 decimals=2}} <!-- 5.50 -->
   * {{formatNumber 5.5 decimals=2 sign=true}} <!-- +5.50 -->
   *  ```
   */
  static numberFormat(
    value: number,
    options: {
      decimals?: number | undefined;
      sign?: boolean | undefined;
    }
  ): Handlebars.SafeString;
  /**
   * Render a form input field of type number with value appropriately rounded to step size.
   * @returns {Handlebars.SafeString}
   *
   * @example
   * ```hbs
   * {{numberInput value name="numberField" step=1 min=0 max=10}}
   * ```
   */
  static numberInput(value: any, options: any): Handlebars.SafeString;
  /**
   * A helper to create a set of radio checkbox input elements in a named set.
   * The provided keys are the possible radio values while the provided values are human readable labels.
   *
   * @param {string} name         The radio checkbox field name
   * @param {object} choices      A mapping of radio checkbox values to human readable labels
   * @param {object} options      Options which customize the radio boxes creation
   * @param {string} options.checked    Which key is currently checked?
   * @param {boolean} options.localize  Pass each label through string localization?
   * @returns {Handlebars.SafeString}
   *
   * @example The provided input data
   * ```js
   * let groupName = "importantChoice";
   * let choices = {a: "Choice A", b: "Choice B"};
   * let chosen = "a";
   * ```
   *
   * @example The template HTML structure
   * ```hbs
   * <div class="form-group">
   *   <label>Radio Group Label</label>
   *   <div class="form-fields">
   *     {{radioBoxes groupName choices checked=chosen localize=true}}
   *   </div>
   * </div>
   * ```
   */
  static radioBoxes(
    name: string,
    choices: object,
    options: {
      checked: string;
      localize: boolean;
    }
  ): Handlebars.SafeString;
  /**
   * Render a pair of inputs for selecting a value in a range.
   * @param {object} options            Helper options
   * @param {string} [options.name]     The name of the field to create
   * @param {number} [options.value]    The current range value
   * @param {number} [options.min]      The minimum allowed value
   * @param {number} [options.max]      The maximum allowed value
   * @param {number} [options.step]     The allowed step size
   * @returns {Handlebars.SafeString}
   *
   * @example
   * ```hbs
   * {{rangePicker name="foo" value=bar min=0 max=10 step=1}}
   * ```
   */
  static rangePicker(options: {
    name?: string | undefined;
    value?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
    step?: number | undefined;
  }): Handlebars.SafeString;
  /**
   * A helper to assign an `<option>` within a `<select>` block as selected based on its value
   * Escape the string as handlebars would, then escape any regexp characters in it
   * @param {string} value    The value of the option
   * @returns {Handlebars.SafeString}
   *
   * @example
   * ```hbs
   * <select>
   * {{#select selected}}
   *   <option value="a">Choice A</option>
   *   <option value="b">Choice B</option>
   * {{/select}}
   * </select>
   */
  static select(selected: any, options: any): Handlebars.SafeString;
  /**
   * A helper to create a set of &lt;option> elements in a &lt;select> block based on a provided dictionary.
   * The provided keys are the option values while the provided values are human readable labels.
   * This helper supports both single-select as well as multi-select input fields.
   *
   * @param {object|Array<object>>} choices      A mapping of radio checkbox values to human-readable labels
   * @param {object} options                     Helper options
   * @param {string|string[]} [options.selected] Which key or array of keys that are currently selected?
   * @param {boolean} [options.localize=false]   Pass each label through string localization?
   * @param {string} [options.blank]             Add a blank option as the first option with this label
   * @param {boolean} [options.sort]             Sort the options by their label after localization
   * @param {string} [options.nameAttr]          Look up a property in the choice object values to use as the option value
   * @param {string} [options.labelAttr]         Look up a property in the choice object values to use as the option label
   * @param {boolean} [options.inverted=false]   Use the choice object value as the option value, and the key as the label
   *                                             instead of vice-versa
   * @returns {Handlebars.SafeString}
   *
   * @example The provided input data
   * ```js
   * let choices = {a: "Choice A", b: "Choice B"};
   * let value = "a";
   * ```
   * The template HTML structure
   * ```hbs
   * <select name="importantChoice">
   *   {{selectOptions choices selected=value localize=true}}
   * </select>
   * ```
   * The resulting HTML
   * ```html
   * <select name="importantChoice">
   *   <option value="a" selected>Choice A</option>
   *   <option value="b">Choice B</option>
   * </select>
   * ```
   *
   * @example Using an Array as choices
   * ```js
   * let choices = [{a: "Choice A"}, {b: "Choice B"}];
   * let value = "a";
   * ```
   * The template HTML structure
   * ```hbs
   * <select name="importantChoice">
   *   {{selectOptions choices selected=value localize=true}}
   * </select>
   * ```
   * The resulting HTML
   * ```html
   * <select name="importantChoice">
   *   <option value="a" selected>Choice A</option>
   *   <option value="b">Choice B</option>
   * </select>
   * ```
   *
   * @example Using inverted choices
   * ```js
   * let choices = {"Choice A": "a", "Choice B": "b"};
   * let value = "a";
   * ```
   *  The template HTML structure
   *  ```hbs
   * <select name="importantChoice">
   *   {{selectOptions choices selected=value inverted=true}}
   * </select>
   * ```
   *
   * @example Using nameAttr and labelAttr with objects
   * ```js
   * let choices = {foo: {key: "a", label: "Choice A"}, bar: {key: "b", label: "Choice B"}};
   * let value = "b";
   * ```
   * The template HTML structure
   * ```hbs
   * <select name="importantChoice">
   *   {{selectOptions choices selected=value nameAttr="key" labelAttr="label"}}
   * </select>
   * ```
   *
   * @example Using nameAttr and labelAttr with arrays
   * ```js
   * let choices = [{key: "a", label: "Choice A"}, {key: "b", label: "Choice B"}];
   * let value = "b";
   * ```
   * The template HTML structure
   * ```hbs
   * <select name="importantChoice">
   *   {{selectOptions choices selected=value nameAttr="key" labelAttr="label"}}
   * </select>
   * ```
   */
  static selectOptions(
    choices: any,
    options: {
      selected?: string | string[] | undefined;
      localize?: boolean | undefined;
      blank?: string | undefined;
      sort?: boolean | undefined;
      nameAttr?: string | undefined;
      labelAttr?: string | undefined;
      inverted?: boolean | undefined;
    }
  ): Handlebars.SafeString;
}
type TextEditorOptions = {
  /**
   * The named target data element
   */
  target?: string | undefined;
  /**
   * Include a button used to activate the editor later?
   */
  button?: boolean | undefined;
  /**
   * A specific CSS class to add to the editor container
   */
  class?: string | undefined;
  /**
   * Is the text editor area currently editable?
   */
  editable?: boolean | undefined;
  /**
   * The editor engine to use, see {@link TextEditor.create }.
   */
  engine?: string | undefined;
  /**
   * Whether to turn on collaborative editing features for ProseMirror.
   *
   * The below options are deprecated since v10 and should be avoided.
   */
  collaborate?: boolean | undefined;
  /**
   * Is the current user an owner of the data?
   */
  owner?: boolean | undefined;
  /**
   * Replace dynamic document links?
   */
  documents?: boolean | undefined;
  /**
   * The data object providing context for inline rolls
   */
  rollData?: Object | Function | undefined;
  /**
   * The original HTML content as a string
   */
  content?: string | undefined;
};
/**
 * A helper class to provide common functionality for working with the Web Audio API.
 * https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 * A singleton instance of this class is available as game#audio.
 * @see Game#audio
 */
declare class AudioHelper {
  /**
   * The Native interval for the AudioHelper to analyse audio levels from streams
   * Any interval passed to startLevelReports() would need to be a multiple of this value.
   * @type {number}
   */
  static levelAnalyserNativeInterval: number;
  /**
   * The cache size threshold after which audio buffers will be expired from the cache to make more room.
   * 1 gigabyte, by default.
   */
  static THRESHOLD_CACHE_SIZE_BYTES: number;
  /**
   * Register client-level settings for global volume overrides
   */
  static registerSettings(): void;
  /**
   * Test whether a source file has a supported audio extension type
   * @param {string} src      A requested audio source path
   * @returns {boolean}       Does the filename end with a valid audio extension?
   */
  static hasAudioExtension(src: string): boolean;
  /**
   * Given an input file path, determine a default name for the sound based on the filename
   * @param {string} src      An input file path
   * @returns {string}        A default sound name for the path
   */
  static getDefaultSoundName(src: string): string;
  /**
   * Open socket listeners which transact ChatMessage data
   * @param socket
   */
  static _activateSocketListeners(socket: any): void;
  /**
   * Play a one-off sound effect which is not part of a Playlist
   *
   * @param {Object} data           An object configuring the audio data to play
   * @param {string} data.src       The audio source file path, either a public URL or a local path relative to the public directory
   * @param {number} data.volume    The volume level at which to play the audio, between 0 and 1.
   * @param {boolean} data.autoplay Begin playback of the audio effect immediately once it is loaded.
   * @param {boolean} data.loop     Loop the audio effect and continue playing it until it is manually stopped.
   * @param {boolean} [push]        Push the audio sound effect to other connected clients?
   *
   * @returns {Sound}               A Sound instance which controls audio playback.
   *
   * @example Play the sound of a locked door for all players
   * ```js
   * AudioHelper.play({src: "sounds/lock.wav", volume: 0.8, loop: false}, true);
   * ```
   */
  static play(
    data: {
      src: string;
      volume: number;
      autoplay: boolean;
      loop: boolean;
    },
    push?: boolean | undefined
  ): Sound;
  /**
   * Begin loading the sound for a provided source URL adding its
   * @param {string} src            The audio source path to preload
   * @returns {Promise<Sound>}      The created and loaded Sound ready for playback
   */
  static preloadSound(src: string): Promise<Sound>;
  /**
   * Returns the volume value based on a range input volume control's position.
   * This is using an exponential approximation of the logarithmic nature of audio level perception
   * @param {number|string} value   Value between [0, 1] of the range input
   * @param {number} [order=1.5]    The exponent of the curve
   * @returns {number}
   */
  static inputToVolume(
    value: number | string,
    order?: number | undefined
  ): number;
  /**
   * Counterpart to inputToVolume()
   * Returns the input range value based on a volume
   * @param {number} volume         Value between [0, 1] of the volume level
   * @param {number} [order=1.5]    The exponent of the curve
   * @returns {number}
   */
  static volumeToInput(volume: number, order?: number | undefined): number;
  /**
   * The primary Audio Context used to play client-facing sounds.
   * The context is undefined until the user's first gesture is observed.
   * @type {AudioContext}
   */
  context: AudioContext;
  /**
   * The set of AudioBuffer objects which are cached for different audio paths
   * @type {Map<string,{buffer: AudioBuffer, lastAccessed: number, playing: boolean, size: number}>}
   */
  buffers: Map<
    string,
    {
      buffer: AudioBuffer;
      lastAccessed: number;
      playing: boolean;
      size: number;
    }
  >;
  /**
   * The set of singleton Sound instances which are cached for different audio paths
   * @type {Map<string,Sound>}
   */
  sounds: Map<string, Sound>;
  /**
   * Get a map of the Sound objects which are currently playing.
   * @type {Map<number,Sound>}
   */
  playing: Map<number, Sound>;
  /**
   * A user gesture must be registered before audio can be played.
   * This Array contains the Sound instances which are requested for playback prior to a gesture.
   * Once a gesture is observed, we begin playing all elements of this Array.
   * @type {Function[]}
   * @see Sound
   */
  pending: Function[];
  /**
   * A flag for whether video playback is currently locked by awaiting a user gesture
   * @type {boolean}
   */
  locked: boolean;
  /**
   * Audio Context singleton used for analysing audio levels of each stream
   * Only created if necessary to listen to audio streams.
   *
   * @type {AudioContext}
   * @private
   */
  private _audioContext;
  /**
   * Map of all streams that we listen to for determining the decibel levels.
   * Used for analyzing audio levels of each stream.
   * Format of the object stored is :
   * {id:
   *   {
   *     stream: MediaStream,
   *     analyser: AudioAnalyser,
   *     interval: Number,
   *     callback: Function
   *   }
   * }
   *
   * @type {Object}
   * @private
   */
  private _analyserStreams;
  /**
   * Interval ID as returned by setInterval for analysing the volume of streams
   * When set to 0, means no timer is set.
   * @type {number}
   * @private
   */
  private _analyserInterval;
  /**
   * Fast Fourier Transform Array.
   * Used for analysing the decibel level of streams. The array is allocated only once
   * then filled by the analyser repeatedly. We only generate it when we need to listen to
   * a stream's level, so we initialize it to null.
   * @type {Float32Array}
   * @private
   */
  private _fftArray;
  /**
   * A Promise which resolves once the game audio API is unlocked and ready to use.
   * @type {Promise<AudioContext>}
   */
  unlock: Promise<AudioContext>;
  /**
   * Create a Sound instance for a given audio source URL
   * @param {object} options      Audio creation options
   * @param {string} options.src                  The source URL for the audio file
   * @param {boolean} [options.singleton=true]    Reuse an existing Sound for this source?
   * @param {boolean} [options.preload=false]     Begin loading the audio immediately?
   * @param {boolean} [options.autoplay=false]    Begin playing the audio as soon as it is ready?
   * @param {object} [options.autoplayOptions={}] Additional options passed to the play method if autoplay is true
   * @returns {Sound}
   */
  create({
    src,
    singleton,
    preload,
    autoplay,
    autoplayOptions,
  }?: {
    src: string;
    singleton?: boolean | undefined;
    preload?: boolean | undefined;
    autoplay?: boolean | undefined;
    autoplayOptions?: object | undefined;
  }): Sound;
  /**
   * Play a single Sound by providing its source.
   * @param {string} src            The file path to the audio source being played
   * @param {object} [options]       Additional options passed to Sound#play
   * @returns {Promise<Sound>}      The created Sound which is now playing
   */
  play(src: string, options?: object | undefined): Promise<Sound>;
  /**
   * Register an event listener to await the first mousemove gesture and begin playback once observed.
   * @returns {Promise<AudioContext>}       The unlocked audio context
   */
  awaitFirstGesture(): Promise<AudioContext>;
  /**
   * Request that other connected clients begin preloading a certain sound path.
   * @param {string} src          The source file path requested for preload
   * @returns {Promise<Sound>}    A Promise which resolves once the preload is complete
   */
  preload(src: string): Promise<Sound>;
  /**
   * Retrieve an AudioBuffer from the buffers cache, if it is available
   * @param {string} src          The buffer audio source path
   * @returns {AudioBuffer}       The AudioBuffer instance if cached, otherwise undefined
   */
  getCache(src: string): AudioBuffer;
  /**
   * Update the last accessed time and playing status of a cached buffer.
   * @param {string} src          The buffer audio source path
   * @param {boolean} playing     Is the buffer currently playing?
   */
  updateCache(src: string, playing?: boolean): void;
  /**
   * Insert an AudioBuffer into the buffers cache.
   * See https://padenot.github.io/web-audio-perf/#memory-profiling
   * @param {string} src          The buffer audio source path
   * @param {AudioBuffer} buffer  The AudioBuffer instance
   */
  setCache(src: string, buffer: AudioBuffer): number | undefined;
  /**
   * Returns a singleton AudioContext if one can be created.
   * An audio context may not be available due to limited resources or browser compatibility
   * in which case null will be returned
   *
   * @returns {AudioContext}  A singleton AudioContext or null if one is not available
   */
  getAudioContext(): AudioContext;
  /**
   * Registers a stream for periodic reports of audio levels.
   * Once added, the callback will be called with the maximum decibel level of
   * the audio tracks in that stream since the last time the event was fired.
   * The interval needs to be a multiple of AudioHelper.levelAnalyserNativeInterval which defaults at 50ms
   *
   * @param {string} id             An id to assign to this report. Can be used to stop reports
   * @param {MediaStream} stream    The MediaStream instance to report activity on.
   * @param {Function} callback     The callback function to call with the decibel level. `callback(dbLevel)`
   * @param {number} interval       (optional) The interval at which to produce reports.
   * @param {number} smoothing      (optional) The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.
   * @returns {boolean}              Returns whether or not listening to the stream was successful
   */
  startLevelReports(
    id: string,
    stream: MediaStream,
    callback: Function,
    interval?: number,
    smoothing?: number
  ): boolean;
  /**
   * Stop sending audio level reports
   * This stops listening to a stream and stops sending reports.
   * If we aren't listening to any more streams, cancel the global analyser timer.
   * @param {string} id      The id of the reports that passed to startLevelReports.
   */
  stopLevelReports(id: string): void;
  /**
   * Ensures the global analyser timer is started
   *
   * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things
   * and avoid having multiple timers running if we want to analyse multiple streams at the same time.
   * I don't know if it actually helps much with performance but it's expected that limiting the number of timers
   * running at the same time is good practice and with JS itself, there's a potential for a timer congestion
   * phenomenon if too many are created.
   * @private
   */
  private _ensureAnalyserTimer;
  /**
   * Cancel the global analyser timer
   * If the timer is running and has become unnecessary, stops it.
   * @private
   */
  private _cancelAnalyserTimer;
  /**
   * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels
   * detected since the last emit.
   * The event's detail is in the form of {userId: decibelLevel}
   * @private
   */
  private _emitVolumes;
  /**
   * Handle the first observed user gesture
   * @param {Event} event         The mouse-move event which enables playback
   * @param {Function} resolve    The Promise resolution function
   * @private
   */
  private _onFirstGesture;
  /**
   * Additional standard callback events that occur whenever a global volume slider is adjusted
   * @param {string} key        The setting key
   * @param {number} volume     The new volume level
   * @private
   */
  private _onChangeGlobalVolume;
  #private;
}
/**
 * An AudioSourceNode container which handles the strategy of node type to use for playback.
 * Used by the Sound interface which controls playback.
 * This class is for internal use only and should not be used by external callers.
 */
declare class AudioContainer {
  /**
   * The maximum duration, in seconds, for which an AudioBuffer will be used.
   * Otherwise, a streaming media element will be used.
   * @type {number}
   */
  static MAX_BUFFER_DURATION: number;
  /**
   * The sequence of container loading states.
   * @enum {number}
   */
  static LOAD_STATES: {
    FAILED: number;
    NONE: number;
    LOADING: number;
    LOADED: number;
  };
  constructor(src: any);
  /**
   * The audio source path
   * @type {string}
   */
  src: string;
  /**
   * The Audio Node used to control this sound
   * @type {AudioBufferSourceNode|MediaElementAudioSourceNode}
   */
  sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode;
  /**
   * The GainNode used to control volume
   * @type {GainNode}
   */
  gainNode: GainNode;
  /**
   * Is this container using an AudioBuffer?
   * @type {boolean}
   */
  isBuffer: boolean;
  /**
   * Whether we have attempted to load the audio node or not, and whether it failed.
   * @see {LOAD_STATES}
   * @type {number}
   */
  loadState: number;
  /**
   * Is the audio source currently playing?
   * @type {boolean}
   */
  playing: boolean;
  /**
   * Should the audio source loop?
   * @type {boolean}
   * @private
   */
  private _loop;
  set loop(arg: boolean);
  get loop(): boolean;
  /**
   * Has the audio file been loaded either fully or for streaming.
   * @type {boolean}
   */
  get loaded(): boolean;
  /**
   * Did the audio file fail to load.
   * @type {boolean}
   */
  get failed(): boolean;
  /**
   * A reference to the AudioBuffer if the sourceNode is a AudioBufferSourceNode.
   * @returns {AudioBuffer}
   */
  get buffer(): AudioBuffer;
  /**
   * The game audio context used throughout the application.
   * @returns {AudioContext}
   */
  get context(): AudioContext;
  /**
   * The total duration of the audio source in seconds
   * @type {number}
   */
  get duration(): number;
  /**
   * A reference to the HTMLMediaElement, if the sourceNode is a MediaElementAudioSourceNode.
   * @returns {HTMLMediaElement}
   */
  get element(): HTMLMediaElement;
  /**
   * Load the source node required for playback of this audio source
   * @returns {Promise<void>}
   */
  load(): Promise<void>;
  /**
   * Create the initial audio node used for playback.
   * Determine the node type to use based on cached state and sound duration.
   * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
   * @private
   */
  private _createNode;
  /**
   * Create an Audio source node using a buffered array.
   * @returns {Promise<AudioBuffer>}
   * @private
   */
  private _createAudioBuffer;
  /**
   * Create a AudioBufferSourceNode using a provided AudioBuffer
   * @private
   */
  private _createAudioBufferSourceNode;
  /**
   * Create an HTML5 Audio element which has loaded the metadata for the provided source.
   * @returns {Promise<HTMLAudioElement>}
   * @private
   */
  private _createAudioElement;
  /**
   * Create a MediaElementAudioSourceNode using a provided HTMLAudioElement
   * @private
   */
  private _createMediaElementAudioSourceNode;
  /**
   * Begin playback for the source node.
   * @param {number} offset         The desired start time
   * @param {Function} onended      A callback function for when playback concludes naturally
   */
  play(offset: number | undefined, onended: Function): void;
  /**
   * Terminate playback for the source node.
   */
  stop(): void;
  /**
   * Perform cleanup actions when the sound has finished playing. For
   * MediaElementAudioSourceNodes, this also means optionally restarting if
   * the sound is supposed to loop.
   * @param {Function} onended A callback provided by the owner of the container that gets fired when the sound ends.
   * @private
   */
  private _onEnd;
  /**
   * Unload the MediaElementAudioSourceNode to terminate any ongoing
   * connections.
   * @private
   */
  private _unloadMediaNode;
}
/**
 * The sequence of container loading states.
 */
type LOAD_STATES = number;
/**
 * The Sound class is used to control the playback of audio sources using the Web Audio API.
 */
declare class Sound {
  /**
   * A global audio node ID used to quickly reference a specific audio node
   * @type {number}
   * @private
   */
  private static _nodeId;
  constructor(
    src: any,
    {
      container,
    }?: {
      container: any;
    }
  );
  /**
   * The numeric identifier for accessing this node
   * @type {number}
   */
  id: number;
  /**
   * The audio source path
   * @type {string}
   */
  src: string;
  /**
   * The AudioContainer which controls playback
   * @type {AudioContainer}
   */
  container: AudioContainer;
  /**
   * The time in seconds at which playback was started
   * @type {number}
   */
  startTime: number;
  /**
   * The time in seconds at which playback was paused
   * @type {number}
   */
  pausedTime: number;
  /**
   * Registered event callbacks
   * @type {{stop: {}, start: {}, end: {}, pause: {}, load: {}}}
   */
  events: {
    stop: {};
    start: {};
    end: {};
    pause: {};
    load: {};
  };
  /**
   * The registered event handler id for this Sound.
   * Incremented each time a callback is registered.
   * @type {number}
   * @private
   */
  private _eventHandlerId;
  /**
   * If this Sound source is currently in the process of loading, this attribute contains a Promise that will resolve
   * when the loading process completes.
   * @type {Promise}
   */
  loading: Promise<any>;
  /**
   * A collection of scheduled events recorded as window timeout IDs
   * @type {Set<number>}
   * @private
   */
  private _scheduledEvents;
  /**
   * A convenience reference to the sound context used by the application
   * @returns {AudioContext}
   */
  get context(): AudioContext;
  /**
   * A reference to the audio source node being used by the AudioContainer
   * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
   */
  get node(): AudioBufferSourceNode | MediaElementAudioSourceNode;
  /**
   * A reference to the GainNode parameter which controls volume
   * @type {AudioParam}
   */
  get gain(): AudioParam;
  /**
   * The current playback time of the sound
   * @returns {number}
   */
  get currentTime(): number;
  /**
   * The total sound duration, in seconds
   * @type {number}
   */
  get duration(): number;
  /**
   * Is the contained audio node loaded and ready for playback?
   * @type {boolean}
   */
  get loaded(): boolean;
  /**
   * Did the contained audio node fail to load?
   * @type {boolean}
   */
  get failed(): boolean;
  /**
   * Is the audio source currently playing?
   * @type {boolean}
   */
  get playing(): boolean;
  set loop(arg: boolean);
  /**
   * Is the Sound current looping?
   * @type {boolean}
   */
  get loop(): boolean;
  set volume(arg: number);
  /**
   * The volume at which the Sound is playing
   * @returns {number}
   */
  get volume(): number;
  /**
   * Fade the volume for this sound between its current level and a desired target volume
   * @param {number} volume                     The desired target volume level between 0 and 1
   * @param {object} [options={}]               Additional options that configure the fade operation
   * @param {number} [options.duration=1000]      The duration of the fade effect in milliseconds
   * @param {number} [options.from]               A volume level to start from, the current volume by default
   * @param {string} [options.type=linear]        The type of fade easing, "linear" or "exponential"
   * @returns {Promise<void>}                   A Promise that resolves after the requested fade duration
   */
  fade(
    volume: number,
    {
      duration,
      from,
      type,
    }?:
      | {
          duration?: number | undefined;
          from?: number | undefined;
          type?: string | undefined;
        }
      | undefined
  ): Promise<void>;
  /**
   * Load the audio source, creating an AudioBuffer.
   * Audio loading is idempotent, it can be requested multiple times but only the first load request will be honored.
   * @param {object} [options={}]   Additional options which affect resource loading
   * @param {boolean} [options.autoplay=false]  Automatically begin playback of the audio source once loaded
   * @param {object} [options.autoplayOptions]  Additional options passed to the play method when loading is complete
   * @returns {Promise<Sound>}      The Sound once its source audio buffer is loaded
   */
  load({
    autoplay,
    autoplayOptions,
  }?:
    | {
        autoplay?: boolean | undefined;
        autoplayOptions?: object | undefined;
      }
    | undefined): Promise<Sound>;
  /**
   * Begin playback for the sound node
   * @param {object} [options={}]   Options which configure playback
   * @param {boolean} [options.loop=false]    Whether to loop the audio automatically
   * @param {number} [options.offset]         A specific offset in seconds at which to begin playback
   * @param {number} [options.volume]         The desired volume at which to begin playback
   * @param {number} [options.fade=0]         Fade volume changes over a desired duration in milliseconds
   */
  play({
    loop,
    offset,
    volume,
    fade,
  }?:
    | {
        loop?: boolean | undefined;
        offset?: number | undefined;
        volume?: number | undefined;
        fade?: number | undefined;
      }
    | undefined): number | void | Promise<void>;
  /**
   * Pause playback, remembering the playback position in order to resume later.
   */
  pause(): void;
  /**
   * Stop playback, fully resetting the Sound to a non-playing state.
   */
  stop(): void;
  /**
   * Schedule a function to occur at the next occurrence of a specific playbackTime for this Sound.
   * @param {Function} fn           A function that will be called with this Sound as its single argument
   * @param {number} playbackTime   The desired playback time at which the function should be called
   * @returns {Promise<null>}       A Promise which resolves once the scheduled function has been called
   *
   * @example Schedule audio playback changes
   * ```js
   * sound.schedule(() => console.log("Do something exactly 30 seconds into the track"), 30);
   * sound.schedule(() => console.log("Do something next time the track loops back to the beginning"), 0);
   * sound.schedule(() => console.log("Do something 5 seconds before the end of the track"), sound.duration - 5);
   * ```
   */
  schedule(fn: Function, playbackTime: number): Promise<null>;
  /**
   * Trigger registered callback functions for a specific event name.
   * @param {string} eventName      The event name being emitted
   */
  emit(eventName: string): void;
  /**
   * Deactivate an event handler which was previously registered for a specific event
   * @param {string} eventName      The event name being deactivated
   * @param {number|Function} fn    The callback ID or callback function being un-registered
   */
  off(eventName: string, fn: number | Function): void;
  /**
   * Register an event handler to take actions for a certain Sound event.
   * @param {string} eventName      The event name being deactivated
   * @param {Function} fn           The callback function to trigger when the event occurs
   * @param {object} [options={}]   Additional options that affect callback registration
   * @param {boolean} [options.once=false]  Trigger the callback once only and automatically un-register it
   */
  on(
    eventName: string,
    fn: Function,
    {
      once,
    }?:
      | {
          once?: boolean | undefined;
        }
      | undefined
  ): number | undefined;
  /**
   * Register a new callback function for a certain event. For internal use only.
   * @private
   */
  private _registerForEvent;
  /**
   * Cancel all pending scheduled events.
   * @private
   */
  private _clearEvents;
  /**
   * Called when playback concludes naturally
   * @protected
   */
  protected _onEnd(): void;
  /**
   * Called when the audio buffer is first loaded
   * @protected
   */
  protected _onLoad(): void;
  /**
   * Called when playback is paused
   * @protected
   */
  protected _onPause(): void;
  /**
   * Called when the sound begins playing
   * @protected
   */
  protected _onStart(): void;
  /**
   * Called when playback is stopped (prior to naturally reaching the end)
   * @protected
   */
  protected _onStop(): void;
}
/**
 * An interface for an Audio/Video client which is extended to provide broadcasting functionality.
 * @interface
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
declare class AVClient {
  constructor(master: any, settings: any);
  /**
   * The master orchestration instance
   * @type {AVMaster}
   */
  master: AVMaster;
  /**
   * The active audio/video settings being used
   * @type {AVSettings}
   */
  settings: AVSettings;
  /**
   * Is audio broadcasting push-to-talk enabled?
   * @returns {boolean}
   */
  get isVoicePTT(): boolean;
  /**
   * Is audio broadcasting always enabled?
   * @returns {boolean}
   */
  get isVoiceAlways(): boolean;
  /**
   * Is audio broadcasting voice-activation enabled?
   * @returns {boolean}
   */
  get isVoiceActivated(): boolean;
  /**
   * Is the current user muted?
   * @returns {boolean}
   */
  get isMuted(): boolean;
  /**
   * One-time initialization actions that should be performed for this client implementation.
   * This will be called only once when the Game object is first set-up.
   * @returns {Promise<void>}
   */
  initialize(): Promise<void>;
  /**
   * Connect to any servers or services needed in order to provide audio/video functionality.
   * Any parameters needed in order to establish the connection should be drawn from the settings object.
   * This function should return a boolean for whether the connection attempt was successful.
   * @returns {Promise<boolean>}   Was the connection attempt successful?
   */
  connect(): Promise<boolean>;
  /**
   * Disconnect from any servers or services which are used to provide audio/video functionality.
   * This function should return a boolean for whether a valid disconnection occurred.
   * @returns {Promise<boolean>}   Did a disconnection occur?
   */
  disconnect(): Promise<boolean>;
  /**
   * Provide an Object of available audio sources which can be used by this implementation.
   * Each object key should be a device id and the key should be a human-readable label.
   * @returns {Promise<{object}>}
   */
  getAudioSinks(): Promise<{
    object;
  }>;
  /**
   * Provide an Object of available audio sources which can be used by this implementation.
   * Each object key should be a device id and the key should be a human-readable label.
   * @returns {Promise<{object}>}
   */
  getAudioSources(): Promise<{
    object;
  }>;
  /**
   * Provide an Object of available video sources which can be used by this implementation.
   * Each object key should be a device id and the key should be a human-readable label.
   * @returns {Promise<{object}>}
   */
  getVideoSources(): Promise<{
    object;
  }>;
  /**
   * Obtain a mapping of available device sources for a given type.
   * @param {string} kind       The type of device source being requested
   * @returns {Promise<{object}>}
   * @private
   */
  private _getSourcesOfType;
  /**
   * Return an array of Foundry User IDs which are currently connected to A/V.
   * The current user should also be included as a connected user in addition to all peers.
   * @returns {string[]}          The connected User IDs
   */
  getConnectedUsers(): string[];
  /**
   * Provide a MediaStream instance for a given user ID
   * @param {string} userId        The User id
   * @returns {MediaStream|null}   The MediaStream for the user, or null if the user does not have one
   */
  getMediaStreamForUser(userId: string): MediaStream | null;
  /**
   * Provide a MediaStream for monitoring a given user's voice volume levels.
   * @param {string} userId       The User ID.
   * @returns {MediaStream|null}  The MediaStream for the user, or null if the user does not have one.
   */
  getLevelsStreamForUser(userId: string): MediaStream | null;
  /**
   * Is outbound audio enabled for the current user?
   * @returns {boolean}
   */
  isAudioEnabled(): boolean;
  /**
   * Is outbound video enabled for the current user?
   * @returns {boolean}
   */
  isVideoEnabled(): boolean;
  /**
   * Set whether the outbound audio feed for the current game user is enabled.
   * This method should be used when the user marks themselves as muted or if the gamemaster globally mutes them.
   * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
   */
  toggleAudio(enable: boolean): void;
  /**
   * Set whether the outbound audio feed for the current game user is actively broadcasting.
   * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
   * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
   */
  toggleBroadcast(broadcast: boolean): void;
  /**
   * Set whether the outbound video feed for the current game user is enabled.
   * This method should be used when the user marks themselves as hidden or if the gamemaster globally hides them.
   * @param {boolean} enable        Whether the outbound video track should be enabled (true) or disabled (false)
   */
  toggleVideo(enable: boolean): void;
  /**
   * Set the Video Track for a given User ID to a provided VideoElement
   * @param {string} userId                   The User ID to set to the element
   * @param {HTMLVideoElement} videoElement   The HTMLVideoElement to which the video should be set
   */
  setUserVideo(userId: string, videoElement: HTMLVideoElement): Promise<void>;
  /**
   * Handle changes to A/V configuration settings.
   * @param {object} changed      The settings which have changed
   */
  onSettingsChanged(changed: object): void;
  /**
   * Replace the local stream for each connected peer with a re-generated MediaStream.
   */
  updateLocalStream(): Promise<void>;
}
/**
 * An implementation of the AVClient which uses the simple-peer library and the Foundry socket server for signaling.
 * Credit to bekit#4213 for identifying simple-peer as a viable technology and providing a POC implementation.
 * @extends {AVClient}
 */
declare class SimplePeerAVClient extends AVClient {
  /**
   * The local Stream which captures input video and audio
   * @type {MediaStream}
   */
  localStream: MediaStream;
  /**
   * The dedicated audio stream used to measure volume levels for voice activity detection.
   * @type {MediaStream}
   */
  levelsStream: MediaStream;
  /**
   * A mapping of connected peers
   * @type {Map}
   */
  peers: Map<any, any>;
  /**
   * A mapping of connected remote streams
   * @type {Map}
   */
  remoteStreams: Map<any, any>;
  /**
   * Has the client been successfully initialized?
   * @type {boolean}
   * @private
   */
  private _initialized;
  /**
   * Is outbound broadcast of local audio enabled?
   * @type {boolean}
   */
  audioBroadcastEnabled: boolean;
  /**
   * The polling interval ID for connected users that might have unexpectedly dropped out of our peer network.
   * @type {number|null}
   */
  _connectionPoll: number | null;
  /**
   * Try to establish a peer connection with each user connected to the server.
   * @private
   */
  private _connect;
  /** @override */
  override getConnectedUsers(): any[];
  /** @override */
  override getMediaStreamForUser(userId: any): any;
  /** @override */
  override getLevelsStreamForUser(userId: any): any;
  /** @override */
  override toggleAudio(enabled: any): void;
  /** @override */
  override toggleBroadcast(enabled: any): void;
  /** @override */
  override toggleVideo(enabled: any): void;
  /** @override */
  override setUserVideo(userId: any, videoElement: any): Promise<void>;
  /**
   * Initialize a local media stream for the current user
   * @returns {Promise<MediaStream>}
   */
  initializeLocalStream(): Promise<MediaStream>;
  /**
   * Attempt to create local media streams.
   * @param {{video: object, audio: object}} params       Parameters for the getUserMedia request.
   * @returns {Promise<MediaStream|Error>}                The created MediaStream or an error.
   * @private
   */
  private _createMediaStream;
  /**
   * Listen for Audio/Video updates on the av socket to broker connections between peers
   */
  activateSocketListeners(): void;
  /**
   * Initialize a stream connection with a new peer
   * @param {string} userId           The Foundry user ID for which the peer stream should be established
   * @returns {Promise<SimplePeer>}   A Promise which resolves once the peer stream is initialized
   */
  initializePeerStream(userId: string): Promise<SimplePeer>;
  /**
   * Receive a request to establish a peer signal with some other User id
   * @param {string} userId           The Foundry user ID who is requesting to establish a connection
   * @param {object} data             The connection details provided by SimplePeer
   */
  receiveSignal(userId: string, data: object): void;
  /**
   * Connect to a peer directly, either as the initiator or as the receiver
   * @param {string} userId           The Foundry user ID with whom we are connecting
   * @param {boolean} isInitiator     Is the current user initiating the connection, or responding to it?
   * @returns {SimplePeer}            The constructed and configured SimplePeer instance
   */
  connectPeer(userId: string, isInitiator?: boolean): SimplePeer;
  /**
   * Create the SimplePeer instance for the desired peer connection.
   * Modules may implement more advanced connection strategies by overriding this method.
   * @param {string} userId           The Foundry user ID with whom we are connecting
   * @param {boolean} isInitiator     Is the current user initiating the connection, or responding to it?
   * @private
   */
  private _createPeerConnection;
  /**
   * Setup the custom TURN relay to be used in subsequent calls if there is one configured.
   * TURN credentials are mandatory in WebRTC.
   * @param {object} options The SimplePeer configuration object.
   * @private
   */
  private _setupCustomTURN;
  /**
   * Disconnect from a peer by stopping current stream tracks and destroying the SimplePeer instance
   * @param {string} userId           The Foundry user ID from whom we are disconnecting
   * @returns {Promise<void>}         A Promise which resolves once the disconnection is complete
   */
  disconnectPeer(userId: string): Promise<void>;
  /**
   * Disconnect from all current peer streams
   * @returns {Promise<Array>}       A Promise which resolves once all peers have been disconnected
   */
  disconnectAll(): Promise<any[]>;
  /** @override */
  override onSettingsChanged(changed: any): Promise<void>;
}
/**
 * The master Audio/Video controller instance.
 * This is available as the singleton game.webrtc
 *
 * @param {AVSettings} settings     The Audio/Video settings to use
 */
declare class AVMaster {
  settings: AVSettings;
  config: AVConfig;
  /**
   * The Audio/Video client class
   * @type {AVClient}
   */
  client: AVClient;
  /**
   * A flag to track whether the current user is actively broadcasting their microphone.
   * @type {boolean}
   */
  broadcasting: boolean;
  /**
   * Flag to determine if we are connected to the signalling server or not.
   * This is required for synchronization between connection and reconnection attempts.
   * @type {boolean}
   */
  _connected: boolean;
  /**
   * The cached connection promise.
   * This is required to prevent re-triggering a connection while one is already in progress.
   * @type {Promise<boolean>|null}
   * @private
   */
  private _connecting;
  /**
   * A flag to track whether the A/V system is currently in the process of reconnecting.
   * This occurs if the connection is lost or interrupted.
   * @type {boolean}
   * @private
   */
  private _reconnecting;
  _speakingData: {
    speaking: boolean;
    volumeHistories: never[];
  };
  _pttMuteTimeout: number;
  get mode(): any;
  /**
   * Connect to the Audio/Video client.
   * @return {Promise<boolean>}     Was the connection attempt successful?
   */
  connect(): Promise<boolean>;
  /**
   * Disconnect from the Audio/Video client.
   * @return {Promise<boolean>}     Whether an existing connection was terminated?
   */
  disconnect(): Promise<boolean>;
  /**
   * Callback actions to take when the user becomes disconnected from the server.
   * @return {Promise<void>}
   */
  reestablish(): Promise<void>;
  /**
   * Initialize the local broadcast state.
   * @private
   */
  private _initialize;
  /**
   * A user can broadcast audio if the AV mode is compatible and if they are allowed to broadcast.
   * @param {string} userId
   * @return {boolean}
   */
  canUserBroadcastAudio(userId: string): boolean;
  /**
   * A user can share audio if they are allowed to broadcast and if they have not muted themselves or been blocked.
   * @param {string} userId
   * @return {boolean}
   */
  canUserShareAudio(userId: string): boolean;
  /**
   * A user can broadcast video if the AV mode is compatible and if they are allowed to broadcast.
   * @param {string} userId
   * @return {boolean}
   */
  canUserBroadcastVideo(userId: string): boolean;
  /**
   * A user can share video if they are allowed to broadcast and if they have not hidden themselves or been blocked.
   * @param {string} userId
   * @return {boolean}
   */
  canUserShareVideo(userId: string): boolean;
  /**
   * Trigger a change in the audio broadcasting state when using a push-to-talk workflow.
   * @param {boolean} intent        The user's intent to broadcast. Whether an actual broadcast occurs will depend
   *                                on whether or not the user has muted their audio feed.
   */
  broadcast(intent: boolean): any;
  /**
   * Set up audio level listeners to handle voice activation detection workflow.
   * @param {string} mode           The currently selected voice broadcasting mode
   * @private
   */
  private _initializeUserVoiceDetection;
  /**
   * Activate voice detection tracking for a userId on a provided MediaStream.
   * Currently only a MediaStream is supported because MediaStreamTrack processing is not yet supported cross-browser.
   * @param {MediaStream} stream    The MediaStream which corresponds to that User
   * @param {number} [ms]           A number of milliseconds which represents the voice activation volume interval
   */
  activateVoiceDetection(stream: MediaStream, ms?: number | undefined): void;
  /**
   * Actions which the orchestration layer should take when a peer user disconnects from the audio/video service.
   */
  deactivateVoiceDetection(): void;
  /**
   * Periodic notification of user audio level
   *
   * This function uses the audio level (in dB) of the audio stream to determine if the user is speaking or not and
   * notifies the UI of such changes.
   *
   * The User is considered speaking if they are above the decibel threshold in any of the history values.
   * This marks them as speaking as soon as they have a high enough volume, and marks them as not speaking only after
   * they drop below the threshold in all histories (last 4 volumes = for 200 ms).
   *
   * There can be more optimal ways to do this and which uses whether the user was already considered speaking before
   * or not, in order to eliminate short bursts of audio (coughing for example).
   *
   * @param {number} dbLevel         The audio level in decibels of the user within the last 50ms
   * @private
   */
  private _onAudioLevel;
  /**
   * Resets the speaking history of a user
   * If the user was considered speaking, then mark them as not speaking
   */
  _resetSpeakingHistory(): void;
  /**
   * Handle activation of a push-to-talk key or button.
   * @param {KeyboardEventContext} context    The context data of the event
   */
  _onPTTStart(context: KeyboardEventContext): boolean;
  /**
   * Handle deactivation of a push-to-talk key or button.
   * @param {KeyboardEventContext} context    The context data of the event
   */
  _onPTTEnd(context: KeyboardEventContext): boolean;
  render(): any;
  /**
   * Render the audio/video streams to the CameraViews UI.
   * Assign each connected user to the correct video frame element.
   */
  onRender(): void;
  /**
   * Respond to changes which occur to AV Settings.
   * Changes are handled in descending order of impact.
   * @param {object} changed       The object of changed AV settings
   */
  onSettingsChanged(changed: object): Promise<boolean> | undefined;
  debug(message: any): void;
}
/**
 * @typedef {object} AVSettingsData
 * @property {boolean} [muted]     Whether this user has muted themselves.
 * @property {boolean} [hidden]    Whether this user has hidden their video.
 * @property {boolean} [speaking]  Whether the user is broadcasting audio.
 */
declare class AVSettings {
  /**
   * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
   * @enum {number}
   */
  static AV_MODES: {
    DISABLED: number;
    AUDIO: number;
    VIDEO: number;
    AUDIO_VIDEO: number;
  };
  /**
   * Voice modes: Always-broadcasting, voice-level triggered, push-to-talk.
   * @enum {string}
   */
  static VOICE_MODES: {
    ALWAYS: string;
    ACTIVITY: string;
    PTT: string;
  };
  /**
   * Displayed nameplate options: Off entirely, animate between player and character name, player name only, character
   * name only.
   * @enum {number}
   */
  static NAMEPLATE_MODES: {
    OFF: number;
    BOTH: number;
    PLAYER_ONLY: number;
    CHAR_ONLY: number;
  };
  /**
   * AV dock positions.
   * @enum {string}
   */
  static DOCK_POSITIONS: {
    TOP: string;
    RIGHT: string;
    BOTTOM: string;
    LEFT: string;
  };
  /**
   * Default client AV settings.
   * @type {object}
   */
  static DEFAULT_CLIENT_SETTINGS: object;
  /**
   * Default world-level AV settings.
   * @type {object}
   */
  static DEFAULT_WORLD_SETTINGS: object;
  /**
   * Default client settings for each connected user.
   * @type {object}
   */
  static DEFAULT_USER_SETTINGS: object;
  _set: any;
  _change: any;
  /**
   * Stores the transient AV activity data received from other users.
   * @type {Object<string, AVSettingsData>}
   */
  activity: {
    [x: string]: AVSettingsData;
  };
  initialize(): void;
  client: any;
  world: any;
  _original: any;
  changed(): any;
  get(scope: any, setting: any): any;
  getUser(userId: any): any;
  set(scope: any, setting: any, value: any): void;
  /**
   * Return a mapping of AV settings for each game User.
   * @type {object}
   */
  get users(): object;
  /**
   * A helper to determine if the dock is configured in a vertical position.
   */
  get verticalDock(): boolean;
  /**
   * Prepare a standardized object of user settings data for a single User
   * @private
   */
  private _getUserSettings;
  /**
   * Handle setting changes to either rctClientSettings or rtcWorldSettings.
   * @private
   */
  private _onSettingsChanged;
  /**
   * Handle another connected user changing their AV settings.
   * @param {string} userId
   * @param {AVSettingsData} settings
   */
  handleUserActivity(userId: string, settings: AVSettingsData): void;
}
/**
 * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
 */
type AV_MODES = number;
/**
 * Voice modes: Always-broadcasting, voice-level triggered, push-to-talk.
 */
type VOICE_MODES = string;
/**
 * Displayed nameplate options: Off entirely, animate between player and character name, player name only, character
 * name only.
 */
type NAMEPLATE_MODES = number;
/**
 * AV dock positions.
 */
type DOCK_POSITIONS = string;
type AVSettingsData = {
  /**
   * Whether this user has muted themselves.
   */
  muted?: boolean | undefined;
  /**
   * Whether this user has hidden their video.
   */
  hidden?: boolean | undefined;
  /**
   * Whether the user is broadcasting audio.
   */
  speaking?: boolean | undefined;
};
/**
 * Runtime configuration settings for Foundry VTT which exposes a large number of variables which determine how
 * aspects of the software behaves.
 *
 * Unlike the CONST analog which is frozen and immutable, the CONFIG object may be updated during the course of a
 * session or modified by system and module developers to adjust how the application behaves.
 *
 * @type {object}
 */
declare const CONFIG: object;
type FontDefinition = FontFaceDescriptors;
type FontFamilyDefinition = {
  /**
   * Whether the font is available in the rich text editor. This will also enable it
   * for notes and drawings.
   */
  editor: boolean;
  /**
   * Individual font face definitions for this font family. If this is empty, the
   * font family may only be loaded from the client's OS-installed fonts.
   */
  fonts: FontFaceDescriptors[];
};
/**
 * A mapping of status effect IDs which provide some additional mechanical integration.
 */
type specialStatusEffects = string;
/**
 * Configuration for the AmbientLight embedded document type and its representation on the game Canvas
 */
type AmbientLight = Function;
/**
 * Configuration for the AmbientSound embedded document type and its representation on the game Canvas
 */
type AmbientSound = Function;
/**
 * Configuration for the Combatant embedded document type within a Combat document
 */
type Combatant = Function;
/**
 * Configuration for the Drawing embedded document type and its representation on the game Canvas
 */
type Drawing = Function;
/**
 * Configuration for the MeasuredTemplate embedded document type and its representation on the game Canvas
 */
type MeasuredTemplate = Function;
/**
 * Configuration for the Note embedded document type and its representation on the game Canvas
 */
type Note = Function;
/**
 * Configuration for the Tile embedded document type and its representation on the game Canvas
 */
type Tile = Function;
/**
 * Configuration for the Token embedded document type and its representation on the game Canvas
 */
type Token = Function;
/**
 * Configuration for the Wall embedded document type and its representation on the game Canvas
 */
type Wall = Function;
type TextEditorEnricher = (
  match: RegExpMatchArray,
  options?:
    | {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean | undefined;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean | undefined;
        /**
         * Replace hyperlink content?
         */
        links?: boolean | undefined;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean | undefined;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: object | Function | undefined;
        /**
         * Perform the operation asynchronously, receiving a Promise as the returned
         *         value. This will become the default behaviour in v11.
         */
        async?: boolean | undefined;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: any;
      }
    | undefined
) => Promise<HTMLElement | null>;
type TextEditorEnricherConfig = {
  /**
   * The string pattern to match. Must be flagged as global.
   */
  pattern: RegExp;
  /**
   * The function that will be called on each match. It is expected that this
   * returns an HTML element to be inserted into the final enriched content.
   */
  enricher: (
    match: RegExpMatchArray,
    options?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ) => Promise<HTMLElement | null>;
};
/**
 * A helper class to manage requesting clipboard permissions and provide common functionality for working with the
 * clipboard.
 */
declare class ClipboardHelper {
  /**
   * Copies plain text to the clipboard in a cross-browser compatible way.
   * @param {string} text  The text to copy.
   * @returns {Promise<void>}
   */
  copyPlainText(text: string): Promise<void>;
}
/**
 * A data structure for quickly retrieving objects by a string prefix.
 * Note that this works well for languages with alphabets (latin, cyrillic, korean, etc.), but may need more nuanced
 * handling for languages that compose characters and letters.
 */
declare class WordTree {
  /**
   * Create a new node.
   * @returns {WordTreeNode}
   */
  get node(): {
    /**
     * Any leaves at this node.
     */
    leaves: {
      /**
       * An object that this entry represents.
       */
      entry: Document | object;
      /**
       * The document type.
       */
      documentName: string;
      /**
       * The document's UUID.
       */
      uuid: string;
      /**
       * The pack ID.
       */
      pack?: string | undefined;
    }[];
  };
  /**
   * Insert an entry into the tree.
   * @param {string} string        The string key for the entry.
   * @param {WordTreeEntry} entry  The entry to store.
   * @returns {WordTreeNode}       The node the entry was added to.
   */
  addLeaf(
    string: string,
    entry: {
      /**
       * An object that this entry represents.
       */
      entry: Document | object;
      /**
       * The document type.
       */
      documentName: string;
      /**
       * The document's UUID.
       */
      uuid: string;
      /**
       * The pack ID.
       */
      pack?: string | undefined;
    }
  ): {
    /**
     * Any leaves at this node.
     */
    leaves: {
      /**
       * An object that this entry represents.
       */
      entry: Document | object;
      /**
       * The document type.
       */
      documentName: string;
      /**
       * The document's UUID.
       */
      uuid: string;
      /**
       * The pack ID.
       */
      pack?: string | undefined;
    }[];
  };
  /**
   * Return entries that match the given string prefix.
   * @param {string} prefix              The prefix.
   * @param {object} [options]           Additional options to configure behaviour.
   * @param {number} [options.limit=10]  The maximum number of items to retrieve. It is important to set this value as
   *                                     very short prefixes will naturally match large numbers of entries.
   * @returns {WordTreeEntry[]}          A number of entries that have the given prefix.
   */
  lookup(
    prefix: string,
    {
      limit,
    }?:
      | {
          limit?: number | undefined;
        }
      | undefined
  ): {
    /**
     * An object that this entry represents.
     */
    entry: Document | object;
    /**
     * The document type.
     */
    documentName: string;
    /**
     * The document's UUID.
     */
    uuid: string;
    /**
     * The pack ID.
     */
    pack?: string | undefined;
  }[];
  /**
   * Returns the node at the given prefix.
   * @param {string} prefix  The prefix.
   * @returns {WordTreeNode}
   */
  nodeAtPrefix(prefix: string): {
    /**
     * Any leaves at this node.
     */
    leaves: {
      /**
       * An object that this entry represents.
       */
      entry: Document | object;
      /**
       * The document type.
       */
      documentName: string;
      /**
       * The document's UUID.
       */
      uuid: string;
      /**
       * The pack ID.
       */
      pack?: string | undefined;
    }[];
  };
  /**
   * Perform a breadth-first search starting from the given node and retrieving any entries along the way, until we
   * reach the limit.
   * @param {WordTreeNode} node          The starting node.
   * @param {WordTreeEntry[]} entries    The accumulated entries.
   * @param {WordTreeNode[]} queue       The working queue of nodes to search.
   * @param {object} [options]           Additional options for the search.
   * @param {number} [options.limit=10]  The maximum number of entries to retrieve before stopping.
   * @protected
   */
  protected _breadthFirstSearch(
    node: {
      /**
       * Any leaves at this node.
       */
      leaves: {
        /**
         * An object that this entry represents.
         */
        entry: Document | object;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string | undefined;
      }[];
    },
    entries: {
      /**
       * An object that this entry represents.
       */
      entry: Document | object;
      /**
       * The document type.
       */
      documentName: string;
      /**
       * The document's UUID.
       */
      uuid: string;
      /**
       * The pack ID.
       */
      pack?: string | undefined;
    }[],
    queue: {
      /**
       * Any leaves at this node.
       */
      leaves: {
        /**
         * An object that this entry represents.
         */
        entry: Document | object;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string | undefined;
      }[];
    }[],
    {
      limit,
    }?:
      | {
          limit?: number | undefined;
        }
      | undefined
  ): void;
  #private;
}
/**
 * This class is responsible for indexing all documents available in the world and storing them in a word tree structure
 * that allows for fast searching.
 */
declare class DocumentIndex {
  /**
   * Returns a Promise that resolves when the indexing process is complete.
   * @returns {Promise<void>|null}
   */
  get ready(): Promise<void> | null;
  /**
   * Index all available documents in the world and store them in a word tree.
   * @returns {Promise<void>}
   */
  index(): Promise<void>;
  /**
   * Return entries that match the given string prefix.
   * @param {string} prefix                     The prefix.
   * @param {object} [options]                  Additional options to configure behaviour.
   * @param {string[]} [options.documentTypes]  Optionally provide an array of document types. Only entries of that type
   *                                            will be searched for.
   * @param {number} [options.limit=10]         The maximum number of items per document type to retrieve. It is
   *                                            important to set this value as very short prefixes will naturally match
   *                                            large numbers of entries.
   * @returns {Object<WordTreeEntry[]>}         A number of entries that have the given prefix, grouped by document
   *                                            type.
   */
  lookup(
    prefix: string,
    {
      limit,
      documentTypes,
    }?:
      | {
          documentTypes?: string[] | undefined;
          limit?: number | undefined;
        }
      | undefined
  ): any;
  /**
   * Add an entry to the index.
   * @param {Document} doc  The document entry.
   */
  addDocument(doc: Document): void;
  /**
   * Remove an entry from the index.
   * @param {Document} doc  The document entry.
   */
  removeDocument(doc: Document): void;
  /**
   * Replace an entry in the index with an updated one.
   * @param {Document} doc  The document entry.
   */
  replaceDocument(doc: Document): void;
  /**
   * Add a leaf node to the word tree index.
   * @param {Document|object} doc                  The document or compendium index entry to add.
   * @param {object} [options]                     Additional information for indexing.
   * @param {CompendiumCollection} [options.pack]  The compendium that the index belongs to.
   * @protected
   */
  protected _addLeaf(
    doc: Document | object,
    {
      pack,
    }?:
      | {
          pack?: CompendiumCollection | undefined;
        }
      | undefined
  ): void;
  /**
   * Aggregate the compendium index and add it to the word tree index.
   * @param {CompendiumCollection} pack  The compendium pack.
   * @protected
   */
  protected _indexCompendium(pack: CompendiumCollection): void;
  /**
   * Add all of a parent document's embedded documents to the index.
   * @param {Document} parent  The parent document.
   * @protected
   */
  protected _indexEmbeddedDocuments(parent: Document): void;
  /**
   * Aggregate all documents and embedded documents in a world collection and add them to the index.
   * @param {string} documentName  The name of the documents to index.
   * @protected
   */
  protected _indexWorldCollection(documentName: string): void;
  #private;
}
/**
 * A leaf entry in the tree.
 */
type WordTreeEntry = {
  /**
   * An object that this entry represents.
   */
  entry: Document | object;
  /**
   * The document type.
   */
  documentName: string;
  /**
   * The document's UUID.
   */
  uuid: string;
  /**
   * The pack ID.
   */
  pack?: string | undefined;
};
/**
 * A word tree node consists of zero or more 1-character keys, and a leaves property that contains any objects that
 * terminate at the current string prefix.
 */
type WordTreeNode = {
  /**
   * Any leaves at this node.
   */
  leaves: {
    /**
     * An object that this entry represents.
     */
    entry: object | Document;
    /**
     * The document type.
     */
    documentName: string;
    /**
     * The document's UUID.
     */
    uuid: string;
    /**
     * The pack ID.
     */
    pack?: string | undefined;
  }[];
};
/**
 * Management class for Gamepad events
 */
declare class GamepadManager {
  /**
   * How often Gamepad polling should check for button presses
   * @type {number}
   */
  static GAMEPAD_POLLER_INTERVAL_MS: number;
  _gamepadPoller: number | null;
  /**
   * The connected Gamepads
   * @type {Map<string, ConnectedGamepad>}
   * @private
   */
  private _connectedGamepads;
  /**
   * Handles a Gamepad Connection event, adding its info to the poll list
   * @param {GamepadEvent} event The originating Event
   * @private
   */
  private _onGamepadConnect;
  /**
   * Handles a Gamepad Disconnect event, removing it from consideration for polling
   * @param {GamepadEvent} event The originating Event
   * @private
   */
  private _onGamepadDisconnect;
  /**
   * Polls all Connected Gamepads for updates. If they have been updated, checks status of Axis and Buttons,
   * firing off Keybinding Contexts as appropriate
   * @private
   */
  private _pollGamepads;
  /**
   * Converts a Gamepad Input event into a KeyboardEvent, then fires it
   * @param {string} gamepadId  The string representation of the Gamepad Input
   * @param {boolean} up        True if the Input is pressed or active
   * @param {boolean} repeat    True if the Input is being held
   * @private
   */
  private _handleGamepadInput;
}
/**
 * @typedef {object} HookedFunction
 * @property {string} hook
 * @property {number} id
 * @property {Function} fn
 * @property {boolean} once
 */
/**
 * A simple event framework used throughout Foundry Virtual Tabletop.
 * When key actions or events occur, a "hook" is defined where user-defined callback functions can execute.
 * This class manages the registration and execution of hooked callback functions.
 */
declare class Hooks {
  /**
   * A mapping of hook events which have functions registered to them.
   * @type {Object<HookedFunction[]>}
   */
  static get events(): any;
  /**
   * @type {Object<HookedFunction[]>}
   * @private
   * @ignore
   */
  private static "__#16@#events";
  /**
   * A mapping of hooked functions by their assigned ID
   * @type {Map<number, HookedFunction>}
   */
  static "__#16@#ids": Map<number, HookedFunction>;
  /**
   * An incrementing counter for assigned hooked function IDs
   * @type {number}
   */
  static "__#16@#id": number;
  /**
   * Register a callback handler which should be triggered when a hook is triggered.
   * @param {string} hook     The unique name of the hooked event
   * @param {Function} fn     The callback function which should be triggered when the hook event occurs
   * @param {object} options  Options which customize hook registration
   * @param {boolean} options.once  Only trigger the hooked function once
   * @returns {number}      An ID number of the hooked function which can be used to turn off the hook later
   */
  static on(
    hook: string,
    fn: Function,
    {
      once,
    }?: {
      once: boolean;
    }
  ): number;
  /**
   * Register a callback handler for an event which is only triggered once the first time the event occurs.
   * An alias for Hooks.on with {once: true}
   * @param {string} hook   The unique name of the hooked event
   * @param {Function} fn   The callback function which should be triggered when the hook event occurs
   * @returns {number}      An ID number of the hooked function which can be used to turn off the hook later
   */
  static once(hook: string, fn: Function): number;
  /**
   * Unregister a callback handler for a particular hook event
   * @param {string} hook           The unique name of the hooked event
   * @param {Function|number} fn    The function, or ID number for the function, that should be turned off
   */
  static off(hook: string, fn: Function | number): void;
  /**
   * Call all hook listeners in the order in which they were registered
   * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
   *
   * @param {string} hook   The hook being triggered
   * @param {...*} args     Arguments passed to the hook callback functions
   * @returns {boolean}     Were all hooks called without execution being prevented?
   */
  static callAll(hook: string, ...args: any[]): boolean;
  /**
   * Call hook listeners in the order in which they were registered.
   * Continue calling hooks until either all have been called or one returns false.
   *
   * Hook listeners which return false denote that the original event has been adequately handled and no further
   * hooks should be called.
   *
   * @param {string} hook   The hook being triggered
   * @param {...*} args     Arguments passed to the hook callback functions
   * @returns {boolean}     Were all hooks called without execution being prevented?
   */
  static call(hook: string, ...args: any[]): boolean;
  /**
   * Call a hooked function using provided arguments and perhaps unregister it.
   * @param {HookedFunction} entry    The hooked function entry
   * @param {any[]} args              Arguments to be passed
   * @private
   */
  private static "__#16@#call";
  /**
   * Notify subscribers that an error has occurred within foundry.
   * @param {string} location                The method where the error was caught.
   * @param {Error} error                    The error.
   * @param {object} [options={}]            Additional options to configure behaviour.
   * @param {string} [options.msg=""]        A message which should prefix the resulting error or notification.
   * @param {?string} [options.log=null]     The level at which to log the error to console (if at all).
   * @param {?string} [options.notify=null]  The level at which to spawn a notification in the UI (if at all).
   * @param {object} [options.data={}]       Additional data to pass to the hook subscribers.
   */
  static onError(
    location: string,
    error: Error,
    {
      msg,
      notify,
      log,
      ...data
    }?:
      | {
          msg?: string | undefined;
          log?: string | null | undefined;
          notify?: string | null | undefined;
          data?: object | undefined;
        }
      | undefined
  ): void;
}
type HookedFunction = {
  hook: string;
  id: number;
  fn: Function;
  once: boolean;
};
/**
 * A helper class to provide common functionality for working with Image objects
 */
declare class ImageHelper {
  /**
   * Create thumbnail preview for a provided image path.
   * @param {string|PIXI.DisplayObject} src   The URL or display object of the texture to render to a thumbnail
   * @param {object} options    Additional named options passed to the compositeCanvasTexture function
   * @param {number} [options.width]        The desired width of the resulting thumbnail
   * @param {number} [options.height]       The desired height of the resulting thumbnail
   * @param {number} [options.tx]           A horizontal transformation to apply to the provided source
   * @param {number} [options.ty]           A vertical transformation to apply to the provided source
   * @param {boolean} [options.center]      Whether to center the object within the thumbnail
   * @param {string} [options.format]       The desired output image format
   * @param {number} [options.quality]      The desired output image quality
   * @returns {Promise<object>}  The parsed and converted thumbnail data
   */
  static createThumbnail(
    src: string | PIXI.DisplayObject,
    {
      width,
      height,
      tx,
      ty,
      center,
      format,
      quality,
    }: {
      width?: number | undefined;
      height?: number | undefined;
      tx?: number | undefined;
      ty?: number | undefined;
      center?: boolean | undefined;
      format?: string | undefined;
      quality?: number | undefined;
    }
  ): Promise<object>;
  /**
   * Test whether a source file has a supported image extension type
   * @param {string} src      A requested image source path
   * @returns {boolean}       Does the filename end with a valid image extension?
   */
  static hasImageExtension(src: string): boolean;
  /**
   * Composite a canvas object by rendering it to a single texture
   *
   * @param {PIXI.DisplayObject} object   The object to render to a texture
   * @param {object} [options]            Options which configure the resulting texture
   * @param {number} [options.width]        The desired width of the output texture
   * @param {number} [options.height]       The desired height of the output texture
   * @param {number} [options.tx]           A horizontal translation to apply to the object
   * @param {number} [options.ty]           A vertical translation to apply to the object
   * @param {boolean} [options.center]      Center the texture in the rendered frame?
   *
   * @returns {PIXI.Texture}              The composite Texture object
   */
  static compositeCanvasTexture(
    object: PIXI.DisplayObject,
    {
      width,
      height,
      tx,
      ty,
      center,
    }?:
      | {
          width?: number | undefined;
          height?: number | undefined;
          tx?: number | undefined;
          ty?: number | undefined;
          center?: boolean | undefined;
        }
      | undefined
  ): PIXI.Texture;
  /**
   * Extract a texture to a base64 PNG string
   * @param {PIXI.Texture} texture      The texture object to extract
   * @param {string} [format]           Image format, e.g. "image/jpeg" or "image/webp".
   * @param {number} [quality]          JPEG or WEBP compression from 0 to 1. Default is 0.92.
   * @return {string}                   A base64 png string of the texture
   */
  static textureToImage(
    texture: PIXI.Texture,
    { format, quality }?: string | undefined
  ): string;
  /**
   * Asynchronously convert a DisplayObject container to base64 using Canvas#toBlob and FileReader
   * @param {PIXI.DisplayObject} target     A PIXI display object to convert
   * @param {string} type                   The requested mime type of the output, default is image/png
   * @param {number} quality                A number between 0 and 1 for image quality if image/jpeg or image/webp
   * @returns {Promise<string>}             A processed base64 string
   */
  static pixiToBase64(
    target: PIXI.DisplayObject,
    type: string,
    quality: number
  ): Promise<string>;
  /**
   * Upload a base64 image string to a persisted data storage location
   * @param {string} base64       The base64 string
   * @param {string} fileName     The file name to upload
   * @param {string} filePath     The file path where the file should be uploaded
   * @param {object} [options]    Additional options which affect uploading
   * @param {string} [options.storage=data]   The data storage location to which the file should be uploaded
   * @param {string} [options.type]           The MIME type of the file being uploaded
   * @returns {Promise<object>}   A promise which resolves to the FilePicker upload response
   */
  static uploadBase64(
    base64: string,
    fileName: string,
    filePath: string,
    {
      storage,
      type,
    }?:
      | {
          storage?: string | undefined;
          type?: string | undefined;
        }
      | undefined
  ): Promise<object>;
}
/**
 * A class responsible for managing defined game keybinding.
 * Each keybinding is a string key/value pair belonging to a certain namespace and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as as game.keybindings.
 *
 * @see {@link Game#keybindings}
 * @see {@link SettingKeybindingConfig}
 * @see {@link KeybindingsConfig}
 */
declare class ClientKeybindings {
  static MOVEMENT_DIRECTIONS: {
    UP: string;
    LEFT: string;
    DOWN: string;
    RIGHT: string;
  };
  static ZOOM_DIRECTIONS: {
    IN: string;
    OUT: string;
  };
  /**
   * A helper method that, when given a value, ensures that the returned value is a standardized Binding array
   * @param {KeybindingActionBinding[]} values  An array of keybinding assignments to be validated
   * @return {KeybindingActionBinding[]}        An array of keybinding assignments confirmed as valid
   * @private
   */
  private static _validateBindings;
  /**
   * Validate that assigned modifiers are allowed
   * @param {string[]} keys           An array of modifiers which may be valid
   * @returns {string[]}              An array of modifiers which are confirmed as valid
   * @private
   */
  private static _validateModifiers;
  /**
   * Compares two Keybinding Actions based on their Order
   * @param {KeybindingAction} a   The first Keybinding Action
   * @param {KeybindingAction} b   the second Keybinding Action
   * @returns {number}
   * @internal
   */
  static _compareActions(a: KeybindingAction, b: KeybindingAction): number;
  /**
   * Handle Select all action
   * @param {KeyboardEvent} event             The originating keyboard event
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onSelectAllObjects;
  /**
   * Handle Cycle View actions
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onCycleView;
  /**
   * Handle Dismiss actions
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onDismiss;
  /**
   * Open Character sheet for current token or controlled actor
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onToggleCharacterSheet;
  /**
   * Handle action to target the currently hovered token.
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onTarget;
  /**
   * Handle DELETE Keypress Events
   * @param {KeyboardEvent} event             The originating keyboard event
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onDelete;
  /**
   * Handle Measured Ruler Movement Action
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onMeasuredRulerMovement;
  /**
   * Handle Pause Action
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onPause;
  /**
   * Handle Highlight action
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onHighlight;
  /**
   * Handle Macro executions
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onMacroExecute;
  /**
   * Handle Macro page swaps
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onMacroPageSwap;
  /**
   * Handle action to copy data to clipboard
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onCopy;
  /**
   * Handle Paste action
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onPaste;
  /**
   * Handle Undo action
   * @param {KeyboardEventContext} context    The context data of the event
   * @private
   */
  private static _onUndo;
  /**
   * Handle presses to keyboard zoom keys
   * @param {KeyboardEventContext} context                    The context data of the event
   * @param {ClientKeybindings.ZOOM_DIRECTIONS} zoomDirection The direction to zoom
   * @private
   */
  private static _onZoom;
  /**
   * Bring the chat window into view and focus the input
   * @param {KeyboardEventContext} context    The context data of the event
   * @returns {boolean}
   * @private
   */
  private static _onFocusChat;
  /**
   * Registered Keybinding actions
   * @type {Map<string, KeybindingActionConfig>}
   */
  actions: Map<string, KeybindingActionConfig>;
  /**
   * A mapping of a string key to possible Actions that might execute off it
   * @type {Map<string, KeybindingAction[]>}
   */
  activeKeys: Map<string, KeybindingAction[]>;
  /**
   * A stored cache of Keybind Actions Ids to Bindings
   * @type {Map<string, KeybindingActionBinding[]>}
   */
  bindings: Map<string, KeybindingActionBinding[]>;
  /**
   * A count of how many registered keybindings there are
   * @type {number}
   * @private
   */
  private _registered;
  /**
   * A timestamp which tracks the last time a pan operation was performed
   * @type {number}
   * @private
   */
  private _moveTime;
  /**
   * An alias of the movement key set tracked by the keyboard
   * @returns {Set<string>}>
   */
  get moveKeys(): Set<string>;
  /**
   * Initializes the keybinding values for all registered actions
   */
  initialize(): void;
  /**
   * Register a new keybinding
   *
   * @param {string} namespace                  The namespace the Keybinding Action belongs to
   * @param {string} action                     A unique machine-readable id for the Keybinding Action
   * @param {KeybindingActionConfig} data       Configuration for keybinding data
   *
   * @example Define a keybinding which shows a notification
   * ```js
   * game.keybindings.register("myModule", "showNotification", {
   *   name: "My Settings Keybinding",
   *   hint: "A description of what will occur when the Keybinding is executed.",
   *   uneditable: [
   *     {
   *       key: "Digit1",
   *       modifiers: ["Control"]
   *     }
   *   ],
   *   editable: [
   *     {
   *       key: "F1"
   *     }
   *   ],
   *   onDown: () => { ui.notifications.info("Pressed!") },
   *   onUp: () => {},
   *   restricted: true,                         // Restrict this Keybinding to gamemaster only?
   *   reservedModifiers: ["Alt""],              // If the ALT modifier is pressed, the notification is permanent instead of temporary
   *   precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL
   * }
   * ```
   */
  register(
    namespace: string,
    action: string,
    data: KeybindingActionConfig
  ): void;
  /**
   * Get the current Bindings of a given namespace's Keybinding Action
   *
   * @param {string} namespace   The namespace under which the setting is registered
   * @param {string} action      The keybind action to retrieve
   * @returns {KeybindingActionBinding[]}
   *
   * @example Retrieve the current Keybinding Action Bindings
   * ```js
   * game.keybindings.get("myModule", "showNotification");
   * ```
   */
  get(namespace: string, action: string): KeybindingActionBinding[];
  /**
   * Set the editable Bindings of a Keybinding Action for a certain namespace and Action
   *
   * @param {string} namespace                    The namespace under which the Keybinding is registered
   * @param {string} action                       The Keybinding action to set
   * @param {KeybindingActionBinding[]} bindings  The Bindings to assign to the Keybinding
   *
   * @example Update the current value of a keybinding
   * ```js
   * game.keybindings.set("myModule", "showNotification", [
   *     {
   *       key: "F2",
   *       modifiers: [ "CONTROL" ]
   *     }
   * ]);
   * ```
   */
  set(
    namespace: string,
    action: string,
    bindings: KeybindingActionBinding[]
  ): Promise<any>;
  /**
   * Reset all client keybindings back to their default configuration.
   */
  resetDefaults(): Promise<any>;
  /**
   * Register core keybindings
   */
  _registerCoreKeybindings(): void;
  /**
   * Handle keyboard movement once a small delay has elapsed to allow for multiple simultaneous key-presses.
   * @param {KeyboardEventContext} context        The context data of the event
   * @param {InteractionLayer} layer              The active InteractionLayer instance
   * @private
   */
  private _handleMovement;
  /**
   * Handle panning the canvas using CTRL + directional keys
   */
  _handleCanvasPan(): any;
  /**
   * Handle Pan action
   * @param {KeyboardEventContext} context          The context data of the event
   * @param {string[]} movementDirections           The Directions being panned in
   * @private
   */
  private _onPan;
}
/**
 * A set of helpers and management functions for dealing with user input from keyboard events.
 * {@link https://keycode.info/}
 */
declare class KeyboardManager {
  /**
   * Allowed modifier keys
   * @enum {string}
   */
  static MODIFIER_KEYS: {
    CONTROL: string;
    SHIFT: string;
    ALT: string;
  };
  /**
   * Track which KeyboardEvent#code presses associate with each modifier
   * @enum {string[]}
   */
  static MODIFIER_CODES: {
    [x: string]: string[];
  };
  /**
   * Key codes which are "protected" and should not be used because they are reserved for browser-level actions.
   * @type {string[]}
   */
  static PROTECTED_KEYS: string[];
  /**
   * The OS-specific string display for what their Command key is
   * @type {string}
   */
  static CONTROL_KEY_STRING: string;
  /**
   * An special mapping of how special KeyboardEvent#code values should map to displayed strings or symbols.
   * Values in this configuration object override any other display formatting rules which may be applied.
   * @type {Object<string, string>}
   */
  static KEYCODE_DISPLAY_MAPPING: {
    [x: string]: string;
  };
  /**
   * Emulates a key being pressed, triggering the Keyboard event workflow.
   * @param {boolean} up                        If True, emulates the `keyup` Event. Else, the `keydown` event
   * @param {string} code                       The KeyboardEvent#code which is being pressed
   * @param {object} [options]                  Additional options to configure behavior.
   * @param {boolean} [options.altKey=false]    Emulate the ALT modifier as pressed
   * @param {boolean} [options.ctrlKey=false]   Emulate the CONTROL modifier as pressed
   * @param {boolean} [options.shiftKey=false]  Emulate the SHIFT modifier as pressed
   * @param {boolean} [options.repeat=false]    Emulate this as a repeat event
   * @param {boolean} [options.force=false]     Force the event to be handled.
   * @returns {KeyboardEventContext}
   */
  static emulateKeypress(
    up: boolean,
    code: string,
    {
      altKey,
      ctrlKey,
      shiftKey,
      repeat,
      force,
    }?:
      | {
          altKey?: boolean | undefined;
          ctrlKey?: boolean | undefined;
          shiftKey?: boolean | undefined;
          repeat?: boolean | undefined;
          force?: boolean | undefined;
        }
      | undefined
  ): KeyboardEventContext;
  /**
   * Format a KeyboardEvent#code into a displayed string.
   * @param {string} code       The input code
   * @returns {string}          The displayed string for this code
   */
  static getKeycodeDisplayString(code: string): string;
  /**
   * Get a standardized keyboard context for a given event.
   * Every individual keypress is uniquely identified using the KeyboardEvent#code property.
   * A list of possible key codes is documented here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
   *
   * @param {KeyboardEvent} event   The originating keypress event
   * @param {boolean} up            A flag for whether the key is down or up
   * @return {KeyboardEventContext} The standardized context of the event
   */
  static getKeyboardEventContext(
    event: KeyboardEvent,
    up?: boolean
  ): KeyboardEventContext;
  /**
   * Converts a Keyboard Context event into a string representation, such as "C" or "Control+C"
   * @param {KeyboardEventContext} context  The standardized context of the event
   * @param {boolean} includeModifiers      If True, includes modifiers in the string representation
   * @return {string}
   * @private
   */
  private static _getContextDisplayString;
  /**
   * Given a standardized pressed key, find all matching registered Keybind Actions.
   * @param {KeyboardEventContext} context  A standardized keyboard event context
   * @return {KeybindingAction[]}           The matched Keybind Actions. May be empty.
   * @internal
   */
  static _getMatchingActions(context: KeyboardEventContext): KeybindingAction[];
  /**
   * Test whether a keypress context matches the registration for a keybinding action
   * @param {KeybindingAction} action             The keybinding action
   * @param {KeyboardEventContext} context        The keyboard event context
   * @returns {boolean}                           Does the context match the action requirements?
   * @private
   */
  private static _testContext;
  /**
   * Given a registered Keybinding Action, executes the action with a given event and context
   *
   * @param {KeybindingAction} keybind         The registered Keybinding action to execute
   * @param {KeyboardEventContext} context     The gathered context of the event
   * @return {boolean}                         Returns true if the keybind was consumed
   * @private
   */
  private static _executeKeybind;
  /**
   * The set of key codes which are currently depressed (down)
   * @type {Set<string>}
   */
  downKeys: Set<string>;
  /**
   * The set of movement keys which were recently pressed
   * @type {Set<string>}
   */
  moveKeys: Set<string>;
  /**
   * Test whether a Form Element currently has focus
   * @returns {boolean}
   */
  get hasFocus(): boolean;
  /**
   * Report whether a modifier in KeyboardManager.MODIFIER_KEYS is currently actively depressed.
   * @param {string} modifier     A modifier in MODIFIER_KEYS
   * @returns {boolean}           Is this modifier key currently down (active)?
   */
  isModifierActive(modifier: string): boolean;
  /**
   * Processes a keyboard event context, checking it against registered keybinding actions
   * @param {KeyboardEventContext} context   The keyboard event context
   * @param {object} [options]               Additional options to configure behavior.
   * @param {boolean} [options.force=false]  Force the event to be handled.
   * @protected
   */
  protected _processKeyboardContext(
    context: KeyboardEventContext,
    {
      force,
    }?:
      | {
          force?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Reset tracking for which keys are in the down and released states
   * @private
   */
  private _reset;
  /**
   * Emulate a key-up event for any currently down keys. When emulating, we go backwards such that combinations such as
   * "CONTROL + S" emulate the "S" first in order to capture modifiers.
   * @param {object} [options]              Options to configure behavior.
   * @param {boolean} [options.force=true]  Force the keyup events to be handled.
   */
  releaseKeys({
    force,
  }?:
    | {
        force?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Handle a key press into the down position
   * @param {KeyboardEvent} event   The originating keyboard event
   * @param {boolean} up            A flag for whether the key is down or up
   * @private
   */
  private _handleKeyboardEvent;
  /**
   * Input events do not fire with isComposing = false at the end of a composition event in Chrome
   * See: https://github.com/w3c/uievents/issues/202
   * @param {CompositionEvent} event
   */
  _onCompositionEnd(event: CompositionEvent): void;
  /**
   * Release any down keys when focusing a form element.
   * @param {FocusEvent} event  The focus event.
   * @protected
   */
  protected _onFocusIn(event: FocusEvent): void;
}
/**
 * Allowed modifier keys
 */
type MODIFIER_KEYS = string;
/**
 * Track which KeyboardEvent#code presses associate with each modifier
 */
type MODIFIER_CODES = string[];
/**
 * Management class for Mouse events
 */
declare class MouseManager {
  /**
   * Specify a rate limit for mouse wheel to gate repeated scrolling.
   * This is especially important for continuous scrolling mice which emit hundreds of events per second.
   * This designates a minimum number of milliseconds which must pass before another wheel event is handled
   * @type {number}
   */
  static MOUSE_WHEEL_RATE_LIMIT: number;
  _wheelTime: number;
  /**
   * Master mouse-wheel event handler
   * @param {WheelEvent} event    The mouse wheel event
   * @private
   */
  private _onWheel;
}
/**
 * Responsible for managing the New User Experience workflows.
 */
declare class NewUserExperience {
  /**
   * Initialize the new user experience.
   * Currently, this generates some chat messages with hints for getting started if we detect this is a new world.
   */
  initialize(): void;
  /**
   * Show chat tips for first launch.
   * @private
   */
  private _createInitialChatMessages;
  /**
   * Create a default scene for the new world.
   * @private
   */
  private _createDefaultScene;
  /**
   * Automatically show uncompleted Tours related to new worlds.
   * @private
   */
  private _showNewWorldTour;
  /**
   * Add event listeners to the chat card links.
   * @param {ChatMessage} msg  The ChatMessage being rendered.
   * @param {jQuery} html      The HTML content of the message.
   * @private
   */
  private _activateListeners;
  /**
   * Perform some special action triggered by clicking on a link in a NUE chat card.
   * @param {TriggeredEvent} event  The click event.
   * @private
   */
  private _onActionLink;
  /**
   * Switch to the appropriate tab when a user clicks on a link in the chat message.
   * @param {TriggeredEvent} event  The click event.
   * @private
   */
  private _onTabLink;
}
/**
 * A client-side mixin used for all Package types.
 * @param {typeof BasePackage} BasePackage    The parent BasePackage class being mixed
 * @returns {typeof ClientPackage}            A BasePackage subclass mixed with ClientPackage features
 * @category - Mixins
 */
declare function ClientPackageMixin(BasePackage: any): any;
/**
 * @extends foundry.packages.BaseModule
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class Module {
  constructor(data: any, options?: {});
}
/**
 * @extends foundry.packages.BaseSystem
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class System {}
/**
 * @extends foundry.packages.BaseWorld
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class World {}
declare namespace PACKAGE_TYPES {
  export { World as world };
  export { System as system };
  export { Module as module };
}
/**
 * A class responsible for managing defined game settings or settings menus.
 * Each setting is a string key/value pair belonging to a certain namespace and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as as game.settings.
 *
 * @see {@link Game#settings}
 * @see {@link Settings}
 * @see {@link SettingsConfig}
 */
declare class ClientSettings {
  /**
   * The types of settings which should be constructed as a function call rather than as a class constructor.
   * @private
   */
  private static PRIMITIVE_TYPES;
  constructor(worldSettings: any);
  /**
   * A object of registered game settings for this scope
   * @type {Map<string, SettingsConfig>}
   */
  settings: Map<string, SettingsConfig>;
  /**
   * Registered settings menus which trigger secondary applications
   * @type {Map}
   */
  menus: Map<any, any>;
  /**
   * The storage interfaces used for persisting settings
   * Each storage interface shares the same API as window.localStorage
   */
  storage: Map<string, Storage>;
  /**
   * Return a singleton instance of the Game Settings Configuration app
   * @returns {SettingsConfig}
   */
  get sheet(): SettingsConfig;
  _sheet: SettingsConfig | undefined;
  /**
   * Register a new game setting under this setting scope
   *
   * @param {string} namespace    The namespace under which the setting is registered
   * @param {string} key          The key name for the setting under the namespace
   * @param {SettingConfig} data  Configuration for setting data
   *
   * @example Register a client setting
   * ```js
   * game.settings.register("myModule", "myClientSetting", {
   *   name: "Register a Module Setting with Choices",
   *   hint: "A description of the registered setting and its behavior.",
   *   scope: "client",     // This specifies a client-stored setting
   *   config: true,        // This specifies that the setting appears in the configuration view
   *   requiresReload: true // This will prompt the user to reload the application for the setting to take effect.
   *   type: String,
   *   choices: {           // If choices are defined, the resulting setting will be a select menu
   *     "a": "Option A",
   *     "b": "Option B"
   *   },
   *   default: "a",        // The default value for the setting
   *   onChange: value => { // A callback function which triggers when the setting is changed
   *     console.log(value)
   *   }
   * });
   * ```
   *
   * @example Register a world setting
   * ```js
   * game.settings.register("myModule", "myWorldSetting", {
   *   name: "Register a Module Setting with a Range slider",
   *   hint: "A description of the registered setting and its behavior.",
   *   scope: "world",      // This specifies a world-level setting
   *   config: true,        // This specifies that the setting appears in the configuration view
   *   requiresReload: true // This will prompt the GM to have all clients reload the application for the setting to
   *                        // take effect.
   *   type: Number,
   *   range: {             // If range is specified, the resulting setting will be a range slider
   *     min: 0,
   *     max: 100,
   *     step: 10
   *   }
   *   default: 50,         // The default value for the setting
   *   onChange: value => { // A callback function which triggers when the setting is changed
   *     console.log(value)
   *   }
   * });
   * ```
   */
  register(namespace: string, key: string, data: SettingConfig): void;
  /**
   * Register a new sub-settings menu
   *
   * @param {string} namespace           The namespace under which the menu is registered
   * @param {string} key                 The key name for the setting under the namespace
   * @param {SettingSubmenuConfig} data  Configuration for setting data
   *
   * @example Define a settings submenu which handles advanced configuration needs
   * ```js
   * game.settings.registerMenu("myModule", "mySettingsMenu", {
   *   name: "My Settings Submenu",
   *   label: "Settings Menu Label",      // The text label used in the button
   *   hint: "A description of what will occur in the submenu dialog.",
   *   icon: "fas fa-bars",               // A Font Awesome icon used in the submenu button
   *   type: MySubmenuApplicationClass,   // A FormApplication subclass which should be created
   *   restricted: true                   // Restrict this submenu to gamemaster only?
   * });
   * ```
   */
  registerMenu(
    namespace: string,
    key: string,
    data: SettingSubmenuConfig
  ): void;
  /**
   * Get the value of a game setting for a certain namespace and setting key
   *
   * @param {string} namespace   The namespace under which the setting is registered
   * @param {string} key         The setting key to retrieve
   *
   * @example Retrieve the current setting value
   * ```js
   * game.settings.get("myModule", "myClientSetting");
   * ```
   */
  get(namespace: string, key: string): any;
  /**
   * Set the value of a game setting for a certain namespace and setting key
   *
   * @param {string} namespace   The namespace under which the setting is registered
   * @param {string} key         The setting key to retrieve
   * @param {*} value            The data to assign to the setting key
   * @param {object} [options]   Additional options passed to the server when updating world-scope settings
   *
   * @example Update the current value of a setting
   * ```js
   * game.settings.set("myModule", "myClientSetting", "b");
   * ```
   */
  set(
    namespace: string,
    key: string,
    value: any,
    options?: object | undefined
  ): Promise<any>;
}
declare class SocketInterface {
  /**
   * Standardize the way that socket messages are dispatched and their results are handled
   * @param {string} eventName          The socket event name being handled
   * @param {SocketRequest} request     Data provided to the Socket event
   * @returns {Promise<SocketResponse>} A Promise which resolves to the SocketResponse
   */
  static dispatch(
    eventName: string,
    request: SocketRequest
  ): Promise<SocketResponse>;
  /**
   * Handle an error returned from the database, displaying it on screen and in the console
   * @param {Error} err   The provided Error message
   * @private
   */
  private static _handleError;
}
/**
 * A collection of functions related to sorting objects within a parent container.
 */
declare class SortingHelpers {
  /**
   * Given a source object to sort, a target to sort relative to, and an Array of siblings in the container:
   * Determine the updated sort keys for the source object, or all siblings if a reindex is required.
   * Return an Array of updates to perform, it is up to the caller to dispatch these updates.
   * Each update is structured as:
   * {
   *   target: object,
   *   update: {sortKey: sortValue}
   * }
   *
   * @param {object} source       The source object being sorted
   * @param {object} [options]    Options which modify the sort behavior
   * @param {object|null} [options.target]  The target object relative which to sort
   * @param {object[]} [options.siblings]   The Array of siblings which the source should be sorted within
   * @param {string} [options.sortKey=sort] The property name within the source object which defines the sort key
   * @param {boolean} [options.sortBefore]  Explicitly sort before (true) or sort after( false).
   *                                        If undefined the sort order will be automatically determined.
   * @returns {object[]}          An Array of updates for the caller of the helper function to perform
   */
  static performIntegerSort(
    source: object,
    {
      target,
      siblings,
      sortKey,
      sortBefore,
    }?:
      | {
          target?: object | null | undefined;
          siblings?: object[] | undefined;
          sortKey?: string | undefined;
          sortBefore?: boolean | undefined;
        }
      | undefined
  ): object[];
  /**
   * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort before the target
   * @private
   */
  private static _sortBefore;
  /**
   * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort after the target
   * @private
   */
  private static _sortAfter;
}
/**
 * A singleton class {@link game#time} which keeps the official Server and World time stamps.
 * Uses a basic implementation of https://www.geeksforgeeks.org/cristians-algorithm/ for synchronization.
 */
declare class GameTime {
  /**
   * The amount of time to delay before re-syncing the official server time.
   * @type {number}
   */
  static SYNC_INTERVAL_MS: number;
  constructor(socket: any);
  /**
   * The most recently synchronized timestamps retrieved from the server.
   * @type {{clientTime: number, serverTime: number, worldTime: number}}
   */
  _time: {
    clientTime: number;
    serverTime: number;
    worldTime: number;
  };
  /**
   * The average one-way latency across the most recent 5 trips
   * @type {number}
   */
  _dt: number;
  /**
   * The most recent five synchronization durations
   * @type {number[]}
   */
  _dts: number[];
  /**
   * The current server time based on the last synchronization point and the approximated one-way latency.
   * @type {number}
   */
  get serverTime(): number;
  /**
   * The current World time based on the last recorded value of the core.time setting
   * @type {number}
   */
  get worldTime(): number;
  /**
   * Advance the game time by a certain number of seconds
   * @param {number} seconds        The number of seconds to advance (or rewind if negative) by
   * @param {object} [options]      Additional options passed to game.settings.set
   * @returns {Promise<number>}     The new game time
   */
  advance(seconds: number, options?: object | undefined): Promise<number>;
  /**
   * Synchronize the local client game time with the official time kept by the server
   * @param {Socket} socket         The connected server Socket instance
   * @returns {Promise<GameTime>}
   */
  sync(socket: Socket): Promise<GameTime>;
  /**
   * Handle follow-up actions when the official World time is changed
   * @param {number} worldTime      The new canonical World time.
   * @param {object} options        Options passed from the requesting client where the change was made
   * @param {string} userId         The ID of the User who advanced the time
   */
  onUpdateWorldTime(worldTime: number, options: object, userId: string): void;
}
/**
 * A singleton Tooltip Manager class responsible for rendering and positioning a dynamic tooltip element which is
 * accessible as `game.tooltip`.
 *
 * @see {@link Game.tooltip}
 *
 * @example API Usage
 * ```js
 * game.tooltip.activate(htmlElement, {text: "Some tooltip text", direction: "UP"});
 * game.tooltip.deactivate();
 * ```
 *
 * @example HTML Usage
 * ```html
 * <span data-tooltip="Some Tooltip" data-tooltip-direction="LEFT">I have a tooltip</span>
 * <ol data-tooltip-direction="RIGHT">
 *   <li data-tooltip="The First One">One</li>
 *   <li data-tooltip="The Second One">Two</li>
 *   <li data-tooltip="The Third One">Three</li>
 * </ol>
 * ```
 */
declare class TooltipManager {
  /**
   * An amount of margin which is used to offset tooltips from their anchored element.
   * @type {number}
   */
  static TOOLTIP_MARGIN_PX: number;
  /**
   * The number of milliseconds delay which activates a tooltip on a "long hover".
   * @type {number}
   */
  static TOOLTIP_ACTIVATION_MS: number;
  /**
   * The directions in which a tooltip can extend, relative to its tool-tipped element.
   * @enum {string}
   */
  static TOOLTIP_DIRECTIONS: {
    UP: string;
    DOWN: string;
    LEFT: string;
    RIGHT: string;
    CENTER: string;
  };
  /**
   * A cached reference to the global tooltip element
   * @type {HTMLElement}
   */
  tooltip: HTMLElement;
  /**
   * A reference to the HTML element which is currently tool-tipped, if any.
   * @type {HTMLElement|null}
   */
  element: HTMLElement | null;
  /**
   * Activate interactivity by listening for hover events on HTML elements which have a data-tooltip defined.
   */
  activateEventListeners(): void;
  /**
   * Activate the tooltip for a hovered HTML element which defines a tooltip localization key.
   * @param {HTMLElement} element     The HTML element being hovered.
   * @param {object} [options={}]     Additional options which can override tooltip behavior.
   * @param {string} [options.text]       Explicit tooltip text to display. If this is not provided the tooltip text is
   *                                      acquired from the elements data-tooltip attribute. This text will be
   *                                      automatically localized
   * @param {TooltipManager.TOOLTIP_DIRECTIONS} [options.direction]  An explicit tooltip expansion direction. If this
   *                                      is not provided the direction is acquired from the data-tooltip-direction
   *                                      attribute of the element or one of its parents.
   * @param {string} [options.cssClass]   An optional CSS class to apply to the activated tooltip.
   */
  activate(
    element: HTMLElement,
    {
      text,
      direction,
      cssClass,
    }?:
      | {
          text?: string | undefined;
          direction?:
            | {
                UP: string;
                DOWN: string;
                LEFT: string;
                RIGHT: string;
                CENTER: string;
              }
            | undefined;
          cssClass?: string | undefined;
        }
      | undefined
  ): void;
  /**
   * Deactivate the tooltip from a previously hovered HTML element.
   * @private
   */
  private deactivate;
  /**
   * Clear any pending activation workflow.
   * @internal
   */
  clearPending(): void;
  /**
   * If an explicit tooltip expansion direction was not specified, figure out a valid direction based on the bounds
   * of the target element and the screen.
   * @private
   */
  private _determineDirection;
  /**
   * Set tooltip position relative to an HTML element using an explicitly provided data-tooltip-direction.
   * @param {TooltipManager.TOOLTIP_DIRECTIONS} direction  The tooltip expansion direction specified by the element
   *                                                        or a parent element.
   * @private
   */
  private _setAnchor;
  /**
   * Apply inline styling rules to the tooltip for positioning and text alignment.
   * @param {object} [position={}]  An object of positioning data, supporting top, right, bottom, left, and textAlign
   * @private
   */
  private _setStyle;
  #private;
}
/**
 * The directions in which a tooltip can extend, relative to its tool-tipped element.
 */
type TOOLTIP_DIRECTIONS = string;
/**
 * @typedef {Object} TourStep               A step in a Tour
 * @property {string} id                    A machine-friendly id of the Tour Step
 * @property {string} title                 The title of the step, displayed in the tooltip header
 * @property {string} content               Raw HTML content displayed during the step
 * @property {string} [selector]            A DOM selector which denotes an element to highlight during this step.
 *                                          If omitted, the step is displayed in the center of the screen.
 * @property {TooltipManager.TOOLTIP_DIRECTIONS} [tooltipDirection]  How the tooltip for the step should be displayed
 *                                          relative to the target element. If omitted, the best direction will be attempted to be auto-selected.
 * @property {boolean} [restricted]         Whether the Step is restricted to the GM only. Defaults to false.
 */
/**
 * @typedef {Object} TourConfig               Tour configuration data
 * @property {string} namespace               The namespace this Tour belongs to. Typically, the name of the package which
 *                                            implements the tour should be used
 * @property {string} id                      A machine-friendly id of the Tour, must be unique within the provided namespace
 * @property {string} title                   A human-readable name for this Tour. Localized.
 * @property {TourStep[]} steps               The list of Tour Steps
 * @property {string} [description]           A human-readable description of this Tour. Localized.
 * @property {object} [localization]          A map of localizations for the Tour that should be merged into the default localizations
 * @property {boolean} [restricted]           Whether the Tour is restricted to the GM only. Defaults to false.
 * @property {boolean} [display]              Whether the Tour should be displayed in the Manage Tours UI. Defaults to false.
 * @property {boolean} [canBeResumed]         Whether the Tour can be resumed or if it always needs to start from the beginning. Defaults to false.
 * @property {string[]} [suggestedNextTours]  A list of namespaced Tours that might be suggested to the user when this Tour is completed.
 *                                            The first non-completed Tour in the array will be recommended.
 */
/**
 * A Tour that shows a series of guided steps.
 * @param {TourConfig} config           The configuration of the Tour
 * @tutorial tours
 */
declare class Tour {
  /**
   * A singleton reference which tracks the currently active Tour.
   * @type {Tour|null}
   */
  static "__#18@#activeTour": Tour | null;
  /**
   * @enum {string}
   */
  static STATUS: {
    UNSTARTED: string;
    IN_PROGRESS: string;
    COMPLETED: string;
  };
  /**
   * Indicates if a Tour is currently in progress.
   * @returns {boolean}
   */
  static get tourInProgress(): boolean;
  /**
   * Returns the active Tour, if any
   * @returns {Tour|null}
   */
  static get activeTour(): Tour | null;
  /**
   * Handle a movement action to either progress or regress the Tour.
   * @param @param {string[]} movementDirections           The Directions being moved in
   * @returns {boolean}
   */
  static onMovementAction(movementDirections: string[]): boolean;
  /**
   * Padding around a Highlighted Element
   * @type {number}
   */
  static HIGHLIGHT_PADDING: number;
  /**
   * Creates and returns a Tour by loading a JSON file
   * @param {string} filepath   The path to the JSON file
   * @returns {Promise<Tour>}
   */
  static fromJSON(filepath: string): Promise<Tour>;
  constructor(
    config: any,
    {
      id,
      namespace,
    }?: {
      id: any;
      namespace: any;
    }
  );
  /**
   * Configuration of the tour. This object is cloned to avoid mutating the original configuration.
   * @type {TourConfig}
   */
  config: TourConfig;
  /**
   * The HTMLElement which is the focus of the current tour step.
   * @type {HTMLElement}
   */
  targetElement: HTMLElement;
  /**
   * The HTMLElement that fades out the rest of the screen
   * @type {HTMLElement}
   */
  fadeElement: HTMLElement;
  /**
   * The HTMLElement that blocks input while a Tour is active
   */
  overlayElement: any;
  set id(arg: string);
  /**
   * The unique identifier of the tour.
   * @type {string}
   */
  get id(): string;
  /**
   * The human-readable title for the tour.
   * @type {string}
   */
  get title(): string;
  /**
   * The human-readable description of the tour.
   * @type {string}
   */
  get description(): string;
  set namespace(arg: string);
  /**
   * The package namespace for the tour.
   * @type {string}
   */
  get namespace(): string;
  /**
   * The key the Tour is stored under in game.tours, of the form `${namespace}.${id}`
   * @returns {string}
   */
  get key(): string;
  /**
   * The configuration of tour steps
   * @type {TourStep[]}
   */
  get steps(): TourStep[];
  /**
   * Return the current Step, or null if the tour has not yet started.
   * @type {TourStep|null}
   */
  get currentStep(): TourStep | null;
  /**
   * The index of the current step; -1 if the tour has not yet started, or null if the tour is finished.
   * @type {number|null}
   */
  get stepIndex(): number | null;
  /**
   * Returns True if there is a next TourStep
   * @type {boolean}
   */
  get hasNext(): boolean;
  /**
   * Returns True if there is a previous TourStep
   * @type {boolean}
   */
  get hasPrevious(): boolean;
  /**
   * Return whether this Tour is currently eligible to be started?
   * This is useful for tours which can only be used in certain circumstances, like if the canvas is active.
   * @type {boolean}
   */
  get canStart(): boolean;
  /**
   * The current status of the Tour
   * @returns {STATUS}
   */
  get status(): string;
  /**
   * Advance the tour to a completed state.
   */
  complete(): Promise<any>;
  /**
   * Exit the tour at the current step.
   */
  exit(): void;
  /**
   * Reset the Tour to an un-started state.
   */
  reset(): Promise<any>;
  /**
   * Start the Tour at its current step, or at the beginning if the tour has not yet been started.
   */
  start(): Promise<any>;
  /**
   * Progress the Tour to the next step.
   */
  next(): Promise<any>;
  /**
   * Rewind the Tour to the previous step.
   */
  previous(): Promise<any>;
  /**
   * Progresses to a given Step
   * @param {number} stepIndex  The step to progress to
   */
  progress(stepIndex: number): Promise<any>;
  /**
   * Query the DOM for the target element using the provided selector
   * @param {string} selector     A CSS selector
   * @returns {Element|null}      The target element, or null if not found
   * @protected
   */
  protected _getTargetElement(selector: string): Element | null;
  /**
   * Set-up operations performed before a step is shown.
   * @abstract
   * @protected
   */
  protected _preStep(): Promise<void>;
  /**
   * Clean-up operations performed after a step is completed.
   * @abstract
   * @protected
   */
  protected _postStep(): Promise<void>;
  /**
   * Renders the current Step of the Tour
   * @protected
   */
  protected _renderStep(): Promise<void>;
  /**
   * Handle Tour Button clicks
   * @param {Event} event   A click event
   * @param {HTMLElement[]} buttons   The step buttons
   * @private
   */
  private _onButtonClick;
  /**
   * Saves the current progress of the Tour to a world setting
   * @private
   */
  private _saveProgress;
  /**
   * Returns the User's current progress of this Tour
   * @returns {null|number}
   * @private
   */
  private _loadProgress;
  /**
   * Reloads the Tour's current step from the saved progress
   * @internal
   */
  _reloadProgress(): void;
  #private;
}
type STATUS = string;
/**
 * A step in a Tour
 */
type TourStep = {
  /**
   * A machine-friendly id of the Tour Step
   */
  id: string;
  /**
   * The title of the step, displayed in the tooltip header
   */
  title: string;
  /**
   * Raw HTML content displayed during the step
   */
  content: string;
  /**
   * A DOM selector which denotes an element to highlight during this step.
   *             If omitted, the step is displayed in the center of the screen.
   */
  selector?: string | undefined;
  /**
   * How the tooltip for the step should be displayed
   * relative to the target element. If omitted, the best direction will be attempted to be auto-selected.
   */
  tooltipDirection?:
    | {
        UP: string;
        DOWN: string;
        LEFT: string;
        RIGHT: string;
        CENTER: string;
      }
    | undefined;
  /**
   * Whether the Step is restricted to the GM only. Defaults to false.
   */
  restricted?: boolean | undefined;
};
/**
 * Tour configuration data
 */
type TourConfig = {
  /**
   * The namespace this Tour belongs to. Typically, the name of the package which
   * implements the tour should be used
   */
  namespace: string;
  /**
   * A machine-friendly id of the Tour, must be unique within the provided namespace
   */
  id: string;
  /**
   * A human-readable name for this Tour. Localized.
   */
  title: string;
  /**
   * The list of Tour Steps
   */
  steps: TourStep[];
  /**
   * A human-readable description of this Tour. Localized.
   */
  description?: string | undefined;
  /**
   * A map of localizations for the Tour that should be merged into the default localizations
   */
  localization?: object | undefined;
  /**
   * Whether the Tour is restricted to the GM only. Defaults to false.
   */
  restricted?: boolean | undefined;
  /**
   * Whether the Tour should be displayed in the Manage Tours UI. Defaults to false.
   */
  display?: boolean | undefined;
  /**
   * Whether the Tour can be resumed or if it always needs to start from the beginning. Defaults to false.
   */
  canBeResumed?: boolean | undefined;
  /**
   * A list of namespaced Tours that might be suggested to the user when this Tour is completed.
   *   The first non-completed Tour in the array will be recommended.
   */
  suggestedNextTours?: string[] | undefined;
};
/**
 * A singleton Tour Collection class responsible for registering and activating Tours, accessible as game.tours
 * @see {Game#tours}
 * @extends Map
 */
declare class Tours extends Map<any, any> {
  constructor();
  /**
   * Register a new Tour
   * @param {string} namespace          The namespace of the Tour
   * @param {string} id                 The machine-readable id of the Tour
   * @param {Tour} tour                 The constructed Tour
   * @returns {void}
   */
  register(namespace: string, id: string, tour: Tour): void;
  /**
   * @inheritDoc
   * @override
   */
  override set(key: any, tour: any): Tours;
}
/**
 * Export data content to be saved to a local file
 * @param {string} data       Data content converted to a string
 * @param {string} type       The type of
 * @param {string} filename   The filename of the resulting download
 */
declare function saveDataToFile(
  data: string,
  type: string,
  filename: string
): void;
/**
 * Read text data from a user provided File object
 * @param {File} file           A File object
 * @return {Promise.<String>}   A Promise which resolves to the loaded text data
 */
declare function readTextFromFile(file: File): Promise<string>;
/**
 * Retrieve a Document by its Universally Unique Identifier (uuid).
 * @param {string} uuid                 The uuid of the Document to retrieve.
 * @param {ClientDocument} [relative]   A document to resolve relative UUIDs against.
 * @returns {Promise<Document|null>}    Returns the Document if it could be found, otherwise null.
 */
declare function fromUuid(
  uuid: string,
  relative?: any
): Promise<Document | null>;
/**
 * Retrieve a Document by its Universally Unique Identifier (uuid) synchronously. If the uuid resolves to a compendium
 * document, that document's index entry will be returned instead.
 * @param {string} uuid                The uuid of the Document to retrieve.
 * @param {ClientDocument} [relative]  A document to resolve relative UUIDs against.
 * @returns {Document|object|null}     The Document or its index entry if it resides in a Compendium, otherwise null.
 * @throws If the uuid resolves to a Document that cannot be retrieved synchronously.
 */
declare function fromUuidSync(
  uuid: string,
  relative?: any
): Document | object | null;
/**
 * @typedef {object} ResolvedUUID
 * @property {DocumentCollection} [collection]  The parent collection.
 * @property {string} [documentId]              The parent document.
 * @property {ClientDocument} [doc]             An already-resolved document.
 * @property {string[]} embedded                Any remaining Embedded Document parts.
 */
/**
 * Parse a UUID into its constituent parts.
 * @param {string} uuid                The UUID to parse.
 * @param {ClientDocument} [relative]  A document to resolve relative UUIDs against.
 * @returns {ResolvedUUID}             Returns the Collection and the Document ID to resolve the parent document, as
 *                                     well as the remaining Embedded Document parts, if any.
 * @private
 */
declare function _parseUuid(uuid: string, relative?: any): ResolvedUUID;
/**
 * Resolve a series of embedded document UUID parts against a parent Document.
 * @param {Document} parent  The parent Document.
 * @param {string[]} parts   A series of Embedded Document UUID parts.
 * @returns {Document}       The resolved Embedded Document.
 * @private
 */
declare function _resolveEmbedded(parent: Document, parts: string[]): Document;
/**
 * Resolve a UUID relative to another document.
 * The general-purpose algorithm for resolving relative UUIDs is as follows:
 * 1. If the number of parts is odd, remove the first part and resolve it against the current document and update the
 *    current document.
 * 2. If the number of parts is even, resolve embedded documents against the current document.
 * @param {string} uuid              The UUID to resolve.
 * @param {ClientDocument} relative  The document to resolve against.
 * @returns {ResolvedUUID}
 * @private
 */
declare function _resolveRelativeUuid(
  uuid: string,
  relative: abstract.Document
): ResolvedUUID;
/**
 * Return a reference to the Document class implementation which is configured for use.
 * @param {string} documentName     The canonical Document name, for example "Actor"
 * @returns {typeof ClientDocument} The configured Document class implementation
 */
declare function getDocumentClass(documentName: string): any;
type ResolvedUUID = {
  /**
   * The parent collection.
   */
  collection?: DocumentCollection | undefined;
  /**
   * The parent document.
   */
  documentId?: string | undefined;
  /**
   * An already-resolved document.
   */
  doc?: any;
  /**
   * Any remaining Embedded Document parts.
   */
  embedded: string[];
};
/**
 * A helper class to provide common functionality for working with HTML5 video objects
 * A singleton instance of this class is available as ``game.video``
 */
declare class VideoHelper {
  static hasVideoExtension(src: any): boolean;
  /**
   * A user gesture must be registered before video playback can begin.
   * This Set records the video elements which await such a gesture.
   * @type {Set}
   */
  pending: Set<any>;
  /**
   * A mapping of base64 video thumbnail images
   * @type {Map<string,string>}
   */
  thumbs: Map<string, string>;
  /**
   * A flag for whether video playback is currently locked by awaiting a user gesture
   * @type {boolean}
   */
  locked: boolean;
  /**
   * Return the HTML element which provides the source for a loaded texture.
   * @param {PIXI.Sprite|SpriteMesh} mesh                       The rendered mesh
   * @returns {HTMLImageElement|HTMLVideoElement|null}          The source HTML element
   */
  getSourceElement(
    mesh: PIXI.Sprite | SpriteMesh
  ): HTMLImageElement | HTMLVideoElement | null;
  /**
   * Get the video element source corresponding to a Sprite or SpriteMesh.
   * @param {PIXI.Sprite|SpriteMesh|PIXI.Texture} object        The PIXI source
   * @returns {HTMLVideoElement|null}                           The source video element or null
   */
  getVideoSource(
    object: PIXI.Sprite | SpriteMesh | PIXI.Texture
  ): HTMLVideoElement | null;
  /**
   * Clone a video texture so that it can be played independently of the original base texture.
   * @param {HTMLVideoElement} source     The video element source
   * @returns {Promise<PIXI.Texture>}     An unlinked PIXI.Texture which can be played independently
   */
  cloneTexture(source: HTMLVideoElement): Promise<PIXI.Texture>;
  /**
   * Play a single video source
   * If playback is not yet enabled, add the video to the pending queue
   * @param {HTMLElement} video     The VIDEO element to play
   * @param {object} [options={}]   Additional options for modifying video playback
   * @param {boolean} [options.playing] Should the video be playing? Otherwise, it will be paused
   * @param {boolean} [options.loop]    Should the video loop?
   * @param {number} [options.offset]   A specific timestamp between 0 and the video duration to begin playback
   * @param {number} [options.volume]   Desired volume level of the video's audio channel (if any)
   */
  play(
    video: HTMLElement,
    {
      playing,
      loop,
      offset,
      volume,
    }?:
      | {
          playing?: boolean | undefined;
          loop?: boolean | undefined;
          offset?: number | undefined;
          volume?: number | undefined;
        }
      | undefined
  ): Promise<any>;
  /**
   * Stop a single video source
   * @param {HTMLElement} video   The VIDEO element to stop
   */
  stop(video: HTMLElement): void;
  /**
   * Register an event listener to await the first mousemove gesture and begin playback once observed
   * A user interaction must involve a mouse click or keypress.
   * Listen for any of these events, and handle the first observed gesture.
   */
  awaitFirstGesture(): void;
  /**
   * Handle the first observed user gesture
   * We need a slight delay because unfortunately Chrome is stupid and doesn't always acknowledge the gesture fast enough.
   * @param {Event} event   The mouse-move event which enables playback
   */
  _onFirstGesture(event: Event): void;
  /**
   * Create and cache a static thumbnail to use for the video.
   * The thumbnail is cached using the video file path or URL.
   * @param {string} src        The source video URL
   * @param {object} options    Thumbnail creation options, including width and height
   * @returns {Promise<string>}  The created and cached base64 thumbnail image, or a placeholder image if the canvas is
   *                            disabled and no thumbnail can be generated.
   */
  createThumbnail(src: string, options: object): Promise<string>;
  /**
   * Lazily-load the YouTube API and retrieve a Player instance for a given iframe.
   * @param {string} id      The iframe ID.
   * @param {object} config  A player config object. See {@link https://developers.google.com/youtube/iframe_api_reference} for reference.
   * @returns {Promise<YT.Player>}
   */
  getYouTubePlayer(id: string, config?: object): Promise<YT.Player>;
  /**
   * Retrieve a YouTube video ID from a URL.
   * @param {string} url  The URL.
   * @returns {string}
   */
  getYouTubeId(url: string): string;
  /**
   * Take a URL to a YouTube video and convert it into a URL suitable for embedding in a YouTube iframe.
   * @param {string} url   The URL to convert.
   * @param {object} vars  YouTube player parameters.
   * @returns {string}     The YouTube embed URL.
   */
  getYouTubeEmbedURL(url: string, vars?: object): string;
  /**
   * Test a URL to see if it points to a YouTube video.
   * @param {string} url  The URL to test.
   * @returns {boolean}
   */
  isYouTubeURL(url?: string): boolean;
  #private;
}
/**
 * @typedef {Object<string, *>} WorkerTask
 * @property {number} [taskId]          An incrementing task ID used to reference task progress
 * @property {WorkerManager.WORKER_TASK_ACTIONS} action  The task action being performed, from WorkerManager.WORKER_TASK_ACTIONS
 * @property {function} [resolve]       A Promise resolution handler
 * @property {function} [reject]        A Promise rejection handler
 */
/**
 * An asynchronous web Worker which can load user-defined functions and await execution using Promises.
 * @param {string} name                 The worker name to be initialized
 * @param {object} [options={}]         Worker initialization options
 * @param {boolean} [options.debug=false]           Should the worker run in debug mode?
 * @param {boolean} [options.loadPrimitives=false]  Should the worker automatically load the primitives library?
 */
declare class AsyncWorker extends Worker {
  /**
   * A path reference to the JavaScript file which provides companion worker-side functionality.
   * @type {string}
   */
  static WORKER_HARNESS_JS: string;
  constructor(
    name: any,
    {
      debug,
      loadPrimitives,
    }?: {
      debug?: boolean | undefined;
      loadPrimitives?: boolean | undefined;
    }
  );
  name: any;
  /**
   * A Promise which resolves once the Worker is ready to accept tasks
   * @type {Promise}
   */
  ready: Promise<any>;
  /**
   * A queue of active tasks that this Worker is executing.
   * @type {Map<number, WorkerTask>}
   */
  tasks: Map<number, WorkerTask>;
  /**
   * An auto-incrementing task index.
   * @type {number}
   * @private
   */
  private _taskIndex;
  /**
   * Load a function onto a given Worker.
   * The function must be a pure function with no external dependencies or requirements on global scope.
   * @param {string} functionName   The name of the function to load
   * @param {function} functionRef  A reference to the function that should be loaded
   * @returns {Promise<unknown>}    A Promise which resolves once the Worker has loaded the function.
   */
  loadFunction(functionName: string, functionRef: Function): Promise<unknown>;
  /**
   * Execute a task on a specific Worker.
   * @param {string} functionName   The named function to execute on the worker. This function must first have been
   *                                loaded.
   * @param {Array<*>} params       An array of parameters with which to call the requested function
   * @returns {Promise<unknown>}    A Promise which resolves with the returned result of the function once complete.
   */
  executeFunction(
    functionName: string,
    ...params: Array<any>
  ): Promise<unknown>;
  /**
   * Dispatch a task to a named Worker, awaiting confirmation of the result.
   * @param {WorkerTask} taskData   Data to dispatch to the Worker as part of the task.
   * @returns {Promise}             A Promise which wraps the task transaction.
   * @private
   */
  private _dispatchTask;
  /**
   * Handle messages emitted by the Worker thread.
   * @param {MessageEvent} event      The dispatched message event
   * @private
   */
  private _onMessage;
  /**
   * Handle errors emitted by the Worker thread.
   * @param {ErrorEvent} error        The dispatched error event
   * @private
   */
  private _onError;
}
/**
 * A client-side class responsible for managing a set of web workers.
 * This interface is accessed as a singleton instance via game.workers.
 * @see Game#workers
 */
declare class WorkerManager {
  /**
   * Supported worker task actions
   * @enum {string}
   */
  static WORKER_TASK_ACTIONS: {
    INIT: string;
    LOAD: string;
    EXECUTE: string;
  };
  /**
   * The currently active workforce.
   * @type {Map<string,AsyncWorker>}
   * @private
   */
  private workforce;
  /**
   * Create a new named Worker.
   * @param {string} name                 The named Worker to create
   * @param {object} [config={}]          Worker configuration parameters passed to the AsyncWorker constructor
   * @returns {Promise<AsyncWorker>}      The created AsyncWorker which is ready to accept tasks
   */
  createWorker(name: string, config?: object | undefined): Promise<AsyncWorker>;
  /**
   * Get a currently active Worker by name.
   * @param {string} name             The named Worker to retrieve
   * @returns {AsyncWorker}           The AsyncWorker instance
   */
  getWorker(name: string): AsyncWorker;
  /**
   * Retire a current Worker, terminating it immediately.
   * @see Worker#terminate
   * @param {string} name           The named worker to terminate
   */
  retireWorker(name: string): void;
}
type WorkerTask = {
  [x: string]: any;
};
/**
 * Supported worker task actions
 */
type WORKER_TASK_ACTIONS = string;
/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @type {function(typeof ClientDocument)}
 * @category - Mixins
 */
declare const CanvasDocumentMixin: (arg0: typeof ClientDocument) => any;
/**
 * The client-side database backend implementation which handles Document modification operations.
 * @extends {abstract.DatabaseBackend}
 * @implements {abstract.DatabaseBackend}
 */
declare class ClientDatabaseBackend implements abstract.DatabaseBackend {
  /**
   * Activate the Socket event listeners used to receive responses from events which modify database documents
   * @param {Socket} socket   The active game socket
   */
  activateSocketListeners(socket: Socket): void;
  /** @inheritdoc */
  _getDocuments(
    documentClass: any,
    {
      query,
      options,
      pack,
    }: {
      query: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<any>;
  /** @inheritdoc */
  _getEmbeddedDocuments(
    documentClass: any,
    parent: any,
    {
      query,
      options,
      pack,
    }: {
      query: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<void>;
  /** @inheritdoc */
  _createDocuments(
    documentClass: any,
    {
      data,
      options,
      pack,
    }: {
      data: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<any[]>;
  /** @inheritdoc */
  _createEmbeddedDocuments(
    documentClass: any,
    parent: any,
    {
      data,
      options,
      pack,
    }: {
      data: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<any>;
  /**
   * Perform a standardized pre-creation workflow for all Document types. For internal use only.
   * @private
   */
  private _preCreateDocumentArray;
  /**
   * Handle a SocketResponse from the server when one or multiple documents were created
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {object[]} [response.result]            An Array of created data objects
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                          An Array of created Document instances
   * @private
   */
  private _handleCreateDocuments;
  /**
   * Handle a SocketResponse from the server when one or multiple documents were created
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {object[]} [response.result]            An Array of created data objects
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                          An Array of created Document instances
   * @private
   */
  private _handleCreateEmbeddedDocuments;
  /**
   * Perform a standardized post-creation workflow for all Document types. For internal use only.
   * @returns {Function[]}   An array of callback operations to perform once every Document is created
   * @private
   */
  private _postCreateDocumentCallbacks;
  /** @inheritdoc */
  _updateDocuments(
    documentClass: any,
    {
      updates,
      options,
      pack,
    }: {
      updates: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<Document[]>;
  /** @inheritdoc */
  _updateEmbeddedDocuments(
    documentClass: any,
    parent: any,
    {
      updates,
      options,
      pack,
    }: {
      updates: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<any>;
  /**
   * Perform a standardized pre-update workflow for all Document types. For internal use only.
   * @private
   */
  private _preUpdateDocumentArray;
  /**
   * Handle a SocketResponse from the server when one or multiple documents were updated
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {object[]} [response.result]            An Array of incremental data objects
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                          An Array of updated Document instances
   * @private
   */
  private _handleUpdateDocuments;
  /**
   * Handle a SocketResponse from the server when embedded Documents are updated in a parent Document.
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {object[]} [response.result]            An Array of incremental data objects
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                          An Array of updated Document instances
   * @private
   */
  private _handleUpdateEmbeddedDocuments;
  /**
   * Perform a standardized post-update workflow for all Document types. For internal use only.
   * @returns {Function[]}   An array of callback operations to perform after every Document is updated
   * @private
   */
  private _postUpdateDocumentCallbacks;
  /** @inheritdoc */
  _deleteDocuments(
    documentClass: any,
    {
      ids,
      options,
      pack,
    }: {
      ids: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<Document[]>;
  /** @inheritdoc */
  _deleteEmbeddedDocuments(
    documentClass: any,
    parent: any,
    {
      ids,
      options,
      pack,
    }: {
      ids: any;
      options: any;
      pack: any;
    },
    user: any
  ): Promise<any>;
  /**
   * Perform a standardized pre-delete workflow for all Document types. For internal use only.
   * @private
   */
  private _preDeleteDocumentArray;
  /**
   * Handle a SocketResponse from the server where Documents are deleted.
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {string[]} [response.result]            An Array of deleted Document ids
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                           An Array of deleted Document instances
   * @private
   */
  private _handleDeleteDocuments;
  /**
   * Handle a SocketResponse from the server when embedded Documents are deleted from a parent Document.
   * @param {SocketResponse} response               The provided Socket response
   * @param {SocketRequest} [response.request]      The initial socket request
   * @param {string[]} [response.result]            An Array of deleted Document ids
   * @param {string} [response.userId]              The id of the requesting User
   * @returns {Document[]}                          An Array of deleted Document instances
   * @private
   */
  private _handleDeleteEmbeddedDocuments;
  /**
   * Perform a standardized post-deletion workflow for all Document types. For internal use only.
   * @returns {Function[]}   An array of callback operations to perform after every Document is deleted
   * @private
   */
  private _postDeleteDocumentCallbacks;
  /** @inheritdoc */
  getFlagScopes(): any[];
  /** @inheritdoc */
  getCompendiumScopes(): any[];
  #private;
}
/**
 * @typedef {abstract.Document} ClientDocument
 * @mixes {ClientDocumentMixin}
 */
/**
 * A mixin which extends each Document definition with specialized client-side behaviors.
 * This mixin defines the client-side interface for database operations and common document behaviors.
 * @type {function(Class)}
 * @category - Mixins
 * @mixin
 */
declare const ClientDocumentMixin: (arg0: Class) => any;
type ClientDocument = abstract.Document;
/**
 * An abstract subclass of the Collection container which defines a collection of Document instances.
 * @extends {Collection}
 * @abstract
 *
 * @param {object[]} data      An array of data objects from which to create document instances
 */
declare class DocumentCollection {
  /**
   * The base Document type which is contained within this DocumentCollection
   * @type {string}
   */
  static documentName: string;
  constructor(data?: any[]);
  /**
   * An Array of application references which will be automatically updated when the collection content changes
   * @type {Application[]}
   */
  apps: Application[];
  /**
   * Initialize the DocumentCollection by constructing any initially provided Document instances
   * @private
   */
  private _initialize;
  /**
   * A reference to the Document class definition which is contained within this DocumentCollection.
   * @type {Function}
   */
  get documentClass(): Function;
  /** @inheritdoc */
  get documentName(): any;
  /**
   * Record the set of document ids where the Document was not initialized because of invalid source data
   * @type {Set<string>}
   */
  invalidDocumentIds: Set<string>;
  /**
   * The Collection class name
   * @type {string}
   */
  get name(): string;
  /**
   * Obtain a temporary Document instance for a document id which currently has invalid source data.
   * @param {string} id         A document ID with invalid source data.
   * @returns {Document}        An in-memory instance for the invalid Document
   */
  getInvalid(id: string): Document;
  /** @inheritdoc */
  set(id: any, document: any): void;
  /** @inheritdoc */
  delete(id: any): void;
  /**
   * Render any Applications associated with this DocumentCollection.
   */
  render(force: any, options: any): void;
  /**
   * Update all objects in this DocumentCollection with a provided transformation.
   * Conditionally filter to only apply to Entities which match a certain condition.
   * @param {Function|object} transformation    An object of data or function to apply to all matched objects
   * @param {Function|null}  condition          A function which tests whether to target each object
   * @param {object} [options]                  Additional options passed to Document.update
   * @return {Promise<Document[]>}              An array of updated data once the operation is complete
   */
  updateAll(
    transformation: Function | object,
    condition?: Function | null,
    options?: object | undefined
  ): Promise<Document[]>;
  /**
   * Preliminary actions taken before a set of Documents in this Collection are created.
   * @param {object[]} result       An Array of created data objects
   * @param {object} options        Options which modified the creation operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _preCreateDocuments(
    result: object[],
    options: object,
    userId: string
  ): void;
  /**
   * Follow-up actions taken after a set of Documents in this Collection are created.
   * @param {Document[]} documents  An Array of created Documents
   * @param {object[]} result       An Array of created data objects
   * @param {object} options        Options which modified the creation operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _onCreateDocuments(
    documents: Document[],
    result: object[],
    options: object,
    userId: string
  ): void;
  /**
   * Preliminary actions taken before a set of Documents in this Collection are updated.
   * @param {object[]} result       An Array of incremental data objects
   * @param {object} options        Options which modified the update operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _preUpdateDocuments(
    result: object[],
    options: object,
    userId: string
  ): void;
  /**
   * Follow-up actions taken after a set of Documents in this Collection are updated.
   * @param {Document[]} documents  An Array of updated Documents
   * @param {object[]} result       An Array of incremental data objects
   * @param {object} options        Options which modified the update operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _onUpdateDocuments(
    documents: Document[],
    result: object[],
    options: object,
    userId: string
  ): void;
  /**
   * Preliminary actions taken before a set of Documents in this Collection are deleted.
   * @param {string[]} result       An Array of document IDs being deleted
   * @param {object} options        Options which modified the deletion operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _preDeleteDocuments(
    result: string[],
    options: object,
    userId: string
  ): void;
  /**
   * Follow-up actions taken after a set of Documents in this Collection are deleted.
   * @param {Document[]} documents  An Array of deleted Documents
   * @param {string[]} result       An Array of document IDs being deleted
   * @param {object} options        Options which modified the deletion operation
   * @param {string} userId         The ID of the User who triggered the operation
   * @protected
   */
  protected _onDeleteDocuments(
    documents: Document[],
    result: string[],
    options: object,
    userId: string
  ): void;
  /**
   * Generate the render context information provided for CRUD operations.
   * @param {string} action           The CRUD operation.
   * @param {Document[]} documents    The documents being operated on.
   * @param {object[]|string[]} data  An array of creation or update objects, or an array of document IDs, depending on
   *                                  the operation.
   * @returns {{action: string, documentType: string, documents: Document[], data: object[]|string[]}}
   * @private
   */
  private _getRenderContext;
}
/**
 * A collection of world-level Document objects with a singleton instance per primary Document type.
 * Each primary Document type has an associated subclass of WorldCollection which contains them.
 * @extends {DocumentCollection}
 * @abstract
 * @see {Game#collections}
 *
 * @param {object[]} data      An array of data objects from which to create Document instances
 */
declare class WorldCollection extends DocumentCollection {
  /**
   * Return a reference to the singleton instance of this WorldCollection, or null if it has not yet been created.
   * @type {WorldCollection}
   */
  static get instance(): WorldCollection;
  /**
   * Register a Document sheet class as a candidate which can be used to display Documents of a given type.
   * See {@link DocumentSheetConfig.registerSheet} for details.
   * @static
   * @param {Array<*>} args      Arguments forwarded to the DocumentSheetConfig.registerSheet method
   *
   * @example Register a new ActorSheet subclass for use with certain Actor types.
   * ```js
   * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character], makeDefault: true });
   * ```
   */
  static registerSheet(...args: Array<any>): void;
  /**
   * Unregister a Document sheet class, removing it from the list of available sheet Applications to use.
   * See {@link DocumentSheetConfig.unregisterSheet} for detauls.
   * @static
   * @param {Array<*>} args      Arguments forwarded to the DocumentSheetConfig.unregisterSheet method
   *
   * @example Deregister the default ActorSheet subclass to replace it with others.
   * ```js
   * Actors.unregisterSheet("core", ActorSheet);
   * ```
   */
  static unregisterSheet(...args: Array<any>): void;
  /**
   * Return an array of currently registered sheet classes for this Document type.
   * @static
   * @type {DocumentSheet[]}
   */
  static get registeredSheets(): DocumentSheet[];
  /**
   * Return a reference to the SidebarDirectory application for this WorldCollection.
   * @type {SidebarDirectory}
   */
  get directory(): SidebarDirectory;
  /**
   * Import a Document from a Compendium collection, adding it to the current World.
   * @param {CompendiumCollection} pack The CompendiumCollection instance from which to import
   * @param {string} id             The ID of the compendium entry to import
   * @param {object} [updateData]   Optional additional data used to modify the imported Document before it is created
   * @param {object} [options]      Optional arguments passed to the {@link WorldCollection#fromCompendium} and
   *                                {@link Document.create} methods
   * @returns {Promise<Document>}   The imported Document instance
   */
  importFromCompendium(
    pack: CompendiumCollection,
    id: string,
    updateData?: object | undefined,
    options?: object | undefined
  ): Promise<Document>;
  /**
   * Apply data transformations when importing a Document from a Compendium pack
   * @param {Document|object} document    The source Document, or a plain data object
   * @param {object} [options]            Additional options which modify how the document is imported
   * @param {boolean} [options.addFlags=false]        Add flags which track the import source
   * @param {boolean} [options.clearSort=true]        Clear the currently assigned folder and sort order
   * @param {boolean} [options.clearOwnership=true]   Clear document ownership
   * @param {boolean} [options.keepId=false]          Retain the Document id from the source Compendium
   * @returns {object}                    The processed data ready for world Document creation
   */
  fromCompendium(
    document: Document | object,
    {
      addFlags,
      clearSort,
      clearOwnership,
      keepId,
    }?:
      | {
          addFlags?: boolean | undefined;
          clearSort?: boolean | undefined;
          clearOwnership?: boolean | undefined;
          keepId?: boolean | undefined;
        }
      | undefined
  ): object;
}
/**
 * The singleton collection of Actor documents which exist within the active World.
 * This Collection is accessible within the Game object as game.actors.
 * @extends {WorldCollection}
 * @category - Collections
 *
 * @see {@link Actor} The Actor document
 * @see {@link ActorDirectory} The ActorDirectory sidebar directory
 *
 * @example Retrieve an existing Actor by its id
 * ```js
 * let actor = game.actors.get(actorId);
 * ```
 */
declare class Actors extends WorldCollection {
  /**
   * A mapping of synthetic Token Actors which are currently active within the viewed Scene.
   * Each Actor is referenced by the Token.id.
   * @type {Object<string, Actor>}
   */
  get tokens(): {
    [x: string]: Actor;
  };
  /** @inheritdoc */
  fromCompendium(document: any, options?: {}): object;
}
/**
 * The collection of Cards documents which exist within the active World.
 * This Collection is accessible within the Game object as game.cards.
 * @extends {WorldCollection}
 * @see {@link Cards} The Cards document
 */
declare class CardStacks extends WorldCollection {}
/**
 * The singleton collection of Combat documents which exist within the active World.
 * This Collection is accessible within the Game object as game.combats.
 * @extends {WorldCollection}
 *
 * @see {@link Combat} The Combat document
 * @see {@link CombatTracker} The CombatTracker sidebar directory
 */
declare class CombatEncounters extends WorldCollection {
  /**
   * Provide the settings object which configures the Combat document
   * @type {object}
   */
  static get settings(): object;
  /** @inheritdoc */
  get directory(): any;
  /**
   * Get an Array of Combat instances which apply to the current canvas scene
   * @type {Combat[]}
   */
  get combats(): Combat[];
  /**
   * The currently active Combat instance
   * @type {Combat}
   */
  get active(): Combat;
  /**
   * The currently viewed Combat encounter
   * @type {Combat|null}
   */
  get viewed(): Combat | null;
  /**
   * When a Token is deleted, remove it as a combatant from any combat encounters which included the Token
   * @param {string} sceneId      The Scene id within which a Token is being deleted
   * @param {string} tokenId      The Token id being deleted
   * @protected
   */
  protected _onDeleteToken(sceneId: string, tokenId: string): Promise<void>;
}
/**
 * A collection of Document objects contained within a specific compendium pack.
 * Each Compendium pack has its own associated instance of the CompendiumCollection class which contains its contents.
 * @extends {DocumentCollection}
 * @abstract
 * @see {Game#packs}
 *
 * @param {object} metadata   The compendium metadata, an object provided by game.data
 */
declare class CompendiumCollection extends DocumentCollection {
  /**
   * The amount of time that Document instances within this CompendiumCollection are held in memory.
   * Accessing the contents of the Compendium pack extends the duration of this lifetime.
   * @type {number}
   */
  static CACHE_LIFETIME_SECONDS: number;
  /**
   * The named game setting which contains Compendium configurations.
   * @type {string}
   */
  static CONFIG_SETTING: string;
  /**
   * Create a new Compendium Collection using provided metadata.
   * @param {object} metadata   The compendium metadata used to create the new pack
   * @param {object} options   Additional options which modify the Compendium creation request
   * @returns {Promise<CompendiumCollection>}
   */
  static createCompendium(
    metadata: object,
    options?: object
  ): Promise<CompendiumCollection>;
  constructor(metadata: any);
  /**
   * The compendium metadata which defines the compendium content and location
   * @type {object}
   */
  metadata: object;
  /**
   * A subsidiary collection which contains the more minimal index of the pack
   * @type {Collection<string, object>}
   */
  index: Collection<string, object>;
  /**
   * A debounced function which will clear the contents of the Compendium pack if it is not accessed frequently.
   * @type {Function}
   * @private
   */
  private _flush;
  /**
   * The canonical Compendium name - comprised of the originating package and the pack name
   * @type {string}
   */
  get collection(): string;
  /**
   * Access the compendium configuration data for this pack
   * @type {object}
   */
  get config(): object;
  /**
   * Track whether the Compendium Collection is locked for editing
   * @type {boolean}
   */
  get locked(): boolean;
  /**
   * Whether the compendium is currently open in the UI.
   * @type {boolean}
   */
  get isOpen(): boolean;
  /**
   * Track whether the Compendium Collection is private
   * @type {boolean}
   */
  get private(): boolean;
  /**
   * A convenience reference to the label which should be used as the title for the Compendium pack.
   * @type {string}
   */
  get title(): string;
  /**
   * The index fields which should be loaded for this compendium pack
   * @type {Set<string>}
   */
  get indexFields(): Set<string>;
  /**
   * Has this compendium pack been fully indexed?
   * @type {boolean}
   */
  get indexed(): boolean;
  /** @inheritdoc */
  get(key: any, options: any): any;
  /**
   * Load the Compendium index and cache it as the keys and values of the Collection.
   * @param {object} [options]    Options which customize how the index is created
   * @param {string[]} [options.fields]  An array of fields to return as part of the index
   * @returns {Promise<Collection>}
   */
  getIndex({
    fields,
  }?:
    | {
        fields?: string[] | undefined;
      }
    | undefined): Promise<Collection>;
  /**
   * Get a single Document from this Compendium by ID.
   * The document may already be locally cached, otherwise it is retrieved from the server.
   * @param {string} id               The requested Document id
   * @returns {Promise<Document>|undefined}     The retrieved Document instance
   */
  getDocument(id: string): Promise<Document> | undefined;
  /**
   * Load multiple documents from the Compendium pack using a provided query object.
   * @param {object} query            A database query used to retrieve documents from the underlying database
   * @returns {Promise<Document[]>}   The retrieved Document instances
   */
  getDocuments(query?: object): Promise<Document[]>;
  /**
   * Import a Document into this Compendium Collection.
   * @param {Document} document     The existing Document you wish to import
   * @param {object} [options]      Additional options which modify how the data is imported.
   *                                See {@link ClientDocumentMixin#toCompendium}
   * @returns {Promise<Document>}   The imported Document instance
   */
  importDocument(
    document: Document,
    options?: object | undefined
  ): Promise<Document>;
  /**
   * Fully import the contents of a Compendium pack into a World folder.
   * @param {object} [options={}]     Options which modify the import operation. Additional options are forwarded to
   *                                  {@link WorldCollection#fromCompendium} and {@link Document.createDocuments}
   * @param {string|null} [options.folderId]  An existing Folder _id to use.
   * @param {string} [options.folderName]     A new Folder name to create.
   * @returns {Promise<Document[]>}   The imported Documents, now existing within the World
   */
  importAll({
    folderId,
    folderName,
    ...options
  }?:
    | {
        folderId?: string | null | undefined;
        folderName?: string | undefined;
      }
    | undefined): Promise<Document[]>;
  /**
   * Provide a dialog form that prompts the user to import the full contents of a Compendium pack into the World.
   * @param {object} [options={}] Additional options passed to the Dialog.confirm method
   * @returns {Promise<Document[]|boolean|null>} A promise which resolves in the following ways: an array of imported
   *                            Documents if the "yes" button was pressed, false if the "no" button was pressed, or
   *                            null if the dialog was closed without making a choice.
   */
  importDialog(
    options?: object | undefined
  ): Promise<Document[] | boolean | null>;
  /**
   * Add a Document to the index, capturing its relevant index attributes
   * @param {Document} document       The document to index
   */
  indexDocument(document: Document): void;
  /**
   * Assign configuration metadata settings to the compendium pack
   * @param {object} settings   The object of compendium settings to define
   * @returns {Promise}         A Promise which resolves once the setting is updated
   */
  configure(settings?: object): Promise<any>;
  /**
   * Delete an existing world-level Compendium Collection.
   * This action may only be performed for world-level packs by a Gamemaster User.
   * @returns {Promise<CompendiumCollection>}
   */
  deleteCompendium(): Promise<CompendiumCollection>;
  /**
   * Duplicate a compendium pack to the current World.
   * @param {string} label    A new Compendium label
   * @returns {Promise<CompendiumCollection>}
   */
  duplicateCompendium({ label }?: string): Promise<CompendiumCollection>;
  /**
   * Validate that the current user is able to modify content of this Compendium pack
   * @returns {boolean}
   * @private
   */
  private _assertUserCanModify;
  /**
   * Migrate a compendium pack.
   * This operation re-saves all documents within the compendium pack to disk, applying the current data model.
   * If the document type has system data, the latest system data template will also be applied to all documents.
   * @returns {Promise<CompendiumCollection>}
   */
  migrate(): Promise<CompendiumCollection>;
  /** @inheritdoc */
  updateAll(
    transformation: any,
    condition?: null,
    options?: {}
  ): Promise<Document[]>;
  /** @inheritdoc */
  _onCreateDocuments(
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onUpdateDocuments(
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onDeleteDocuments(
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /**
   * Follow-up actions taken when Documents within this Compendium pack are modified
   * @private
   */
  private _onModifyContents;
  #private;
}
/**
 * The singleton collection of FogExploration documents which exist within the active World.
 * @extends {WorldCollection}
 * @see {@link FogExploration} The FogExploration document
 */
declare class FogExplorations extends WorldCollection {
  /** @inheritDoc */
  _onDeleteDocuments(
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
}
/**
 * The singleton collection of Folder documents which exist within the active World.
 * This Collection is accessible within the Game object as game.folders.
 * @extends {WorldCollection}
 *
 * @see {@link Folder} The Folder document
 */
declare class Folders extends WorldCollection {
  constructor(...args: any[]);
  /**
   * Track which Folders are currently expanded in the UI
   */
  _expanded: {};
  /**
   * Refresh the display of any active JournalSheet instances where the folder list will change.
   * @private
   */
  private _refreshJournalEntrySheets;
}
/**
 * The singleton collection of Item documents which exist within the active World.
 * This Collection is accessible within the Game object as game.items.
 * @extends {WorldCollection}
 *
 * @see {@link Item} The Item document
 * @see {@link ItemDirectory} The ItemDirectory sidebar directory
 */
declare class Items extends WorldCollection {}
/**
 * The singleton collection of JournalEntry documents which exist within the active World.
 * This Collection is accessible within the Game object as game.journal.
 * @extends {WorldCollection}
 *
 * @see {@link JournalEntry} The JournalEntry document
 * @see {@link JournalDirectory} The JournalDirectory sidebar directory
 */
declare class Journal extends WorldCollection {
  /**
   * Display a dialog which prompts the user to show a JournalEntry or JournalEntryPage to other players.
   * @param {JournalEntry|JournalEntryPage} doc  The JournalEntry or JournalEntryPage to show.
   * @returns {Promise<JournalEntry|JournalEntryPage|void>}
   */
  static showDialog(
    doc: JournalEntry | JournalEntryPage
  ): Promise<JournalEntry | JournalEntryPage | void>;
  /**
   * Show the JournalEntry or JournalEntryPage to connected players.
   * By default, the document will only be shown to players who have permission to observe it.
   * If the force parameter is passed, the document will be shown to all players regardless of normal permission.
   * @param {JournalEntry|JournalEntryPage} doc  The JournalEntry or JournalEntryPage to show.
   * @param {object} [options]                   Additional options to configure behaviour.
   * @param {boolean} [options.force=false]      Display the entry to all players regardless of normal permissions.
   * @param {string[]} [options.users]           An optional list of user IDs to show the document to. Otherwise it will
   *                                             be shown to all connected clients.
   * @returns {Promise<JournalEntry|JournalEntryPage>}  A Promise that resolves back to the shown document once the
   *                                                    request is processed.
   * @throws If the user does not own the document they are trying to show.
   */
  static show(
    doc: JournalEntry | JournalEntryPage,
    {
      force,
      users,
    }?:
      | {
          force?: boolean | undefined;
          users?: string[] | undefined;
        }
      | undefined
  ): Promise<JournalEntry | JournalEntryPage>;
  /**
   * Share an image with connected players.
   * @param {string} src                 The image URL to share.
   * @param {ShareImageConfig} [config]  Image sharing configuration.
   */
  static showImage(
    src: string,
    {
      users,
      ...options
    }?:
      | {
          /**
           * The image URL to share.
           */
          image: string;
          /**
           * The image title.
           */
          title: string;
          /**
           * The UUID of a Document related to the image, used to determine permission to see
           *         the image title.
           */
          uuid?: string | undefined;
          /**
           * If this is provided, the permissions of the related Document will be ignored and
           *   the title will be shown based on this parameter.
           */
          showTitle?: boolean | undefined;
          /**
           * A list of user IDs to show the image to.
           */
          users?: string[] | undefined;
        }
      | undefined
  ): void;
  /**
   * Open Socket listeners which transact JournalEntry data
   * @param {Socket} socket       The open websocket
   */
  static _activateSocketListeners(socket: Socket): void;
  /**
   * Handle a received request to show a JournalEntry or JournalEntryPage to the current client
   * @param {string} uuid            The UUID of the document to display for other players
   * @param {boolean} [force=false]  Display the document regardless of normal permissions
   * @internal
   */
  static _showEntry(uuid: string, force?: boolean | undefined): Promise<void>;
}
/**
 * The singleton collection of Macro documents which exist within the active World.
 * This Collection is accessible within the Game object as game.macros.
 * @extends {WorldCollection}
 *
 * @see {@link Macro} The Macro document
 * @see {@link MacroDirectory} The MacroDirectory sidebar directory
 */
declare class Macros extends WorldCollection {
  /** @override */
  override get directory(): any;
  /** @inheritdoc */
  fromCompendium(document: any, options?: {}): object;
}
/**
 * The singleton collection of ChatMessage documents which exist within the active World.
 * This Collection is accessible within the Game object as game.messages.
 * @extends {WorldCollection}
 *
 * @see {@link ChatMessage} The ChatMessage document
 * @see {@link ChatLog} The ChatLog sidebar directory
 */
declare class Messages extends WorldCollection {
  /**
   * @override
   * @returns {SidebarTab}
   * */
  override get directory(): SidebarTab;
  /** @override */
  override render(force?: boolean): void;
  /**
   * If requested, dispatch a Chat Bubble UI for the newly created message
   * @param {ChatMessage} message     The ChatMessage document to say
   * @private
   */
  private sayBubble;
  /**
   * Handle export of the chat log to a text file
   * @private
   */
  private export;
  /**
   * Allow for bulk deletion of all chat messages, confirm first with a yes/no dialog.
   * @see {@link Dialog.confirm}
   */
  flush(): Promise<any>;
}
/**
 * The singleton collection of Playlist documents which exist within the active World.
 * This Collection is accessible within the Game object as game.playlists.
 * @extends {WorldCollection}
 *
 * @see {@link Playlist} The Playlist document
 * @see {@link PlaylistDirectory} The PlaylistDirectory sidebar directory
 */
declare class Playlists extends WorldCollection {
  constructor(...args: any[]);
  /**
   * Return the subset of Playlist documents which are currently playing
   * @type {Playlist[]}
   */
  get playing(): Playlist[];
  /**
   * Perform one-time initialization to begin playback of audio
   */
  initialize(): void;
  /**
   * Handle changes to a Scene to determine whether to trigger changes to Playlist documents.
   * @param {Scene} scene       The Scene document being updated
   * @param {Object} data       The incremental update data
   */
  _onChangeScene(scene: Scene, data: Object): Promise<void>;
}
/**
 * The singleton collection of Scene documents which exist within the active World.
 * This Collection is accessible within the Game object as game.scenes.
 * @extends {WorldCollection}
 *
 * @see {@link Scene} The Scene document
 * @see {@link SceneDirectory} The SceneDirectory sidebar directory
 */
declare class Scenes extends WorldCollection {
  /** @override */
  static override _activateSocketListeners(socket: any): void;
  /**
   * Handle requests pulling the current User to a specific Scene
   * @param {string} sceneId
   * @private
   */
  private static _pullToScene;
  /**
   * Return a reference to the Scene which is currently active
   * @type {Scene}
   */
  get active(): Scene;
  /**
   * Return the current Scene target.
   * This is the viewed scene if the canvas is active, otherwise it is the currently active scene.
   * @type {Scene}
   */
  get current(): Scene;
  /**
   * Return a reference to the Scene which is currently viewed
   * @type {Scene}
   */
  get viewed(): Scene;
  /**
   * Handle preloading the art assets for a Scene
   * @param {string} sceneId    The Scene id to begin loading
   * @param {boolean} push      Trigger other connected clients to also preload Scene resources
   */
  preload(sceneId: string, push?: boolean): Promise<any>;
  /** @inheritdoc */
  fromCompendium(document: any, options?: {}): object;
}
/**
 * The Collection of Setting documents which exist within the active World.
 * This collection is accessible as game.settings.storage.get("world")
 * @extends {WorldCollection}
 *
 * @see {@link Setting} The Setting document
 */
declare class WorldSettings extends WorldCollection {
  /** @override */
  override get directory(): null;
  /**
   * Return the Setting document with the given key.
   * @param {string} key        The setting key
   * @returns {Setting}         The Setting
   */
  getSetting(key: string): Setting;
  /**
   * Return the serialized value of the world setting as a string
   * @param {string} key    The setting key
   * @returns {string|null}  The serialized setting string
   */
  getItem(key: string): string | null;
}
/**
 * The singleton collection of RollTable documents which exist within the active World.
 * This Collection is accessible within the Game object as game.tables.
 * @extends {WorldCollection}
 *
 * @see {@link RollTable} The RollTable document
 * @see {@link RollTableDirectory} The RollTableDirectory sidebar directory
 */
declare class RollTables extends WorldCollection {
  /**
   * Register world settings related to RollTable documents
   */
  static registerSettings(): void;
  /** @override */
  override get directory(): any;
}
/**
 * The singleton collection of User documents which exist within the active World.
 * This Collection is accessible within the Game object as game.users.
 * @extends {WorldCollection}
 *
 * @see {@link User} The User document
 */
declare class Users extends WorldCollection {
  static _activateSocketListeners(socket: any): void;
  /**
   * Handle receipt of activity data from another User connected to the Game session
   * @param {string} userId               The User id who generated the activity data
   * @param {ActivityData} activityData   The object of activity data
   * @private
   */
  private static _handleUserActivity;
  constructor(...args: any[]);
  /**
   * The User document of the currently connected user
   * @type {User|null}
   */
  current: User | null;
  /**
   * Get the users with player roles
   * @returns {User[]}
   */
  get players(): User[];
}
/**
 * The client-side ActiveEffect document which extends the common BaseActiveEffect model.
 * Each ActiveEffect belongs to the effects collection of its parent Document.
 * Each ActiveEffect contains a ActiveEffectData object which provides its source data.
 *
 * @extends documents.BaseActiveEffect
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Actor}                     The Actor document which contains ActiveEffect embedded documents
 * @see {@link documents.Item}                      The Item document which contains ActiveEffect embedded documents
 */
declare class ActiveEffect {
  /**
   * A cached reference to the source name to avoid recurring database lookups
   * @type {string|null}
   */
  _sourceName: string | null;
  /**
   * Does this ActiveEffect correspond to a significant status effect ID?
   * @type {string|null}
   * @private
   */
  private _statusId;
  /**
   * Is there some system logic that makes this active effect ineligible for application?
   * @type {boolean}
   */
  get isSuppressed(): boolean;
  /**
   * Does this Active Effect currently modify an Actor?
   * @type {boolean}
   */
  get modifiesActor(): boolean;
  /** @inheritdoc */
  prepareDerivedData(): void;
  /**
   * Prepare derived data related to active effect duration
   * @internal
   */
  _prepareDuration(): any;
  /**
   * Format a round+turn combination as a decimal
   * @param {number} round    The round number
   * @param {number} turn     The turn number
   * @param {number} [nTurns] The maximum number of turns in the encounter
   * @returns {number}        The decimal representation
   * @private
   */
  private _getCombatTime;
  /**
   * Format a number of rounds and turns into a human-readable duration label
   * @param {number} rounds   The number of rounds
   * @param {number} turns    The number of turns
   * @returns {string}        The formatted label
   * @private
   */
  private _getDurationLabel;
  /**
   * Describe whether the ActiveEffect has a temporary duration based on combat turns or rounds.
   * @type {boolean}
   */
  get isTemporary(): boolean;
  /**
   * A cached property for obtaining the source name
   * @type {string}
   */
  get sourceName(): string;
  /**
   * Apply this ActiveEffect to a provided Actor.
   * TODO: This method is poorly conceived. Its functionality is static, applying a provided change to an Actor
   * TODO: When we revisit this in Active Effects V2 this should become an Actor method, or a static method
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @returns {*}                           The resulting applied value
   */
  apply(actor: Actor, change: EffectChangeData): any;
  /**
   * Cast a raw EffectChangeData change string to the desired data type.
   * @param {string} raw      The raw string value
   * @param {string} type     The target data type that the raw value should be cast to match
   * @returns {*}             The parsed delta cast to the target data type
   * @private
   */
  private _castDelta;
  /**
   * Cast a raw EffectChangeData change string to an Array of an inner type.
   * @param {string} raw      The raw string value
   * @param {string} type     The target data type of inner array elements
   * @returns {Array<*>}      The parsed delta cast as a typed array
   * @private
   */
  private _castArray;
  /**
   * Parse serialized JSON, or retain the raw string.
   * @param {string} raw      A raw serialized string
   * @returns {*}             The parsed value, or the original value if parsing failed
   * @private
   */
  private _parseOrString;
  /**
   * Apply an ActiveEffect that uses an ADD application mode.
   * The way that effects are added depends on the data type of the current value.
   *
   * If the current value is null, the change value is assigned directly.
   * If the current type is a string, the change value is concatenated.
   * If the current type is a number, the change value is cast to numeric and added.
   * If the current type is an array, the change value is appended to the existing array if it matches in type.
   *
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @param {*} current                     The current value being modified
   * @param {*} delta                       The parsed value of the change object
   * @param {object} changes                An object which accumulates changes to be applied
   * @private
   */
  private _applyAdd;
  /**
   * Apply an ActiveEffect that uses a MULTIPLY application mode.
   * Changes which MULTIPLY must be numeric to allow for multiplication.
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @param {*} current                     The current value being modified
   * @param {*} delta                       The parsed value of the change object
   * @param {object} changes                An object which accumulates changes to be applied
   * @private
   */
  private _applyMultiply;
  /**
   * Apply an ActiveEffect that uses an OVERRIDE application mode.
   * Numeric data is overridden by numbers, while other data types are overridden by any value
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @param {*} current                     The current value being modified
   * @param {*} delta                       The parsed value of the change object
   * @param {object} changes                An object which accumulates changes to be applied
   * @private
   */
  private _applyOverride;
  /**
   * Apply an ActiveEffect that uses an UPGRADE, or DOWNGRADE application mode.
   * Changes which UPGRADE or DOWNGRADE must be numeric to allow for comparison.
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @param {*} current                     The current value being modified
   * @param {*} delta                       The parsed value of the change object
   * @param {object} changes                An object which accumulates changes to be applied
   * @private
   */
  private _applyUpgrade;
  /**
   * Apply an ActiveEffect that uses a CUSTOM application mode.
   * @param {Actor} actor                   The Actor to whom this effect should be applied
   * @param {EffectChangeData} change       The change data being applied
   * @param {*} current                     The current value being modified
   * @param {*} delta                       The parsed value of the change object
   * @param {object} changes                An object which accumulates changes to be applied
   * @private
   */
  private _applyCustom;
  /**
   * Get the name of the source of the Active Effect
   * @type {string}
   */
  _getSourceName(): Promise<any>;
  /** @inheritdoc */
  _preCreate(data: any, options: any, user: any): Promise<void>;
  /** @inheritdoc */
  _onCreate(data: any, options: any, userId: any): void;
  /** @inheritdoc */
  _onUpdate(data: any, options: any, userId: any): void;
  /** @inheritdoc */
  _onDelete(options: any, userId: any): void;
  /**
   * Display changes to active effects as scrolling Token status text.
   * @param {boolean} enabled     Is the active effect currently enabled?
   * @private
   */
  private _displayScrollingStatus;
  #private;
}
/**
 * The client-side Actor document which extends the common BaseActor model.
 *
 * @extends foundry.documents.BaseActor
 * @mixes ClientDocumentMixin
 * @category - Documents
 *
 * @see {@link documents.Actors}            The world-level collection of Actor documents
 * @see {@link applications.ActorSheet}     The Actor configuration application
 *
 * @example Create a new Actor
 * ```js
 * let actor = await Actor.create({
 *   name: "New Test Actor",
 *   type: "character",
 *   img: "artwork/character-profile.jpg"
 * });
 * ```
 *
 * @example Retrieve an existing Actor
 * ```js
 * let actor = game.actors.get(actorId);
 * ```
 */
declare class Actor {
  /**
   * Request wildcard token images from the server and return them.
   * @param {string} actorId         The actor whose prototype token contains the wildcard image path.
   * @param {object} [options]
   * @param {string} [options.pack]  The name of the compendium the actor is in.
   * @returns {Promise<string[]>}    The list of filenames to token images that match the wildcard search.
   * @private
   */
  private static _requestTokenImages;
  /**
   * An object that tracks which tracks the changes to the data model which were applied by active effects
   * @type {object}
   */
  overrides: object;
  /**
   * A cached array of image paths which can be used for this Actor's token.
   * Null if the list has not yet been populated.
   * @type {string[]|null}
   * @private
   */
  private _tokenImages;
  /**
   * Cache the last drawn wildcard token to avoid repeat draws
   * @type {string|null}
   */
  _lastWildcard: string | null;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * Provide an object which organizes all embedded Item instances by their type
   * @type {Object<Item[]>}
   */
  get itemTypes(): any;
  /**
   * Test whether an Actor document is a synthetic representation of a Token (if true) or a full Document (if false)
   * @type {boolean}
   */
  get isToken(): boolean;
  /**
   * An array of ActiveEffect instances which are present on the Actor which have a limited duration.
   * @type {ActiveEffect[]}
   */
  get temporaryEffects(): ActiveEffect[];
  /**
   * Return a reference to the TokenDocument which owns this Actor as a synthetic override
   * @type {TokenDocument|null}
   */
  get token(): TokenDocument | null;
  /** @inheritdoc */
  get uuid(): any;
  /**
   * Apply any transformations to the Actor data which are caused by ActiveEffects.
   */
  applyActiveEffects(): void;
  /**
   * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
   * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
   * If the Actor is a synthetic token actor, only the exact Token which it represents will be returned.
   *
   * @param {boolean} [linked=false]    Limit results to Tokens which are linked to the Actor. Otherwise, return all
   *                                    Tokens even those which are not linked.
   * @param {boolean} [document=false]  Return the Document instance rather than the PlaceableObject
   * @returns {Token[]}                 An array of Token instances in the current Scene which reference this Actor.
   */
  getActiveTokens(
    linked?: boolean | undefined,
    document?: boolean | undefined
  ): Function[];
  /**
   * Prepare a data object which defines the data schema used by dice roll commands against this Actor
   * @returns {object}
   */
  getRollData(): object;
  /**
   * Create a new Token document, not yet saved to the database, which represents the Actor.
   * @param {object} [data={}]            Additional data, such as x, y, rotation, etc. for the created token data
   * @returns {Promise<TokenDocument>}    The created TokenDocument instance
   */
  getTokenDocument(data?: object | undefined): Promise<TokenDocument>;
  /**
   * Get an Array of Token images which could represent this Actor
   * @returns {Promise<string[]>}
   */
  getTokenImages(): Promise<string[]>;
  /**
   * Handle how changes to a Token attribute bar are applied to the Actor.
   * This allows for game systems to override this behavior and deploy special logic.
   * @param {string} attribute    The attribute path
   * @param {number} value        The target attribute value
   * @param {boolean} isDelta     Whether the number represents a relative change (true) or an absolute change (false)
   * @param {boolean} isBar       Whether the new value is part of an attribute bar, or just a direct value
   * @returns {Promise<documents.Actor>}  The updated Actor document
   */
  modifyTokenAttribute(
    attribute: string,
    value: number,
    isDelta?: boolean,
    isBar?: boolean
  ): Promise<documents.Actor>;
  /** @inheritdoc */
  prepareEmbeddedDocuments(): void;
  /**
   * Roll initiative for all Combatants in the currently active Combat encounter which are associated with this Actor.
   * If viewing a full Actor document, all Tokens which map to that actor will be targeted for initiative rolls.
   * If viewing a synthetic Token actor, only that particular Token will be targeted for an initiative roll.
   *
   * @param {object} options                          Configuration for how initiative for this Actor is rolled.
   * @param {boolean} [options.createCombatants=false]    Create new Combatant entries for Tokens associated with
   *                                                      this actor.
   * @param {boolean} [options.rerollInitiative=false]    Re-roll the initiative for this Actor if it has already
   *                                                      been rolled.
   * @param {object} [options.initiativeOptions={}]       Additional options passed to the Combat#rollInitiative method.
   * @returns {Promise<documents.Combat|null>}        A promise which resolves to the Combat document once rolls
   *                                                  are complete.
   */
  rollInitiative({
    createCombatants,
    rerollInitiative,
    initiativeOptions,
  }?: {
    createCombatants?: boolean | undefined;
    rerollInitiative?: boolean | undefined;
    initiativeOptions?: object | undefined;
  }): Promise<documents.Combat | null>;
  /** @inheritdoc */
  _preCreate(data: any, options: any, userId: any): Promise<void>;
  /**
   * When an Actor is being created, apply default token configuration settings to its prototype token.
   * @param {object} data         Data explicitly provided to the creation workflow
   * @param {object} options      Options which configure creation
   * @param {boolean} [options.fromCompendium]  Does this creation workflow originate via compendium import?
   * @protected
   */
  protected _applyDefaultTokenSettings(
    data: object,
    {
      fromCompendium,
    }?: {
      fromCompendium?: boolean | undefined;
    }
  ): any;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
  /** @inheritdoc */
  _onCreateEmbeddedDocuments(embeddedName: any, ...args: any[]): void;
  /** @inheritdoc */
  _onUpdateEmbeddedDocuments(embeddedName: any, ...args: any[]): void;
  /** @inheritdoc */
  _onDeleteEmbeddedDocuments(embeddedName: any, ...args: any[]): void;
  /**
   * Perform various actions on active tokens if embedded documents were changed.
   * @param {string} embeddedName  The type of embedded document that was modified.
   * @private
   */
  private _onEmbeddedDocumentChange;
  /**
   * @deprecated since v10
   * @ignore
   */
  getTokenData(data: any): Promise<TokenDocument>;
}
/**
 * The client-side Adventure document which extends the common {@link foundry.documents.BaseAdventure} model.
 * @extends documents.BaseAdventure
 * @mixes ClientDocumentMixin
 */
declare class Adventure {}
/**
 * The client-side AmbientLight document which extends the common BaseAmbientLight document model.
 * @extends documents.BaseAmbientLight
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains AmbientLight documents
 * @see {@link AmbientLightConfig}        The AmbientLight configuration application
 */
declare class AmbientLightDocument {
  /** @inheritdoc */
  _onUpdate(data: any, options: any, userId: any): any;
  /**
   * Is this ambient light source global in nature?
   * @type {boolean}
   */
  get isGlobal(): boolean;
}
/**
 * The client-side AmbientSound document which extends the common BaseAmbientSound document model.
 * @extends abstract.BaseAmbientSound
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                   The Scene document type which contains AmbientSound documents
 * @see {@link AmbientSoundConfig}      The AmbientSound configuration application
 */
declare class AmbientSoundDocument {}
/**
 * The client-side Card document which extends the common BaseCard document model.
 * @extends documents.BaseCard
 * @mixes ClientDocumentMixin
 *
 * @see {@link Cards}                    The Cards document type which contains Card embedded documents
 * @see {@link CardConfig}               The Card configuration application
 */
declare class Card {
  /**
   * The current card face
   * @type {CardFaceData|null}
   */
  get currentFace(): any;
  /**
   * The image of the currently displayed card face or back
   * @type {string}
   */
  get img(): string;
  /**
   * A reference to the source Cards document which defines this Card.
   * @type {Cards|null}
   */
  get source(): Cards | null;
  /**
   * A convenience property for whether the Card is within its source Cards stack. Cards in decks are always
   * considered home.
   * @type {boolean}
   */
  get isHome(): boolean;
  /**
   * Whether to display the face of this card?
   * @type {boolean}
   */
  get showFace(): boolean;
  /**
   * Does this Card have a next face available to flip to?
   * @type {boolean}
   */
  get hasNextFace(): boolean;
  /**
   * Does this Card have a previous face available to flip to?
   * @type {boolean}
   */
  get hasPreviousFace(): boolean;
  /** @override */
  override prepareDerivedData(): void;
  name: any;
  /**
   * Flip this card to some other face. A specific face may be requested, otherwise:
   * If the card currently displays a face the card is flipped to the back.
   * If the card currently displays the back it is flipped to the first face.
   * @param {number|null} [face]      A specific face to flip the card to
   * @returns {Promise<Card>}         A reference to this card after the flip operation is complete
   */
  flip(face?: number | null | undefined): Promise<Card>;
  /**
   * Pass this Card to some other Cards document.
   * @param {Cards} to                A new Cards document this card should be passed to
   * @param {object} [options={}]     Options which modify the pass operation
   * @param {object} [options.updateData={}]  Modifications to make to the Card as part of the pass operation,
   *                                  for example the displayed face
   * @returns {Promise<Card>}         A reference to this card after it has been passed to another parent document
   */
  pass(
    to: Cards,
    {
      updateData,
      ...options
    }?:
      | {
          updateData?: object | undefined;
        }
      | undefined
  ): Promise<Card>;
  /**
   * @alias Card#pass
   * @see Card#pass
   * @inheritdoc
   */
  play(
    to: any,
    {
      updateData,
      ...options
    }?: {
      updateData?: {} | undefined;
    }
  ): Promise<any>;
  /**
   * @alias Card#pass
   * @see Card#pass
   * @inheritdoc
   */
  discard(
    to: any,
    {
      updateData,
      ...options
    }?: {
      updateData?: {} | undefined;
    }
  ): Promise<any>;
  /**
   * Recall this Card to its original Cards parent.
   * @param {object} [options={}]   Options which modify the recall operation
   * @returns {Promise<Card>}       A reference to the recalled card belonging to its original parent
   */
  recall(options?: object | undefined): Promise<Card>;
  /**
   * Create a chat message which displays this Card.
   * @param {object} [messageData={}] Additional data which becomes part of the created ChatMessageData
   * @param {object} [options={}]     Options which modify the message creation operation
   * @returns {Promise<ChatMessage>}  The created chat message
   */
  toMessage(
    messageData?: object | undefined,
    options?: object | undefined
  ): Promise<ChatMessage>;
}
/**
 * The client-side Cards document which extends the common BaseCards model.
 * Each Cards document contains CardsData which defines its data schema.
 * @extends documents.BaseCards
 * @mixes ClientDocumentMixin
 *
 * @see {@link CardStacks}                        The world-level collection of Cards documents
 * @see {@link CardsConfig}                       The Cards configuration application
 */
declare class Cards {
  /** @inheritdoc */
  static createDocuments(data?: any[], context?: {}): Promise<any>;
  /** @override */
  static override createDialog(
    data?: {},
    {
      parent,
      pack,
      ...options
    }?: {
      parent?: null | undefined;
      pack?: null | undefined;
    }
  ): Promise<any>;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * The Card documents within this stack which are available to be drawn.
   * @type {Card[]}
   */
  get availableCards(): Card[];
  /**
   * The Card documents which belong to this stack but have already been drawn.
   * @type {Card[]}
   */
  get drawnCards(): Card[];
  /**
   * Returns the localized Label for the type of Card Stack this is
   * @type {string}
   */
  get typeLabel(): string;
  /**
   * Can this Cards document be cloned in a duplicate workflow?
   * @type {boolean}
   */
  get canClone(): boolean;
  /** @inheritDoc */
  _preCreate(data: any, options: any, user: any): Promise<void>;
  /**
   * Deal one or more cards from this Cards document to each of a provided array of Cards destinations.
   * Cards are allocated from the top of the deck in cyclical order until the required number of Cards have been dealt.
   * @param {Cards[]} to              An array of other Cards documents to which cards are dealt
   * @param {number} [number=1]       The number of cards to deal to each other document
   * @param {object} [options={}]     Options which modify how the deal operation is performed
   * @param {number} [options.how=0]          How to draw, a value from CONST.CARD_DRAW_MODES
   * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the deal operation,
   *                                          for example the displayed face
   * @param {string} [options.action=deal]    The name of the action being performed, used as part of the dispatched
   *                                          Hook event
   * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Cards>}        This Cards document after the deal operation has completed
   */
  deal(
    to: Cards[],
    number?: number | undefined,
    {
      action,
      how,
      updateData,
      chatNotification,
    }?:
      | {
          how?: number | undefined;
          updateData?: object | undefined;
          action?: string | undefined;
          chatNotification?: boolean | undefined;
        }
      | undefined
  ): Promise<Cards>;
  /**
   * Pass an array of specific Card documents from this document to some other Cards stack.
   * @param {Cards} to                Some other Cards document that is the destination for the pass operation
   * @param {string[]} ids            The embedded Card ids which should be passed
   * @param {object} [options={}]     Additional options which modify the pass operation
   * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the pass operation,
   *                                          for example the displayed face
   * @param {string} [options.action=pass]    The name of the action being performed, used as part of the dispatched
   *                                          Hook event
   * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Card[]>}       An array of the Card embedded documents created within the destination stack
   */
  pass(
    to: Cards,
    ids: string[],
    {
      updateData,
      action,
      chatNotification,
    }?:
      | {
          updateData?: object | undefined;
          action?: string | undefined;
          chatNotification?: boolean | undefined;
        }
      | undefined
  ): Promise<Card[]>;
  /**
   * Draw one or more cards from some other Cards document.
   * @param {Cards} from              Some other Cards document from which to draw
   * @param {number} [number=1]       The number of cards to draw
   * @param {object} [options={}]     Options which modify how the draw operation is performed
   * @param {number} [options.how=0]          How to draw, a value from CONST.CARD_DRAW_MODES
   * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the draw operation,
   *                                          for example the displayed face
   * @returns {Promise<Card[]>}       An array of the Card documents which were drawn
   */
  draw(
    from: Cards,
    number?: number | undefined,
    {
      how,
      updateData,
      ...options
    }?:
      | {
          how?: number | undefined;
          updateData?: object | undefined;
        }
      | undefined
  ): Promise<Card[]>;
  /**
   * Shuffle this Cards stack, randomizing the sort order of all the cards it contains.
   * @param {object} [options={}]     Options which modify how the shuffle operation is performed.
   * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the shuffle operation,
   *                                          for example the displayed face.
   * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Cards>}        The Cards document after the shuffle operation has completed
   */
  shuffle({
    updateData,
    chatNotification,
  }?:
    | {
        updateData?: object | undefined;
        chatNotification?: boolean | undefined;
      }
    | undefined): Promise<Cards>;
  /**
   * Recall the Cards stack, retrieving all original cards from other stacks where they may have been drawn if this is a
   * deck, otherwise returning all the cards in this stack to the decks where they originated.
   * @param {object} [options={}]             Options which modify the recall operation
   * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the recall operation,
   *                                          for example the displayed face
   * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Cards>}                The Cards document after the recall operation has completed.
   */
  recall(
    options?:
      | {
          updateData?: object | undefined;
          chatNotification?: boolean | undefined;
        }
      | undefined
  ): Promise<Cards>;
  /**
   * Perform a reset operation for a deck, retrieving all original cards from other stacks where they may have been
   * drawn.
   * @param {object} [options={}]              Options which modify the reset operation.
   * @param {object} [options.updateData={}]           Modifications to make to each Card as part of the reset operation
   * @param {boolean} [options.chatNotification=true]  Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Cards>}                 The Cards document after the reset operation has completed.
   * @private
   */
  private _resetDeck;
  /**
   * Return all cards in this stack to their original decks.
   * @param {object} [options={}]              Options which modify the return operation.
   * @param {object} [options.updateData={}]          Modifications to make to each Card as part of the return operation
   * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
   * @returns {Promise<Cards>}                 The Cards document after the return operation has completed.
   * @private
   */
  private _resetStack;
  /**
   * A sorting function that is used to determine the standard order of Card documents within an un-shuffled stack.
   * @param {Card} a     The card being sorted
   * @param {Card} b     Another card being sorted against
   * @returns {number}
   * @protected
   */
  protected sortStandard(a: Card, b: Card): number;
  /**
   * A sorting function that is used to determine the order of Card documents within a shuffled stack.
   * @param {Card} a     The card being sorted
   * @param {Card} b     Another card being sorted against
   * @returns {number}
   * @protected
   */
  protected sortShuffled(a: Card, b: Card): number;
  /**
   * An internal helper method for drawing a certain number of Card documents from this Cards stack.
   * @param {number} number       The number of cards to draw
   * @param {number} how          A draw mode from CONST.CARD_DRAW_MODES
   * @returns {Card[]}            An array of drawn Card documents
   * @protected
   */
  protected _drawCards(number: number, how: number): Card[];
  /**
   * Create a ChatMessage which provides a notification of the operation which was just performed.
   * Visibility of the resulting message is linked to the default roll mode selected in the chat log dropdown.
   * @param {Cards} source        The source Cards document from which the action originated
   * @param {string} action       The localization key which formats the chat message notification
   * @param {object} context      Data passed to the Localization#format method for the localization key
   * @returns {ChatMessage}       A created ChatMessage document
   * @private
   */
  private _postChatNotification;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
  _sheet: any;
  /** @inheritdoc */
  _preDelete(options: any, user: any): Promise<any>;
  /**
   * Display a dialog which prompts the user to deal cards to some number of hand-type Cards documents.
   * @see {@link Cards#deal}
   * @returns {Promise<Cards|null>}
   */
  dealDialog(): Promise<Cards | null>;
  /**
   * Display a dialog which prompts the user to draw cards from some other deck-type Cards documents.
   * @see {@link Cards#draw}
   * @returns {Promise<Card[]|null>}
   */
  drawDialog(): Promise<Card[] | null>;
  /**
   * Display a dialog which prompts the user to pass cards from this document to some other Cards document.
   * @see {@link Cards#deal}
   * @returns {Promise<Cards|null>}
   */
  passDialog(): Promise<Cards | null>;
  /**
   * Display a dialog which prompts the user to play a specific Card to some other Cards document
   * @see {@link Cards#pass}
   * @param {Card} card     The specific card being played as part of this dialog
   * @returns {Promise<Card[]|null>}
   */
  playDialog(card: Card): Promise<Card[] | null>;
  /**
   * Display a confirmation dialog for whether or not the user wishes to reset a Cards stack
   * @see {@link Cards#recall}
   * @returns {Promise<Cards|false|null>}
   */
  resetDialog(): Promise<Cards | false | null>;
  /** @inheritdoc */
  deleteDialog(options?: {}): Promise<any>;
}
/**
 * The client-side ChatMessage document which extends the common BaseChatMessage model.
 *
 * @extends documents.BaseChatMessage
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Messages}                The world-level collection of ChatMessage documents
 */
declare class ChatMessage {
  /**
   * Transform a provided object of ChatMessage data by applying a certain rollMode to the data object.
   * @param {object} chatData     The object of ChatMessage data prior to applying a rollMode preference
   * @param {string} rollMode     The rollMode preference to apply to this message data
   * @returns {object}            The modified ChatMessage data with rollMode preferences applied
   */
  static applyRollMode(chatData: object, rollMode: string): object;
  /**
   * Attempt to determine who is the speaking character (and token) for a certain Chat Message
   * First assume that the currently controlled Token is the speaker
   *
   * @param {object} [options={}]   Options which affect speaker identification
   * @param {Scene} [options.scene]         The Scene in which the speaker resides
   * @param {Actor} [options.actor]         The Actor who is speaking
   * @param {TokenDocument} [options.token] The Token who is speaking
   * @param {string} [options.alias]        The name of the speaker to display
   *
   * @returns {object}              The identified speaker data
   */
  static getSpeaker({
    scene,
    actor,
    token,
    alias,
  }?:
    | {
        scene?: Scene | undefined;
        actor?: Actor | undefined;
        token?: TokenDocument | undefined;
        alias?: string | undefined;
      }
    | undefined): object;
  /**
   * A helper to prepare the speaker object based on a target TokenDocument
   * @param {object} [options={}]       Options which affect speaker identification
   * @param {TokenDocument} options.token        The TokenDocument of the speaker
   * @param {string} [options.alias]             The name of the speaker to display
   * @returns {object}                  The identified speaker data
   * @private
   */
  private static _getSpeakerFromToken;
  /**
   * A helper to prepare the speaker object based on a target Actor
   * @param {object} [options={}]       Options which affect speaker identification
   * @param {Scene} [options.scene]             The Scene is which the speaker resides
   * @param {Actor} [options.actor]             The Actor that is speaking
   * @param {string} [options.alias]            The name of the speaker to display
   * @returns {Object}                  The identified speaker data
   * @private
   */
  private static _getSpeakerFromActor;
  /**
   * A helper to prepare the speaker object based on a target User
   * @param {object} [options={}]       Options which affect speaker identification
   * @param {Scene} [options.scene]             The Scene in which the speaker resides
   * @param {User} [options.user]               The User who is speaking
   * @param {string} [options.alias]            The name of the speaker to display
   * @returns {Object}                  The identified speaker data
   * @private
   */
  private static _getSpeakerFromUser;
  /**
   * Obtain an Actor instance which represents the speaker of this message (if any)
   * @param {Object} speaker    The speaker data object
   * @returns {Actor|null}
   */
  static getSpeakerActor(speaker: Object): Actor | null;
  /**
   * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
   *
   * @param {string} name   The target name of the whisper target
   * @returns {User[]}      An array of User instances
   */
  static getWhisperRecipients(name: string): User[];
  /**
   * Is the display of dice rolls in this message collapsed (false) or expanded (true)
   * @type {boolean}
   * @private
   */
  private _rollExpanded;
  /**
   * Is this ChatMessage currently displayed in the sidebar ChatLog?
   * @type {boolean}
   */
  logged: boolean;
  /**
   * Return the recommended String alias for this message.
   * The alias could be a Token name in the case of in-character messages or dice rolls.
   * Alternatively it could be the name of a User in the case of OOC chat or whispers.
   * @type {string}
   */
  get alias(): string;
  /**
   * Is the current User the author of this message?
   * @type {boolean}
   */
  get isAuthor(): boolean;
  /**
   * Return whether the content of the message is visible to the current user.
   * For certain dice rolls, for example, the message itself may be visible while the content of that message is not.
   * @type {boolean}
   */
  get isContentVisible(): boolean;
  /**
   * Test whether the chat message contains a dice roll
   * @type {boolean}
   */
  get isRoll(): boolean;
  /**
   * Return whether the ChatMessage is visible to the current User.
   * Messages may not be visible if they are private whispers.
   * @type {boolean}
   */
  get visible(): boolean;
  /** @inheritdoc */
  prepareDerivedData(): void;
  rolls: any;
  /**
   * Update the data of a ChatMessage instance to apply a requested rollMode
   * @param {string} rollMode     The rollMode preference to apply to this message data
   */
  applyRollMode(rollMode: string): void;
  /**
   * Obtain a data object used to evaluate any dice rolls associated with this particular chat message
   * @returns {object}
   */
  getRollData(): object;
  /**
   * Render the HTML for the ChatMessage which should be added to the log
   * @returns {Promise<jQuery>}
   */
  getHTML(): Promise<jQuery>;
  /**
   * Render the inner HTML content for ROLL type messages.
   * @param {object} messageData      The chat message data used to render the message HTML
   * @returns {Promise}
   * @private
   */
  private _renderRollContent;
  /** @override */
  override _preCreate(data: any, options: any, user: any): Promise<void>;
  /** @override */
  override _onCreate(data: any, options: any, userId: any): void;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
  /** @override */
  override _onDelete(options: any, userId: any): void;
  /**
   * Export the content of the chat message into a standardized log format
   * @returns {string}
   */
  export(): string;
  /**
   * Return the first Roll instance contained in this chat message, if one is present
   * @deprecated since v10
   * @ignore
   * @type {Roll|null}
   */
  get roll(): Roll | null;
}
/**
 * The client-side Combatant document which extends the common BaseCombatant model.
 *
 * @extends documents.BaseCombatant
 * @mixes ClientDocumentMixin
 *
 * @see {@link Combat}                  The Combat document which contains Combatant embedded documents
 * @see {@link CombatantConfig}         The application which configures a Combatant.
 */
declare class Combatant {
  /**
   * The token video source image (if any)
   * @type {string|null}
   * @internal
   */
  _videoSrc: string | null;
  /**
   * The current value of the special tracked resource which pertains to this Combatant
   * @type {object|null}
   */
  resource: object | null;
  /**
   * A convenience alias of Combatant#parent which is more semantically intuitive
   * @type {Combat|null}
   */
  get combat(): Combat | null;
  /**
   * This is treated as a non-player combatant if it has no associated actor and no player users who can control it
   * @type {boolean}
   */
  get isNPC(): boolean;
  /** @override */
  override get isOwner(): any;
  /** @override */
  override get visible(): any;
  /**
   * A reference to the Actor document which this Combatant represents, if any
   * @type {Actor|null}
   */
  get actor(): Actor | null;
  /**
   * A reference to the Token document which this Combatant represents, if any
   * @type {TokenDocument|null}
   */
  get token(): TokenDocument | null;
  /**
   * An array of User documents who have ownership of this Document
   * @type {User[]}
   */
  get players(): User[];
  /**
   * Has this combatant been marked as defeated?
   * @type {boolean}
   */
  get isDefeated(): boolean;
  /** @inheritdoc */
  testUserPermission(
    user: any,
    permission: any,
    {
      exact,
    }?: {
      exact?: boolean | undefined;
    }
  ): any;
  /**
   * Get a Roll object which represents the initiative roll for this Combatant.
   * @param {string} formula        An explicit Roll formula to use for the combatant.
   * @returns {Roll}                The unevaluated Roll instance to use for the combatant.
   */
  getInitiativeRoll(formula: string): Roll;
  /**
   * Roll initiative for this particular combatant.
   * @param {string} [formula]      A dice formula which overrides the default for this Combatant.
   * @returns {Promise<Combatant>}  The updated Combatant.
   */
  rollInitiative(formula?: string | undefined): Promise<Function>;
  /** @override */
  override prepareDerivedData(): void;
  /**
   * Update the value of the tracked resource for this Combatant.
   * @returns {null|object}
   */
  updateResource(): null | object;
  /**
   * Acquire the default dice formula which should be used to roll initiative for this combatant.
   * Modules or systems could choose to override or extend this to accommodate special situations.
   * @returns {string}               The initiative formula to use for this combatant.
   * @protected
   */
  protected _getInitiativeFormula(): string;
}
/**
 * The client-side Combat document which extends the common BaseCombat model.
 *
 * @extends documents.BaseCombat
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Combats}             The world-level collection of Combat documents
 * @see {@link Combatant}                     The Combatant embedded document which exists within a Combat document
 * @see {@link CombatConfig}                  The Combat configuration application
 */
declare class Combat {
  /**
   * The configuration setting used to record Combat preferences
   * @type {string}
   */
  static CONFIG_SETTING: string;
  constructor(data: any, context: any);
  /**
   * Track the sorted turn order of this combat encounter
   * @type {Combatant[]}
   */
  turns: Function[];
  /**
   * Record the current round, turn, and tokenId to understand changes in the encounter state
   * @type {{round: number|null, turn: number|null, tokenId: string|null, combatantId: string|null}}
   * @private
   */
  private current;
  /**
   * Track the previous round, turn, and tokenId to understand changes in the encounter state
   * @type {{round: number|null, turn: number|null, tokenId: string|null, combatantId: string|null}}
   * @private
   */
  private previous;
  /**
   * Get the Combatant who has the current turn.
   * @type {Combatant}
   */
  get combatant(): Function;
  /**
   * Get the Combatant who has the next turn.
   * @type {Combatant}
   */
  get nextCombatant(): Function;
  /**
   * Return the object of settings which modify the Combat Tracker behavior
   * @type {object}
   */
  get settings(): object;
  /**
   * Has this combat encounter been started?
   * @type {boolean}
   */
  get started(): boolean;
  /** @inheritdoc */
  get visible(): boolean;
  /**
   * Is this combat active in the current scene?
   * @type {boolean}
   */
  get isActive(): boolean;
  /**
   * Set the current Combat encounter as active within the Scene.
   * Deactivate all other Combat encounters within the viewed Scene and set this one as active
   * @param {object} [options] Additional context to customize the update workflow
   * @returns {Promise<Combat>}
   */
  activate(options?: object | undefined): Promise<Combat>;
  /** @override */
  override prepareDerivedData(): void;
  /**
   * Get a Combatant using its Token id
   * @param {string} tokenId   The id of the Token for which to acquire the combatant
   * @returns {Combatant}
   */
  getCombatantByToken(tokenId: string): Function;
  /**
   * Get a Combatant using its Actor id
   * @param {string} actorId The id of the Actor for which to acquire the combatant
   * @returns {Combatant}
   */
  getCombatantByActor(actorId: string): Function;
  /**
   * Begin the combat encounter, advancing to round 1 and turn 1
   * @returns {Promise<Combat>}
   */
  startCombat(): Promise<Combat>;
  /**
   * Advance the combat to the next round
   * @returns {Promise<Combat>}
   */
  nextRound(): Promise<Combat>;
  /**
   * Rewind the combat to the previous round
   * @returns {Promise<Combat>}
   */
  previousRound(): Promise<Combat>;
  /**
   * Advance the combat to the next turn
   * @returns {Promise<Combat>}
   */
  nextTurn(): Promise<Combat>;
  /**
   * Rewind the combat to the previous turn
   * @returns {Promise<Combat>}
   */
  previousTurn(): Promise<Combat>;
  /**
   * Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker
   * @returns {Promise<Combat>}
   */
  endCombat(): Promise<Combat>;
  /**
   * Toggle whether this combat is linked to the scene or globally available.
   * @returns {Promise<Combat>}
   */
  toggleSceneLink(): Promise<Combat>;
  /**
   * Reset all combatant initiative scores, setting the turn back to zero
   * @returns {Promise<Combat>}
   */
  resetAll(): Promise<Combat>;
  /**
   * Roll initiative for one or multiple Combatants within the Combat document
   * @param {string|string[]} ids     A Combatant id or Array of ids for which to roll
   * @param {object} [options={}]     Additional options which modify how initiative rolls are created or presented.
   * @param {string|null} [options.formula]         A non-default initiative formula to roll. Otherwise, the system
   *                                                default is used.
   * @param {boolean} [options.updateTurn=true]     Update the Combat turn after adding new initiative scores to
   *                                                keep the turn on the same Combatant.
   * @param {object} [options.messageOptions={}]    Additional options with which to customize created Chat Messages
   * @returns {Promise<Combat>}       A promise which resolves to the updated Combat document once updates are complete.
   */
  rollInitiative(
    ids: string | string[],
    {
      formula,
      updateTurn,
      messageOptions,
    }?:
      | {
          formula?: string | null | undefined;
          updateTurn?: boolean | undefined;
          messageOptions?: object | undefined;
        }
      | undefined
  ): Promise<Combat>;
  /**
   * Roll initiative for all combatants which have not already rolled
   * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
   */
  rollAll(options?: object | undefined): Promise<Combat>;
  /**
   * Roll initiative for all non-player actors who have not already rolled
   * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
   */
  rollNPC(options?: object | undefined): Promise<Combat>;
  /**
   * Assign initiative for a single Combatant within the Combat encounter.
   * Update the Combat turn order to maintain the same combatant as the current turn.
   * @param {string} id         The combatant ID for which to set initiative
   * @param {number} value      A specific initiative value to set
   */
  setInitiative(id: string, value: number): Promise<void>;
  /**
   * Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name.
   * @returns {Combatant[]}
   */
  setupTurns(): Function[];
  turn: any;
  /**
   * Update active effect durations for all actors present in this Combat encounter.
   */
  updateEffectDurations(): void;
  /**
   * Loads the registered Combat Theme (if any) and plays the requested type of sound.
   * If multiple exist for that type, one is chosen at random.
   * @param {string} type     One of [ "startEncounter", "nextUp", "yourTurn" ]
   * @private
   */
  private _playCombatSound;
  /**
   * Define how the array of Combatants is sorted in the displayed list of the tracker.
   * This method can be overridden by a system or module which needs to display combatants in an alternative order.
   * The default sorting rules sort in descending order of initiative using combatant IDs for tiebreakers.
   * @param {Combatant} a     Some combatant
   * @param {Combatant} b     Some other combatant
   * @protected
   */
  protected _sortCombatants(a: Function, b: Function): number;
  /** @inheritdoc */
  _onCreate(data: any, options: any, userId: any): void;
  /** @inheritdoc */
  _onUpdate(data: any, options: any, userId: any): any;
  /** @inheritdoc */
  _onDelete(options: any, userId: any): void;
  /** @inheritdoc */
  _onCreateEmbeddedDocuments(
    type: any,
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onUpdateEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onDeleteEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
}
/**
 * The client-side Drawing document which extends the common BaseDrawing model.
 *
 * @extends documents.BaseDrawing
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}               The Scene document type which contains Drawing embedded documents
 * @see {@link DrawingConfig}       The Drawing configuration application
 */
declare class DrawingDocument {
  set elevation(arg: number);
  /**
   * Define an elevation property on the Drawing Document which in the future will become a part of its data schema.
   * @type {number}
   */
  get elevation(): number;
  /**
   * Define a sort property on the Drawing Document which in the future will become a core part of its data schema.
   * @type {number}
   */
  get sort(): number;
  #private;
}
/**
 * The client-side FogExploration document which extends the common BaseFogExploration model.
 * @extends documents.BaseFogExploration
 * @mixes ClientDocumentMixin
 */
declare class FogExploration {
  /**
   * Obtain the fog of war exploration progress for a specific Scene and User.
   * @param {object} [query]        Parameters for which FogExploration document is retrieved
   * @param {string} [query.scene]    A certain Scene ID
   * @param {string} [query.user]     A certain User ID
   * @param {object} [options={}]   Additional options passed to DatabaseBackend#get
   * @returns {Promise<FogExploration|null>}
   */
  static get(
    {
      scene,
      user,
    }?:
      | {
          scene?: string | undefined;
          user?: string | undefined;
        }
      | undefined,
    options?: object | undefined
  ): Promise<FogExploration | null>;
  /**
   * Explore fog of war for a new point source position.
   * @param {PointSource} source    The candidate source of exploration
   * @param {boolean} [force=false] Force the position to be re-explored
   * @returns {boolean}             Is the source position newly explored?
   */
  explore(source: PointSource, force?: boolean | undefined): boolean;
  /**
   * Transform the explored base64 data into a PIXI.Texture object
   * @returns {PIXI.Texture|null}
   */
  getTexture(): PIXI.Texture | null;
}
/**
 * The client-side Folder document which extends the common BaseFolder model.
 * @extends documents.BaseFolder
 * @mixes ClientDocumentMixin
 *
 * @see {@link Folders}                     The world-level collection of Folder documents
 * @see {@link FolderConfig}                The Folder configuration application
 */
declare class Folder {
  /**
   * Present a Dialog form to create a new Folder.
   * @see ClientDocumentMixin.createDialog
   * @param {object} data              Initial data with which to populate the creation form
   * @param {object} [context={}]      Additional context options or dialog positioning options
   * @param {object} [context.options={}] Dialog options
   * @returns {Promise<Folder|null>}   A Promise which resolves to the created Folder, or null if the dialog was
   *                                   closed.
   */
  static createDialog(data?: object, options?: {}): Promise<Folder | null>;
  /**
   * The depth of this folder in its sidebar tree
   * @type {number}
   */
  depth: number;
  /**
   * An array of other Folders which are the displayed children of this one. This differs from the results of
   * {@link Folder.getSubfolders} because reports the subset of child folders which  are displayed to the current User
   * in the UI.
   * @type {Folder[]}
   */
  children: Folder[];
  /**
   * Return whether the folder is displayed in the sidebar to the current User.
   * @type {boolean}
   */
  displayed: boolean;
  set contents(arg: abstract.Document[]);
  /**
   * Return an array of the Document instances which are contained within this Folder.
   * @type {ClientDocument[]}
   */
  get contents(): abstract.Document[];
  /**
   * Return a reference to the Document type which is contained within this Folder.
   * @returns {Function}
   */
  get documentClass(): Function;
  /**
   * Return a reference to the WorldCollection instance which provides Documents to this Folder.
   * @returns {WorldCollection}
   */
  get documentCollection(): WorldCollection;
  /**
   * Return whether the folder is currently expanded within the sidebar interface.
   * @type {boolean}
   */
  get expanded(): boolean;
  /**
   * Return the list of ancestors of this folder, starting with the parent.
   * @type {Folder[]}
   */
  get ancestors(): Folder[];
  /**
   * Export all Documents contained in this Folder to a given Compendium pack.
   * Optionally update existing Documents within the Pack by name, otherwise append all new entries.
   * @param {CompendiumCollection} pack       A Compendium pack to which the documents will be exported
   * @param {object} [options]                Additional options which customize how content is exported.
   *                                          See {@link ClientDocumentMixin#toCompendium}
   * @param {boolean} [options.updateByName=false]    Update existing entries in the Compendium pack, matching by name
   * @returns {Promise<CompendiumCollection>}  The updated Compendium Collection instance
   */
  exportToCompendium(
    pack: CompendiumCollection,
    options?:
      | {
          updateByName?: boolean | undefined;
        }
      | undefined
  ): Promise<CompendiumCollection>;
  /**
   * Provide a dialog form that allows for exporting the contents of a Folder into an eligible Compendium pack.
   * @param {string} pack       A pack ID to set as the default choice in the select input
   * @param {object} options    Additional options passed to the Dialog.prompt method
   * @returns {Promise<void>}   A Promise which resolves or rejects once the dialog has been submitted or closed
   */
  exportDialog(pack: string, options?: object): Promise<void>;
  /**
   * Get the Folder documents which are sub-folders of the current folder, either direct children or recursively.
   * @param {boolean} [recursive=false] Identify child folders recursively, if false only direct children are returned
   * @returns {Folder[]}  An array of Folder documents which are subfolders of this one
   */
  getSubfolders(recursive?: boolean | undefined): Folder[];
  /** @inheritdoc */
  _onDelete(options: any, userId: any): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get content(): abstract.Document[];
  #private;
}
/**
 * The client-side Item document which extends the common BaseItem model.
 * @extends documents.BaseItem
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Items}            The world-level collection of Item documents
 * @see {@link applications.ItemSheet}     The Item configuration application
 */
declare class Item {
  /** @inheritdoc */
  static _onCreateDocuments(items: any, context: any): Promise<any>;
  /** @inheritdoc */
  static _onDeleteDocuments(items: any, context: any): Promise<any>;
  /**
   * A convenience alias of Item#parent which is more semantically intuitive
   * @type {Actor|null}
   */
  get actor(): Actor | null;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * A convenience alias of Item#isEmbedded which is preserves legacy support
   * @type {boolean}
   */
  get isOwned(): boolean;
  /**
   * Return an array of the Active Effect instances which originated from this Item.
   * The returned instances are the ActiveEffect instances which exist on the Item itself.
   * @type {ActiveEffect[]}
   */
  get transferredEffects(): ActiveEffect[];
  /**
   * Prepare a data object which defines the data schema used by dice roll commands against this Item
   * @returns {object}
   */
  getRollData(): object;
}
/**
 * The client-side JournalEntry document which extends the common BaseJournalEntry model.
 * @extends documents.BaseJournalEntry
 * @mixes ClientDocumentMixin
 *
 * @see {@link Journal}                       The world-level collection of JournalEntry documents
 * @see {@link JournalSheet}                  The JournalEntry configuration application
 */
declare class JournalEntry {
  /**
   * A boolean indicator for whether the JournalEntry is visible to the current user in the directory sidebar
   * @type {boolean}
   */
  get visible(): boolean;
  /**
   * Return a reference to the Note instance for this Journal Entry in the current Scene, if any.
   * If multiple notes are placed for this Journal Entry, only the first will be returned.
   * @type {Note|null}
   */
  get sceneNote(): Function | null;
  /**
   * Show the JournalEntry to connected players.
   * By default, the entry will only be shown to players who have permission to observe it.
   * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
   *
   * @param {boolean} [force=false]    Display the entry to all players regardless of normal permissions
   * @returns {Promise<JournalEntry>}  A Promise that resolves back to the shown entry once the request is processed
   * @alias Journal.show
   */
  show(force?: boolean | undefined): Promise<JournalEntry>;
  /**
   * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
   * The note will also be highlighted as if hovered upon by the mouse
   * @param {object} [options={}]         Options which modify the pan operation
   * @param {number} [options.scale=1.5]          The resulting zoom level
   * @param {number} [options.duration=250]       The speed of the pan animation in milliseconds
   * @returns {Promise<void>}             A Promise which resolves once the pan animation has concluded
   */
  panToNote(
    options?:
      | {
          scale?: number | undefined;
          duration?: number | undefined;
        }
      | undefined
  ): Promise<void>;
  /** @inheritdoc */
  _preCreate(data: any, options: any, user: any): Promise<any>;
  /** @inheritdoc */
  _preUpdate(changed: any, options: any, user: any): Promise<any>;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
  /** @override */
  override _onDelete(options: any, userId: any): void;
}
/**
 * The client-side JournalEntryPage document which extends the common BaseJournalEntryPage document model.
 * @extends documents.BaseJournalEntryPage
 * @mixes ClientDocumentMixin
 *
 * @see {@link JournalEntry}  The JournalEntry document type which contains JournalEntryPage embedded documents.
 */
declare class JournalEntryPage {
  /**
   * Convert a heading into slug suitable for use as an identifier.
   * @param {HTMLHeadingElement|string} heading  The heading element or some text content.
   * @returns {string}
   */
  static slugifyHeading(heading: HTMLHeadingElement | string): string;
  /**
   * Build a table of contents for the given HTML content.
   * @param {HTMLElement[]} html                     The HTML content to generate a ToC outline for.
   * @param {object} [options]                       Additional options to configure ToC generation.
   * @param {boolean} [options.includeElement=true]  Include references to the heading DOM elements in the returned ToC.
   * @returns {Object<JournalEntryPageHeading>}
   */
  static buildTOC(
    html: HTMLElement[],
    {
      includeElement,
    }?:
      | {
          includeElement?: boolean | undefined;
        }
      | undefined
  ): any;
  /**
   * Flatten the tree structure into a single object with each node's slug as the key.
   * @param {JournalEntryPageHeading[]} nodes  The root ToC nodes.
   * @returns {Object<JournalEntryPageHeading>}
   * @protected
   */
  protected static _flattenTOC(
    nodes: {
      /**
       * The heading level, 1-6.
       */
      level: number;
      /**
       * The raw heading text with any internal tags omitted.
       */
      text: string;
      /**
       * The generated slug for this heading.
       */
      slug: string;
      /**
       * The currently rendered element for this heading, if it exists.
       */
      element?: HTMLHeadingElement | undefined;
      /**
       * Any child headings of this one.
       */
      children: string[];
    }[]
  ): any;
  /**
   * Construct a table of contents node from a heading element.
   * @param {HTMLHeadingElement} heading             The heading element.
   * @param {object} [options]                       Additional options to configure the returned node.
   * @param {boolean} [options.includeElement=true]  Whether to include the DOM element in the returned ToC node.
   * @returns {JournalEntryPageHeading}
   * @protected
   */
  protected static _makeHeadingNode(
    heading: HTMLHeadingElement,
    {
      includeElement,
    }?:
      | {
          includeElement?: boolean | undefined;
        }
      | undefined
  ): {
    /**
     * The heading level, 1-6.
     */
    level: number;
    /**
     * The raw heading text with any internal tags omitted.
     */
    text: string;
    /**
     * The generated slug for this heading.
     */
    slug: string;
    /**
     * The currently rendered element for this heading, if it exists.
     */
    element?: HTMLHeadingElement | undefined;
    /**
     * Any child headings of this one.
     */
    children: string[];
  };
  /**
   * @typedef {object} JournalEntryPageHeading
   * @property {number} level                  The heading level, 1-6.
   * @property {string} text                   The raw heading text with any internal tags omitted.
   * @property {string} slug                   The generated slug for this heading.
   * @property {HTMLHeadingElement} [element]  The currently rendered element for this heading, if it exists.
   * @property {string[]} children             Any child headings of this one.
   */
  /**
   * The cached table of contents for this JournalEntryPage.
   * @type {Object<JournalEntryPageHeading>}
   * @protected
   */
  protected _toc: any;
  /**
   * The table of contents for this JournalEntryPage.
   * @type {Object<JournalEntryPageHeading>}
   */
  get toc(): any;
  /** @inheritdoc */
  get permission(): any;
  /**
   * Return a reference to the Note instance for this Journal Entry Page in the current Scene, if any.
   * If multiple notes are placed for this Journal Entry, only the first will be returned.
   * @type {Note|null}
   */
  get sceneNote(): Function | null;
  /** @inheritdoc */
  _createDocumentLink(
    eventData: any,
    {
      relativeTo,
      label,
    }?: {
      relativeTo: any;
      label: any;
    }
  ): any;
  /** @inheritdoc */
  _onClickDocumentLink(event: any): any;
  /** @inheritdoc */
  _onUpdate(changed: any, options: any, userId: any): void;
}
type JournalEntryPageHeading = {
  /**
   * The heading level, 1-6.
   */
  level: number;
  /**
   * The raw heading text with any internal tags omitted.
   */
  text: string;
  /**
   * The generated slug for this heading.
   */
  slug: string;
  /**
   * The currently rendered element for this heading, if it exists.
   */
  element?: HTMLHeadingElement | undefined;
  /**
   * Any child headings of this one.
   */
  children: string[];
};
/**
 * The client-side Macro document which extends the common BaseMacro model.
 * @extends documents.BaseMacro
 * @mixes ClientDocumentMixin
 *
 * @see {@link Macros}                       The world-level collection of Macro documents
 * @see {@link MacroConfig}                  The Macro configuration application
 */
declare class Macro {
  /**
   * Is the current User the author of this macro?
   * @type {boolean}
   */
  get isAuthor(): boolean;
  /**
   * Test whether the current user is capable of executing a Macro script
   * @type {boolean}
   */
  get canExecute(): boolean;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * Execute the Macro command.
   * @param {object} [scope={}]     Provide some additional scope configuration for the Macro
   * @param {Actor} [scope.actor]   An Actor who is the protagonist of the executed action
   * @param {Token} [scope.token]   A Token which is the protagonist of the executed action
   */
  execute({
    actor,
    token,
  }?:
    | {
        actor?: Actor | undefined;
        token?: Function | undefined;
      }
    | undefined): any;
  /**
   * Execute the command as a chat macro.
   * Chat macros simulate the process of the command being entered into the Chat Log input textarea.
   * @private
   */
  private _executeChat;
  /**
   * Execute the command as a script macro.
   * Script Macros are wrapped in an async IIFE to allow the use of asynchronous commands and await statements.
   * @param {object} [options={}]
   * @param {Actor} [options.actor]
   * @param {Token} [options.token]
   * @private
   */
  private _executeScript;
  /** @inheritdoc */
  _onClickDocumentLink(event: any): any;
}
/**
 * The client-side MeasuredTemplate document which extends the common BaseMeasuredTemplate document model.
 * @extends documents.BaseMeasuredTemplate
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains MeasuredTemplate documents
 * @see {@link MeasuredTemplateConfig}    The MeasuredTemplate configuration application
 */
declare class MeasuredTemplateDocument {
  /**
   * A reference to the User who created the MeasuredTemplate document.
   * @type {User}
   */
  get author(): User;
  /**
   * Rotation is an alias for direction
   * @returns {number}
   */
  get rotation(): number;
}
/**
 * The client-side Note document which extends the common BaseNote document model.
 * @extends documents.BaseNote
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Note documents
 * @see {@link NoteConfig}                The Note configuration application
 */
declare class NoteDocument {
  /**
   * The associated JournalEntry which is referenced by this Note
   * @type {JournalEntry}
   */
  get entry(): JournalEntry;
  /**
   * The specific JournalEntryPage within the associated JournalEntry referenced by this Note.
   * @type {JournalEntryPage}
   */
  get page(): JournalEntryPage;
  /**
   * The text label used to annotate this Note
   * @type {string}
   */
  get label(): string;
}
/**
 * The client-side Playlist document which extends the common BasePlaylist model.
 * @extends documents.BasePlaylist
 * @mixes ClientDocumentMixin
 *
 * @see {@link Playlists}             The world-level collection of Playlist documents
 * @see {@link PlaylistSound}         The PlaylistSound embedded document within a parent Playlist
 * @see {@link PlaylistConfig}        The Playlist configuration application
 */
declare class Playlist {
  /**
   * Find all content links belonging to a given {@link Playlist} or {@link PlaylistSound}.
   * @param {Playlist|PlaylistSound} doc  The Playlist or PlaylistSound.
   * @returns {NodeListOf<Element>}
   * @protected
   */
  protected static _getSoundContentLinks(
    doc: Playlist | PlaylistSound
  ): NodeListOf<Element>;
  /**
   * Playlists may have a playback order which defines the sequence of Playlist Sounds
   * @type {string[]}
   */
  _playbackOrder: string[];
  /**
   * The order in which sounds within this playlist will be played (if sequential or shuffled)
   * Uses a stored seed for randomization to guarantee that all clients generate the same random order.
   * @type {string[]}
   */
  get playbackOrder(): string[];
  /** @inheritdoc */
  get visible(): any;
  /** @inheritdoc */
  prepareDerivedData(): void;
  playing: any;
  /**
   * Begin simultaneous playback for all sounds in the Playlist.
   * @returns {Promise<Playlist>} The updated Playlist document
   */
  playAll(): Promise<Playlist>;
  /**
   * Play the next Sound within the sequential or shuffled Playlist.
   * @param {string} [soundId]      The currently playing sound ID, if known
   * @param {object} [options={}]   Additional options which configure the next track
   * @param {number} [options.direction=1] Whether to advance forward (if 1) or backwards (if -1)
   * @returns {Promise<Playlist>}   The updated Playlist document
   */
  playNext(
    soundId?: string | undefined,
    {
      direction,
    }?:
      | {
          direction?: number | undefined;
        }
      | undefined
  ): Promise<Playlist>;
  /**
   * Begin playback of a specific Sound within this Playlist.
   * Determine which other sounds should remain playing, if any.
   * @param {PlaylistSound} sound       The desired sound that should play
   * @returns {Promise<Playlist>}       The updated Playlist
   */
  playSound(sound: PlaylistSound): Promise<Playlist>;
  /**
   * Stop playback of a specific Sound within this Playlist.
   * Determine which other sounds should remain playing, if any.
   * @param {PlaylistSound} sound       The desired sound that should play
   * @returns {Promise<Playlist>}       The updated Playlist
   */
  stopSound(sound: PlaylistSound): Promise<Playlist>;
  /**
   * End playback for any/all currently playing sounds within the Playlist.
   * @returns {Promise<Playlist>} The updated Playlist document
   */
  stopAll(): Promise<Playlist>;
  /**
   * Cycle the playlist mode
   * @return {Promise.<Playlist>}   A promise which resolves to the updated Playlist instance
   */
  cycleMode(): Promise<Playlist>;
  /**
   * Get the next sound in the cached playback order. For internal use.
   * @private
   */
  private _getNextSound;
  /**
   * Get the previous sound in the cached playback order. For internal use.
   * @private
   */
  private _getPreviousSound;
  /**
   * Define the sorting order for the Sounds within this Playlist. For internal use.
   * @private
   */
  private _sortSounds;
  /** @inheritdoc */
  toAnchor({ classes, ...options }?: { classes?: any[] | undefined }): any;
  /** @inheritdoc */
  _onClickDocumentLink(event: any): Promise<Playlist>;
  /** @inheritdoc */
  _preUpdate(changed: any, options: any, user: any): Promise<any>;
  /** @inheritdoc */
  _onUpdate(changed: any, options: any, userId: any): void;
  /** @inheritdoc */
  _onDelete(options: any, userId: any): void;
  /** @inheritdoc */
  _onCreateEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    createData: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onUpdateEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    changes: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onDeleteEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    ids: any,
    options: any,
    userId: any
  ): void;
  /**
   * Handle callback logic when an individual sound within the Playlist concludes playback naturally
   * @param {PlaylistSound} sound
   * @private
   */
  private _onSoundEnd;
  /**
   * Handle callback logic when playback for an individual sound within the Playlist is started.
   * Schedule auto-preload of next track
   * @param {PlaylistSound} sound
   * @private
   */
  private _onSoundStart;
  /**
   * Update the playing status of this Playlist in content links.
   * @param {object} changed  The data changes.
   * @private
   */
  private _updateContentLinkPlaying;
  /** @inheritdoc */
  toCompendium(pack: any, options?: {}): any;
}
/**
 * The client-side PlaylistSound document which extends the common BasePlaylistSound model.
 * Each PlaylistSound belongs to the sounds collection of a Playlist document.
 * @extends documents.BasePlaylistSound
 * @mixes ClientDocumentMixin
 *
 * @see {@link Playlist}              The Playlist document which contains PlaylistSound embedded documents
 * @see {@link PlaylistSoundConfig}   The PlaylistSound configuration application
 * @see {@link Sound}                 The Sound API which manages web audio playback
 */
declare class PlaylistSound {
  /**
   * The debounce tolerance for processing rapid volume changes into database updates in milliseconds
   * @type {number}
   */
  static VOLUME_DEBOUNCE_MS: number;
  constructor(data: any, context: any);
  /**
   * The Sound which manages playback for this playlist sound
   * @type {Sound|null}
   */
  sound: Sound | null;
  /**
   * A debounced function, accepting a single volume parameter to adjust the volume of this sound
   * @type {Function}
   * @param {number} volume     The desired volume level
   */
  debounceVolume: Function;
  /**
   * Create a Sound used to play this PlaylistSound document
   * @returns {Sound|null}
   * @private
   */
  private _createSound;
  /**
   * The effective volume at which this playlist sound is played, incorporating the global playlist volume setting.
   * @type {number}
   */
  get effectiveVolume(): number;
  /**
   * Determine the fade duration for this PlaylistSound based on its own configuration and that of its parent.
   * @type {number}
   */
  get fadeDuration(): number;
  /**
   * Synchronize playback for this particular PlaylistSound instance
   */
  sync(): number | void | Promise<void> | Promise<Sound>;
  /** @inheritdoc */
  toAnchor({ classes, ...options }?: { classes?: any[] | undefined }): any;
  /** @inheritdoc */
  _onClickDocumentLink(event: any): any;
  /** @override */
  override _onCreate(data: any, options: any, userId: any): void;
  /** @override */
  override _onUpdate(changed: any, options: any, userId: any): void;
  /** @override */
  override _onDelete(options: any, userId: any): void;
  playing: boolean | undefined;
  /**
   * Special handling that occurs when a PlaylistSound reaches the natural conclusion of its playback.
   * @private
   */
  private _onEnd;
  /**
   * Special handling that occurs when playback of a PlaylistSound is started.
   * @private
   */
  private _onStart;
  /**
   * Special handling that occurs when a PlaylistSound is manually stopped before its natural conclusion.
   * @private
   */
  private _onStop;
  /**
   * Handle fading in the volume for this sound when it begins to play (or loop)
   * @param {Sound} sound     The sound fading-in
   * @private
   */
  private _fadeIn;
  /**
   * Handle fading out the volume for this sound when it begins to play (or loop)
   * @param {Sound} sound     The sound fading-out
   * @private
   */
  private _fadeOut;
}
/**
 * The client-side Scene document which extends the common BaseScene model.
 * @extends documents.BaseItem
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scenes}            The world-level collection of Scene documents
 * @see {@link SceneConfig}       The Scene configuration application
 */
declare class Scene {
  /**
   * @deprecated since v10
   * @ignore
   */
  static getDimensions(data: any): void;
  /**
   * Track the viewed position of each scene (while in memory only, not persisted)
   * When switching back to a previously viewed scene, we can automatically pan to the previous position.
   * @type {CanvasViewPosition}
   */
  _viewPosition: {
    /**
     * The x-coordinate which becomes stage.pivot.x
     */
    x: number | null;
    /**
     * The y-coordinate which becomes stage.pivot.y
     */
    y: number | null;
    /**
     * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    scale: number | null;
  };
  /**
   * Track whether the scene is the active view
   * @type {boolean}
   */
  _view: boolean;
  /**
   * Determine the canvas dimensions this Scene would occupy, if rendered
   * @type {object}
   */
  dimensions: object;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * A convenience accessor for whether the Scene is currently viewed
   * @type {boolean}
   */
  get isView(): boolean;
  /**
   * Set this scene as currently active
   * @returns {Promise<Scene>}  A Promise which resolves to the current scene once it has been successfully activated
   */
  activate(): Promise<Scene>;
  /**
   * Set this scene as the current view
   * @returns {Promise<Scene>}
   */
  view(): Promise<Scene>;
  /** @override */
  override clone(createData?: {}, options?: {}): any;
  /** @inheritdoc */
  prepareBaseData(): void;
  playlistSound: any;
  foregroundElevation: any;
  /**
   * @typedef {object} SceneDimensions
   * @property {number} width        The width of the canvas.
   * @property {number} height       The height of the canvas.
   * @property {number} size         The grid size.
   * @property {Rectangle} rect      The canvas rectangle.
   * @property {number} sceneX       The X coordinate of the scene rectangle within the larger canvas.
   * @property {number} sceneY       The Y coordinate of the scene rectangle within the larger canvas.
   * @property {number} sceneWidth   The width of the scene.
   * @property {number} sceneHeight  The height of the scene.
   * @property {Rectangle} sceneRect The scene rectangle.
   * @property {number} distance     The number of distance units in a single grid space.
   * @property {number} ratio        The aspect ratio of the scene rectangle.
   * @property {number} maxR               The length of the longest line that can be drawn on the canvas.
   */
  /**
   * Get the Canvas dimensions which would be used to display this Scene.
   * Apply padding to enlarge the playable space and round to the nearest 2x grid size to ensure symmetry.
   * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
   * @returns {SceneDimensions}
   */
  getDimensions(): {
    /**
     * The width of the canvas.
     */
    width: number;
    /**
     * The height of the canvas.
     */
    height: number;
    /**
     * The grid size.
     */
    size: number;
    /**
     * The canvas rectangle.
     */
    rect: Rectangle;
    /**
     * The X coordinate of the scene rectangle within the larger canvas.
     */
    sceneX: number;
    /**
     * The Y coordinate of the scene rectangle within the larger canvas.
     */
    sceneY: number;
    /**
     * The width of the scene.
     */
    sceneWidth: number;
    /**
     * The height of the scene.
     */
    sceneHeight: number;
    /**
     * The scene rectangle.
     */
    sceneRect: Rectangle;
    /**
     * The number of distance units in a single grid space.
     */
    distance: number;
    /**
     * The aspect ratio of the scene rectangle.
     */
    ratio: number;
    /**
     * The length of the longest line that can be drawn on the canvas.
     */
    maxR: number;
  };
  /** @inheritdoc */
  _onClickDocumentLink(event: any): any;
  /** @override */
  override _preCreate(data: any, options: any, user: any): Promise<any>;
  /** @override */
  override _onCreate(data: any, options: any, userId: any): void;
  /** @override */
  override _preUpdate(data: any, options: any, user: any): Promise<any>;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): any;
  thumb: any;
  /** @inheritdoc */
  _preDelete(options: any, user: any): Promise<void>;
  /** @override */
  override _onDelete(options: any, userId: any): void;
  /**
   * Handle Scene activation workflow if the active state is changed to true
   * @param {boolean} active    Is the scene now active?
   * @protected
   */
  protected _onActivate(active: boolean): any;
  /** @inheritdoc */
  _preCreateEmbeddedDocuments(
    embeddedName: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onCreateEmbeddedDocuments(...args: any[]): void;
  /** @inheritdoc */
  _preUpdateEmbeddedDocuments(
    embeddedName: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @override */
  override _onUpdateEmbeddedDocuments(...args: any[]): void;
  /** @inheritdoc */
  _preDeleteEmbeddedDocuments(
    embeddedName: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onDeleteEmbeddedDocuments(...args: any[]): void;
  /** @inheritdoc */
  toCompendium(pack: any, options?: {}): any;
  /**
   * Create a 300px by 100px thumbnail image for this scene background
   * @param {object} [options]      Options which modify thumbnail creation
   * @param {string|null} [options.img]  A background image to use for thumbnail creation, otherwise the current scene
   *                          background is used.
   * @param {number} [options.width]        The desired thumbnail width. Default is 300px
   * @param {number} [options.height]       The desired thumbnail height. Default is 100px;
   * @param {string} [options.format]       Which image format should be used? image/png, image/jpg, or image/webp
   * @param {number} [options.quality]      What compression quality should be used for jpeg or webp, between 0 and 1
   * @returns {Promise<object>}      The created thumbnail data.
   */
  createThumbnail({
    img,
    width,
    height,
    format,
    quality,
  }?:
    | {
        img?: string | null | undefined;
        width?: number | undefined;
        height?: number | undefined;
        format?: string | undefined;
        quality?: number | undefined;
      }
    | undefined): Promise<object>;
}
type SceneDimensions = {
  /**
   * The width of the canvas.
   */
  width: number;
  /**
   * The height of the canvas.
   */
  height: number;
  /**
   * The grid size.
   */
  size: number;
  /**
   * The canvas rectangle.
   */
  rect: Rectangle;
  /**
   * The X coordinate of the scene rectangle within the larger canvas.
   */
  sceneX: number;
  /**
   * The Y coordinate of the scene rectangle within the larger canvas.
   */
  sceneY: number;
  /**
   * The width of the scene.
   */
  sceneWidth: number;
  /**
   * The height of the scene.
   */
  sceneHeight: number;
  /**
   * The scene rectangle.
   */
  sceneRect: Rectangle;
  /**
   * The number of distance units in a single grid space.
   */
  distance: number;
  /**
   * The aspect ratio of the scene rectangle.
   */
  ratio: number;
  /**
   * The length of the longest line that can be drawn on the canvas.
   */
  maxR: number;
};
/**
 * The client-side Setting document which extends the common BaseSetting model.
 * @extends documents.BaseSetting
 * @mixes ClientDocumentMixin
 *
 * @see {@link WorldSettings}       The world-level collection of Setting documents
 */
declare class Setting {
  /** @override */
  override _onCreate(data: any, options: any, userId: any): void;
  /** @override */
  override _onUpdate(changed: any, options: any, userId: any): void;
}
/**
 * @typedef {Object} RollTableDraw      An object containing the executed Roll and the produced results
 * @property {Roll} roll                The Dice roll which generated the draw
 * @property {TableResult[]} results    An array of drawn TableResult documents
 */
/**
 * The client-side RollTable document which extends the common BaseRollTable model.
 * @extends documents.BaseRollTable
 * @mixes ClientDocumentMixin
 *
 * @see {@link RollTables}                      The world-level collection of RollTable documents
 * @see {@link TableResult}                     The embedded TableResult document
 * @see {@link RollTableConfig}                 The RollTable configuration application
 */
declare class RollTable {
  /**
   * Create a new RollTable document using all of the Documents from a specific Folder as new results.
   * @param {Folder} folder       The Folder document from which to create a roll table
   * @param {object} options      Additional options passed to the RollTable.create method
   * @returns {Promise<RollTable>}
   */
  static fromFolder(folder: Folder, options?: object): Promise<RollTable>;
  /**
   * Provide a thumbnail image path used to represent this document.
   * @type {string}
   */
  get thumbnail(): string;
  /**
   * Display a result drawn from a RollTable in the Chat Log along.
   * Optionally also display the Roll which produced the result and configure aspects of the displayed messages.
   *
   * @param {TableResult[]} results         An Array of one or more TableResult Documents which were drawn and should
   *                                        be displayed.
   * @param {object} [options={}]           Additional options which modify message creation
   * @param {Roll} [options.roll]                 An optional Roll instance which produced the drawn results
   * @param {Object} [options.messageData={}]     Additional data which customizes the created messages
   * @param {Object} [options.messageOptions={}]  Additional options which customize the created messages
   */
  toMessage(
    results: TableResult[],
    {
      roll,
      messageData,
      messageOptions,
    }?:
      | {
          roll?: Roll | undefined;
          messageData?: Object | undefined;
          messageOptions?: Object | undefined;
        }
      | undefined
  ): Promise<any>;
  /**
   * Draw a result from the RollTable based on the table formula or a provided Roll instance
   * @param {object} [options={}]         Optional arguments which customize the draw behavior
   * @param {Roll} [options.roll]                   An existing Roll instance to use for drawing from the table
   * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
   * @param {TableResult[]} [options.results]       One or more table results which have been drawn
   * @param {boolean} [options.displayChat=true]    Whether to automatically display the results in chat
   * @param {string} [options.rollMode]             The chat roll mode to use when displaying the result
   * @returns {Promise<{RollTableDraw}>}  A Promise which resolves to an object containing the executed roll and the
   *                                      produced results.
   */
  draw({
    roll,
    recursive,
    results,
    displayChat,
    rollMode,
  }?:
    | {
        roll?: Roll | undefined;
        recursive?: boolean | undefined;
        results?: TableResult[] | undefined;
        displayChat?: boolean | undefined;
        rollMode?: string | undefined;
      }
    | undefined): Promise<{
    RollTableDraw;
  }>;
  /**
   * Draw multiple results from a RollTable, constructing a final synthetic Roll as a dice pool of inner rolls.
   * @param {number} number               The number of results to draw
   * @param {object} [options={}]         Optional arguments which customize the draw
   * @param {Roll} [options.roll]                   An optional pre-configured Roll instance which defines the dice
   *                                                roll to use
   * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
   * @param {boolean} [options.displayChat=true]    Automatically display the drawn results in chat? Default is true
   * @param {string} [options.rollMode]             Customize the roll mode used to display the drawn results
   * @returns {Promise<{RollTableDraw}>}  The drawn results
   */
  drawMany(
    number: number,
    {
      roll,
      recursive,
      displayChat,
      rollMode,
    }?:
      | {
          roll?: Roll | undefined;
          recursive?: boolean | undefined;
          displayChat?: boolean | undefined;
          rollMode?: string | undefined;
        }
      | undefined
  ): Promise<{
    RollTableDraw;
  }>;
  /**
   * Normalize the probabilities of rolling each item in the RollTable based on their assigned weights
   * @returns {Promise<RollTable>}
   */
  normalize(): Promise<RollTable>;
  /**
   * Reset the state of the RollTable to return any drawn items to the table
   * @returns {Promise<RollTable>}
   */
  resetResults(): Promise<RollTable>;
  /**
   * Evaluate a RollTable by rolling its formula and retrieving a drawn result.
   *
   * Note that this function only performs the roll and identifies the result, the RollTable#draw function should be
   * called to formalize the draw from the table.
   *
   * @param {object} [options={}]       Options which modify rolling behavior
   * @param {Roll} [options.roll]                   An alternative dice Roll to use instead of the default table formula
   * @param {boolean} [options.recursive=true]   If a RollTable document is drawn as a result, recursively roll it
   * @param {number} [options._depth]            An internal flag used to track recursion depth
   * @returns {Promise<RollTableDraw>}  The Roll and results drawn by that Roll
   *
   * @example Draw results using the default table formula
   * ```js
   * const defaultResults = await table.roll();
   * ```
   *
   * @example Draw results using a custom roll formula
   * ```js
   * const roll = new Roll("1d20 + @abilities.wis.mod", actor.getRollData());
   * const customResults = await table.roll({roll});
   * ```
   */
  roll({
    roll,
    recursive,
    _depth,
  }?:
    | {
        roll?: Roll | undefined;
        recursive?: boolean | undefined;
        _depth?: number | undefined;
      }
    | undefined): Promise<RollTableDraw>;
  /**
   * Get an Array of valid results for a given rolled total
   * @param {number} value    The rolled value
   * @returns {TableResult[]} An Array of results
   */
  getResultsForRoll(value: number): TableResult[];
  /** @inheritdoc */
  _onCreateEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @inheritdoc */
  _onDeleteEmbeddedDocuments(
    embeddedName: any,
    documents: any,
    result: any,
    options: any,
    userId: any
  ): void;
  /** @override */
  override toCompendium(pack: any, options?: {}): any;
}
/**
 * An object containing the executed Roll and the produced results
 */
type RollTableDraw = {
  /**
   * The Dice roll which generated the draw
   */
  roll: Roll;
  /**
   * An array of drawn TableResult documents
   */
  results: TableResult[];
};
/**
 * The client-side TableResult document which extends the common BaseTableResult document model.
 * @extends documents.BaseTableResult
 * @mixes ClientDocumentMixin
 *
 * @see {@link RollTable}                The RollTable document type which contains TableResult documents
 */
declare class TableResult {
  /**
   * A path reference to the icon image used to represent this result
   */
  get icon(): any;
  /**
   * Prepare a string representation for the result which (if possible) will be a dynamic link or otherwise plain text
   * @returns {string}  The text to display
   */
  getChatText(): string;
}
/**
 * The client-side Tile document which extends the common BaseTile document model.
 * @extends documents.BaseTile
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Tile documents
 * @see {@link TileConfig}                The Tile configuration application
 */
declare class TileDocument {
  set elevation(arg: number);
  /**
   * Define an elevation property on the Tile Document which in the future will become a core part of its data schema.
   * @type {number}
   */
  get elevation(): number;
  /**
   * Define a sort property on the Tile Document which in the future will become a core part of its data schema.
   * @type {number}
   */
  get sort(): number;
  /** @inheritdoc */
  prepareDerivedData(): void;
  x: any;
  y: any;
  /** @inheritDoc */
  _onUpdate(changed: any, options: any, user: any): void;
  #private;
}
/**
 * The client-side Token document which extends the common BaseToken document model.
 * @extends documents.BaseToken
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Token documents
 * @see {@link TokenConfig}               The Token configuration application
 */
declare class TokenDocument {
  /**
   * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker
   * @param {object} data
   * @param {string[]} _path
   * @returns {object}
   */
  static getTrackedAttributes(data: object, _path?: string[]): object;
  /**
   * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar
   * @param {object} attributes       The tracked attributes which can be chosen from
   * @returns {object}                A nested object of attribute choices to display
   */
  static getTrackedAttributeChoices(attributes: object): object;
  constructor(data: any, context?: {});
  /**
   * A cached reference to the Actor document that this Token modifies.
   * This may be a "synthetic" unlinked Token Actor which does not exist in the World.
   * @type {Actor|null}
   */
  _actor: Actor | null;
  /**
   * A lazily evaluated reference to the Actor this Token modifies.
   * If actorLink is true, then the document is the primary Actor document.
   * Otherwise, the Actor document is a synthetic (ephemeral) document constructed using the Token's actorData.
   * @returns {Actor|null}
   */
  get actor(): Actor | null;
  /**
   * An indicator for whether the current User has full control over this Token document.
   * @type {boolean}
   */
  get isOwner(): boolean;
  /**
   * A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy
   * @type {boolean}
   */
  get isLinked(): boolean;
  /**
   * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
   * @type {Combatant|null}
   */
  get combatant(): Function | null;
  /**
   * An indicator for whether this Token is currently involved in the active combat encounter.
   * @type {boolean}
   */
  get inCombat(): boolean;
  set sort(arg: number);
  /**
   * Define a sort order for this TokenDocument.
   * This controls its rendering order in the PrimaryCanvasGroup relative to siblings at the same elevation.
   * In the future this will be replaced with a persisted database field for permanent adjustment of token stacking.
   * In case of ties, Tokens will be sorted above other types of objects.
   * @type {number}
   */
  get sort(): number;
  /** @inheritdoc */
  prepareBaseData(): void;
  alpha: any;
  /**
   * Prepare detection modes which are available to the Token.
   * Ensure that every Token has the basic sight detection mode configured.
   * @protected
   */
  protected _prepareDetectionModes(): void;
  /** @inheritdoc */
  clone(data?: {}, options?: {}): any;
  /**
   * Create a synthetic Actor using a provided Token instance
   * If the Token data is linked, return the true Actor document
   * If the Token data is not linked, create a synthetic Actor using the Token's actorData override
   * @returns {Actor}
   */
  getActor(): Actor;
  /**
   * A helper method to retrieve the underlying data behind one of the Token's attribute bars
   * @param {string} barName        The named bar to retrieve the attribute for
   * @param {string} alternative    An alternative attribute path to get instead of the default one
   * @returns {object|null}         The attribute displayed on the Token bar, if any
   */
  getBarAttribute(barName: string, { alternative }?: string): object | null;
  /**
   * A helper function to toggle a status effect which includes an Active Effect template
   * @param {{id: string, label: string, icon: string}} effectData The Active Effect data, including statusId
   * @param {object} [options]                                     Options to configure application of the Active Effect
   * @param {boolean} [options.overlay=false]                      Should the Active Effect icon be displayed as an
   *                                                               overlay on the token?
   * @param {boolean} [options.active]                             Force a certain active state for the effect.
   * @returns {Promise<boolean>}                                   Whether the Active Effect is now on or off
   */
  toggleActiveEffect(
    effectData: {
      id: string;
      label: string;
      icon: string;
    },
    {
      overlay,
      active,
    }?:
      | {
          overlay?: boolean | undefined;
          active?: boolean | undefined;
        }
      | undefined
  ): Promise<boolean>;
  /**
   * Test whether a Token has a specific status effect.
   * @param {string} statusId     The status effect ID as defined in CONFIG.statusEffects
   * @returns {boolean}           Does the Token have this status effect?
   */
  hasStatusEffect(statusId: string): boolean;
  /**
   * Convenience method to change a token vision mode.
   * @param {string} visionMode       The vision mode to apply to this token.
   * @param {boolean} [defaults=true] If the vision mode should be updated with its defaults.
   * @returns {Promise<*>}
   */
  updateVisionMode(
    visionMode: string,
    defaults?: boolean | undefined
  ): Promise<any>;
  /**
   * Redirect updates to a synthetic Token Actor to instead update the tokenData override object.
   * Once an attribute in the Token has been overridden, it must always remain overridden.
   *
   * @param {object} update       The provided differential update data which should update the Token Actor
   * @param {object} options      Provided options which modify the update request
   * @returns {Promise<Actor[]>}  The updated un-linked Actor instance
   */
  modifyActorDocument(update: object, options: object): Promise<Actor[]>;
  /** @inheritdoc */
  getEmbeddedCollection(embeddedName: any): any;
  /**
   * Redirect creation of Documents within a synthetic Token Actor to instead update the tokenData override object.
   * @param {string} embeddedName   The named embedded Document type being modified
   * @param {object[]} data         The provided initial data with which to create the embedded Documents
   * @param {object} options        Provided options which modify the creation request
   * @returns {Promise<Document[]>} The created Embedded Document instances
   */
  createActorEmbeddedDocuments(
    embeddedName: string,
    data: object[],
    options: object
  ): Promise<Document[]>;
  /**
   * Redirect updating of Documents within a synthetic Token Actor to instead update the tokenData override object.
   * @param {string} embeddedName   The named embedded Document type being modified
   * @param {object[]} updates      The provided differential data with which to update the embedded Documents
   * @param {object} options        Provided options which modify the update request
   * @returns {Promise<Document[]>} The updated Embedded Document instances
   */
  updateActorEmbeddedDocuments(
    embeddedName: string,
    updates: object[],
    options: object
  ): Promise<Document[]>;
  /**
   * Redirect deletion of Documents within a synthetic Token Actor to instead update the tokenData override object.
   * @param {string} embeddedName   The named embedded Document type being deleted
   * @param {string[]} ids          The IDs of Documents to delete
   * @param {object} options        Provided options which modify the deletion request
   * @returns {Promise<Document[]>} The deleted Embedded Document instances
   */
  deleteActorEmbeddedDocuments(
    embeddedName: string,
    ids: string[],
    options: object
  ): Promise<Document[]>;
  /** @inheritdoc */
  _preUpdate(data: any, options: any, user: any): Promise<void>;
  /**
   * When the Actor data overrides change for an un-linked Token Actor, simulate the pre-update process.
   * @param {object} data
   * @param {object} options
   * @param {User} user
   * @returns {Promise<void>}
   * @private
   */
  private _preUpdateTokenActor;
  /** @inheritdoc */
  _onUpdate(data: any, options: any, userId: any): any;
  /**
   * When the base Actor for a TokenDocument changes, we may need to update its Actor instance
   * @param {object} update
   * @param {object} options
   * @private
   */
  private _onUpdateBaseActor;
  /**
   * When the Actor data overrides change for an un-linked Token Actor, simulate the post-update process.
   * @param {object} data
   * @param {object} options
   * @param {string} userId
   * @private
   */
  private _onUpdateTokenActor;
  #private;
}
/**
 * @deprecated since v10
 * @see data.PrototypeToken
 * @ignore
 */
declare class PrototypeTokenDocument {
  constructor(...args: any[]);
}
/**
 * The client-side User document which extends the common BaseUser model.
 * Each User document contains UserData which defines its data schema.
 *
 * @extends documents.BaseUser
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Users}             The world-level collection of User documents
 * @see {@link applications.UserConfig}     The User configuration application
 */
declare class User {
  /**
   * Track whether the user is currently active in the game
   * @type {boolean}
   */
  active: boolean;
  /**
   * Track references to the current set of Tokens which are targeted by the User
   * @type {Set<Token>}
   */
  targets: Set<Function>;
  /**
   * Track the ID of the Scene that is currently being viewed by the User
   * @type {string|null}
   */
  viewedScene: string | null;
  /**
   * A flag for whether the current User is a Trusted Player
   * @type {boolean}
   */
  get isTrusted(): boolean;
  /**
   * A flag for whether this User is the connected client
   * @type {boolean}
   */
  get isSelf(): boolean;
  /** @inheritdoc */
  prepareDerivedData(): void;
  avatar: any;
  border: any;
  /**
   * Assign a Macro to a numbered hotbar slot between 1 and 50
   * @param {Macro|null} macro      The Macro document to assign
   * @param {number|string} [slot]  A specific numbered hotbar slot to fill
   * @param {number} [fromSlot]     An optional origin slot from which the Macro is being shifted
   * @returns {Promise<User>}       A Promise which resolves once the User update is complete
   */
  assignHotbarMacro(
    macro: Macro | null,
    slot?: string | number | undefined,
    { fromSlot }?: number | undefined
  ): Promise<User>;
  /**
   * Assign a specific boolean permission to this user.
   * Modifies the user permissions to grant or restrict access to a feature.
   *
   * @param {string} permission    The permission name from USER_PERMISSIONS
   * @param {boolean} allowed      Whether to allow or restrict the permission
   */
  assignPermission(permission: string, allowed: boolean): any;
  /**
   * @typedef {object} PingData
   * @property {boolean} [pull=false]  Pulls all connected clients' views to the pinged co-ordinates.
   * @property {string} style          The ping style, see CONFIG.Canvas.pings.
   * @property {string} scene          The ID of the scene that was pinged.
   * @property {number} zoom           The zoom level at which the ping was made.
   */
  /**
   * @typedef {object} ActivityData
   * @property {string|null} [sceneId]           The ID of the scene that the user is viewing.
   * @property {{x: number, y: number}} [cursor] The position of the user's cursor.
   * @property {RulerData|null} [ruler]          The state of the user's ruler, if they are currently using one.
   * @property {string[]} [targets]              The IDs of the tokens the user has targeted in the currently viewed
   *                                             scene.
   * @property {boolean} [active]                Whether the user has an open WS connection to the server or not.
   * @property {boolean} [focus]                 Is the user pulling focus to the cursor coordinates?
   * @property {PingData} [ping]                 Is the user emitting a ping at the cursor coordinates?
   * @property {AVSettingsData} [av]             The state of the user's AV settings.
   */
  /**
   * Submit User activity data to the server for broadcast to other players.
   * This type of data is transient, persisting only for the duration of the session and not saved to any database.
   *
   * @param {ActivityData} activityData  An object of User activity data to submit to the server for broadcast.
   */
  broadcastActivity(activityData?: {
    /**
     * The ID of the scene that the user is viewing.
     */
    sceneId?: string | null | undefined;
    /**
     * The position of the user's cursor.
     */
    cursor?:
      | {
          x: number;
          y: number;
        }
      | undefined;
    /**
     * The state of the user's ruler, if they are currently using one.
     */
    ruler?:
      | {
          /**
           * The ruler measurement state.
           */
          _state: number;
          /**
           * A unique name for the ruler containing the owning user's ID.
           */
          name: string;
          /**
           * The current point the ruler has been extended to.
           */
          destination: PIXI.Point;
          /**
           * The class name of this ruler instance.
           */
          class: string;
          /**
           * Additional waypoints along the ruler's length, including the starting point.
           */
          waypoints: PIXI.Point[];
        }
      | null
      | undefined;
    /**
     * The IDs of the tokens the user has targeted in the currently viewed
     *               scene.
     */
    targets?: string[] | undefined;
    /**
     * Whether the user has an open WS connection to the server or not.
     */
    active?: boolean | undefined;
    /**
     * Is the user pulling focus to the cursor coordinates?
     */
    focus?: boolean | undefined;
    /**
     * Is the user emitting a ping at the cursor coordinates?
     */
    ping?:
      | {
          /**
           * Pulls all connected clients' views to the pinged co-ordinates.
           */
          pull?: boolean | undefined;
          /**
           * The ping style, see CONFIG.Canvas.pings.
           */
          style: string;
          /**
           * The ID of the scene that was pinged.
           */
          scene: string;
          /**
           * The zoom level at which the ping was made.
           */
          zoom: number;
        }
      | undefined;
    /**
     * The state of the user's AV settings.
     */
    av?: AVSettingsData | undefined;
  }): void;
  /**
   * Get an Array of Macro Documents on this User's Hotbar by page
   * @param {number} page     The hotbar page number
   * @returns {Array<{slot: number, macro: Macro|null}>}
   */
  getHotbarMacros(page?: number): Array<{
    slot: number;
    macro: Macro | null;
  }>;
  /**
   * Update the set of Token targets for the user given an array of provided Token ids.
   * @param {string[]} targetIds      An array of Token ids which represents the new target set
   */
  updateTokenTargets(targetIds?: string[]): void;
  /** @inheritdoc  */
  _onUpdate(data: any, options: any, userId: any): any;
  /** @inheritdoc  */
  _onDelete(options: any, userId: any): void;
}
type PingData = {
  /**
   * Pulls all connected clients' views to the pinged co-ordinates.
   */
  pull?: boolean | undefined;
  /**
   * The ping style, see CONFIG.Canvas.pings.
   */
  style: string;
  /**
   * The ID of the scene that was pinged.
   */
  scene: string;
  /**
   * The zoom level at which the ping was made.
   */
  zoom: number;
};
type ActivityData = {
  /**
   * The ID of the scene that the user is viewing.
   */
  sceneId?: string | null | undefined;
  /**
   * The position of the user's cursor.
   */
  cursor?:
    | {
        x: number;
        y: number;
      }
    | undefined;
  /**
   * The state of the user's ruler, if they are currently using one.
   */
  ruler?:
    | {
        /**
         * The ruler measurement state.
         */
        _state: number;
        /**
         * A unique name for the ruler containing the owning user's ID.
         */
        name: string;
        /**
         * The current point the ruler has been extended to.
         */
        destination: PIXI.Point;
        /**
         * The class name of this ruler instance.
         */
        class: string;
        /**
         * Additional waypoints along the ruler's length, including the starting point.
         */
        waypoints: PIXI.Point[];
      }
    | null
    | undefined;
  /**
   * The IDs of the tokens the user has targeted in the currently viewed
   *               scene.
   */
  targets?: string[] | undefined;
  /**
   * Whether the user has an open WS connection to the server or not.
   */
  active?: boolean | undefined;
  /**
   * Is the user pulling focus to the cursor coordinates?
   */
  focus?: boolean | undefined;
  /**
   * Is the user emitting a ping at the cursor coordinates?
   */
  ping?:
    | {
        /**
         * Pulls all connected clients' views to the pinged co-ordinates.
         */
        pull?: boolean | undefined;
        /**
         * The ping style, see CONFIG.Canvas.pings.
         */
        style: string;
        /**
         * The ID of the scene that was pinged.
         */
        scene: string;
        /**
         * The zoom level at which the ping was made.
         */
        zoom: number;
      }
    | undefined;
  /**
   * The state of the user's AV settings.
   */
  av?: AVSettingsData | undefined;
};
/**
 * The client-side Wall document which extends the common BaseWall document model.
 * @extends documents.BaseWall
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Wall documents
 * @see {@link WallConfig}                The Wall configuration application
 */
declare class WallDocument {}
/**
 * A type of DiceTerm used to represent flipping a two-sided coin.
 * @implements {DiceTerm}
 */
declare class Coin extends DiceTerm implements DiceTerm {
  /** @inheritdoc */
  static MODIFIERS: {
    c: string;
  };
  constructor(termData: any);
  /** @inheritdoc */
  roll({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): {
    result: undefined;
    active: boolean;
  };
  /** @inheritdoc */
  getResultLabel(result: any): any;
  /** @inheritdoc */
  getResultCSS(result: any): (string | null)[];
  /**
   * Call the result of the coin flip, marking any coins that matched the called target as a success
   * 3dcc1      Flip 3 coins and treat "heads" as successes
   * 2dcc0      Flip 2 coins and treat "tails" as successes
   * @param {string} modifier     The matched modifier query
   */
  call(modifier: string): false | undefined;
}
/**
 * A type of DiceTerm used to represent rolling a fair n-sided die.
 * @implements {DiceTerm}
 *
 * @example Roll four six-sided dice
 * ```js
 * let die = new Die({faces: 6, number: 4}).evaluate();
 * ```
 */
declare class Die extends DiceTerm implements DiceTerm {
  /** @inheritdoc */
  static MODIFIERS: {
    r: string;
    rr: string;
    x: string;
    xo: string;
    k: string;
    kh: string;
    kl: string;
    d: string;
    dh: string;
    dl: string;
    min: string;
    max: string;
    even: string;
    odd: string;
    cs: string;
    cf: string;
    df: string;
    sf: string;
    ms: string;
  };
  constructor(termData?: {});
  /**
   * Re-roll the Die, rolling additional results for any values which fall within a target set.
   * If no target number is specified, re-roll the lowest possible result.
   *
   * 20d20r         reroll all 1s
   * 20d20r1        reroll all 1s
   * 20d20r=1       reroll all 1s
   * 20d20r1=1      reroll a single 1
   *
   * @param {string} modifier     The matched modifier query
   * @param {boolean} recursive   Reroll recursively, continuing to reroll until the condition is no longer met
   * @returns {boolean|void}      False if the modifier was unmatched
   */
  reroll(modifier: string, { recursive }?: boolean): boolean | void;
  /**
   * @see {@link Die#reroll}
   */
  rerollRecursive(modifier: any): boolean | void;
  /**
   * Explode the Die, rolling additional results for any values which match the target set.
   * If no target number is specified, explode the highest possible result.
   * Explosion can be a "small explode" using a lower-case x or a "big explode" using an upper-case "X"
   *
   * @param {string} modifier     The matched modifier query
   * @param {boolean} recursive   Explode recursively, such that new rolls can also explode?
   */
  explode(modifier: string, { recursive }?: boolean): false | undefined;
  /**
   * @see {@link Die#explode}
   */
  explodeOnce(modifier: any): false | undefined;
  /**
   * Keep a certain number of highest or lowest dice rolls from the result set.
   *
   * 20d20k       Keep the 1 highest die
   * 20d20kh      Keep the 1 highest die
   * 20d20kh10    Keep the 10 highest die
   * 20d20kl      Keep the 1 lowest die
   * 20d20kl10    Keep the 10 lowest die
   *
   * @param {string} modifier     The matched modifier query
   */
  keep(modifier: string): false | undefined;
  /**
   * Drop a certain number of highest or lowest dice rolls from the result set.
   *
   * 20d20d       Drop the 1 lowest die
   * 20d20dh      Drop the 1 highest die
   * 20d20dl      Drop the 1 lowest die
   * 20d20dh10    Drop the 10 highest die
   * 20d20dl10    Drop the 10 lowest die
   *
   * @param {string} modifier     The matched modifier query
   */
  drop(modifier: string): false | undefined;
  /**
   * Count the number of successful results which occurred in a given result set.
   * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
   * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
   *
   * 20d20cs      Count the number of dice which rolled a 20
   * 20d20cs>10   Count the number of dice which rolled higher than 10
   * 20d20cs<10   Count the number of dice which rolled less than 10
   *
   * @param {string} modifier     The matched modifier query
   */
  countSuccess(modifier: string): false | undefined;
  /**
   * Count the number of failed results which occurred in a given result set.
   * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
   * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
   *
   * 6d6cf      Count the number of dice which rolled a 1 as failures
   * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
   * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
   *
   * @param {string} modifier     The matched modifier query
   */
  countFailures(modifier: string): false | undefined;
  /**
   * Count the number of even results which occurred in a given result set.
   * Even numbers are marked as a success and counted as 1
   * Odd numbers are marked as a non-success and counted as 0.
   *
   * 6d6even    Count the number of even numbers rolled
   *
   * @param {string} modifier     The matched modifier query
   */
  countEven(modifier: string): void;
  /**
   * Count the number of odd results which occurred in a given result set.
   * Odd numbers are marked as a success and counted as 1
   * Even numbers are marked as a non-success and counted as 0.
   *
   * 6d6odd    Count the number of odd numbers rolled
   *
   * @param {string} modifier     The matched modifier query
   */
  countOdd(modifier: string): void;
  /**
   * Deduct the number of failures from the dice result, counting each failure as -1
   * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
   * Applying a deduct-failures modifier to the results counts all failed results as -1.
   *
   * 6d6df      Subtract the number of dice which rolled a 1 from the non-failed total.
   * 6d6cs>3df  Subtract the number of dice which rolled a 3 or less from the non-failed count.
   * 6d6cf<3df  Subtract the number of dice which rolled less than 3 from the non-failed count.
   *
   * @param {string} modifier     The matched modifier query
   */
  deductFailures(modifier: string): false | undefined;
  /**
   * Subtract the value of failed dice from the non-failed total, where each failure counts as its negative value.
   * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
   * Applying a deduct-failures modifier to the results counts all failed results as -1.
   *
   * 6d6df<3    Subtract the value of results which rolled less than 3 from the non-failed total.
   *
   * @param {string} modifier     The matched modifier query
   */
  subtractFailures(modifier: string): false | undefined;
  /**
   * Subtract the total value of the DiceTerm from a target value, treating the difference as the final total.
   * Example: 6d6ms>12    Roll 6d6 and subtract 12 from the resulting total.
   * @param {string} modifier     The matched modifier query
   */
  marginSuccess(modifier: string): false | undefined;
  /**
   * Constrain each rolled result to be at least some minimum value.
   * Example: 6d6min2    Roll 6d6, each result must be at least 2
   * @param {string} modifier     The matched modifier query
   */
  minimum(modifier: string): false | undefined;
  /**
   * Constrain each rolled result to be at most some maximum value.
   * Example: 6d6max5    Roll 6d6, each result must be at most 5
   * @param {string} modifier     The matched modifier query
   */
  maximum(modifier: string): false | undefined;
}
/**
 * A type of DiceTerm used to represent a three-sided Fate/Fudge die.
 * Mathematically behaves like 1d3-2
 * @extends {DiceTerm}
 */
declare class FateDie extends DiceTerm {
  /** @inheritdoc */
  static MODIFIERS: {
    r: (modifier: string, { recursive }?: boolean) => boolean | void;
    rr: (modifier: any) => boolean | void;
    k: (modifier: string) => false | undefined;
    kh: (modifier: string) => false | undefined;
    kl: (modifier: string) => false | undefined;
    d: (modifier: string) => false | undefined;
    dh: (modifier: string) => false | undefined;
    dl: (modifier: string) => false | undefined;
  };
  constructor(termData: any);
  /** @inheritdoc */
  roll({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): {
    result: undefined;
    active: boolean;
  };
  /** @inheritdoc */
  getResultLabel(result: any): any;
}
/**
 * An interface and API for constructing and evaluating dice rolls.
 * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
 *
 * @param {string} formula    The string formula to parse
 * @param {object} data       The data object against which to parse attributes within the formula
 *
 * @example Attack with advantage
 * ```js
 * // Construct the Roll instance
 * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
 *
 * // The parsed terms of the roll formula
 * console.log(r.terms);    // [Die, OperatorTerm, NumericTerm, OperatorTerm, NumericTerm]
 *
 * // Execute the roll
 * await r.evaluate();
 *
 * // The resulting equation after it was rolled
 * console.log(r.result);   // 16 + 2 + 4
 *
 * // The total resulting from the roll
 * console.log(r.total);    // 22
 * ```
 */
declare class Roll {
  /**
   * A Proxy environment for safely evaluating a string using only available Math functions
   * @type {Math}
   */
  static MATH_PROXY: Math;
  /**
   * The HTML template path used to render a complete Roll object to the chat log
   * @type {string}
   */
  static CHAT_TEMPLATE: string;
  /**
   * The HTML template used to render an expanded Roll tooltip to the chat log
   * @type {string}
   */
  static TOOLTIP_TEMPLATE: string;
  /**
   * A factory method which constructs a Roll instance using the default configured Roll class.
   * @param {string} formula        The formula used to create the Roll instance
   * @param {object} [data={}]      The data object which provides component data for the formula
   * @param {object} [options={}]   Additional options which modify or describe this Roll
   * @return {Roll}                 The constructed Roll instance
   */
  static create(
    formula: string,
    data?: object | undefined,
    options?: object | undefined
  ): Roll;
  /**
   * Get the default configured Roll class.
   * @returns {typeof Roll}
   */
  static get defaultImplementation(): typeof Roll;
  /**
   * Transform an array of RollTerm objects into a cleaned string formula representation.
   * @param {RollTerm[]} terms      An array of terms to represent as a formula
   * @returns {string}              The string representation of the formula
   */
  static getFormula(terms: RollTerm[]): string;
  /**
   * A sandbox-safe evaluation function to execute user-input code with access to scoped Math methods.
   * @param {string} expression   The input string expression
   * @returns {number}            The numeric evaluated result
   */
  static safeEval(expression: string): number;
  /**
   * After parenthetical and arithmetic terms have been resolved, we need to simplify the remaining expression.
   * Any remaining string terms need to be combined with adjacent non-operators in order to construct parsable terms.
   * @param {RollTerm[]} terms      An array of terms which is eligible for simplification
   * @returns {RollTerm[]}          An array of simplified terms
   */
  static simplifyTerms(terms: RollTerm[]): RollTerm[];
  /**
   * Simulate a roll and evaluate the distribution of returned results
   * @param {string} formula      The Roll expression to simulate
   * @param {number} n            The number of simulations
   * @return {Promise<number[]>}  The rolled totals
   */
  static simulate(formula: string, n?: number): Promise<number[]>;
  /**
   * Parse a formula by following an order of operations:
   *
   * Step 1: Replace formula data
   * Step 2: Split outer-most parenthetical groups
   * Step 3: Further split outer-most dice pool groups
   * Step 4: Further split string terms on arithmetic operators
   * Step 5: Classify all remaining strings
   *
   * @param {string} formula      The original string expression to parse
   * @param {object} data         A data object used to substitute for attributes in the formula
   * @returns {RollTerm[]}        A parsed array of RollTerm instances
   */
  static parse(formula: string, data: object): RollTerm[];
  /**
   * Replace referenced data attributes in the roll formula with values from the provided data.
   * Data references in the formula use the @attr syntax and would reference the corresponding attr key.
   *
   * @param {string} formula          The original formula within which to replace
   * @param {object} data             The data object which provides replacements
   * @param {string} [missing]        The value that should be assigned to any unmatched keys.
   *                                  If null, the unmatched key is left as-is.
   * @param {boolean} [warn]          Display a warning notification when encountering an un-matched key.
   * @static
   */
  static replaceFormulaData(
    formula: string,
    data: object,
    { missing, warn }?: string | undefined
  ): string;
  /**
   * Validate that a provided roll formula can represent a valid
   * @param {string} formula    A candidate formula to validate
   * @return {boolean}          Is the provided input a valid dice formula?
   */
  static validate(formula: string): boolean;
  /**
   * Split a formula by identifying its outer-most parenthetical and math terms
   * @param {string} _formula      The raw formula to split
   * @returns {string[]}          An array of terms, split on parenthetical terms
   * @private
   */
  private static _splitParentheses;
  /**
   * Handle closing of a parenthetical term to create a MathTerm expression with a function and arguments
   * @returns {MathTerm[]}
   * @private
   */
  private static _splitMathArgs;
  /**
   * Split a formula by identifying its outer-most dice pool terms
   * @param {string} _formula      The raw formula to split
   * @returns {string[]}          An array of terms, split on parenthetical terms
   * @private
   */
  private static _splitPools;
  /**
   * Split a formula by identifying its outer-most groups using a certain group symbol like parentheses or brackets.
   * @param {string} _formula     The raw formula to split
   * @param {object} options      Options that configure how groups are split
   * @returns {string[]}          An array of terms, split on dice pool terms
   * @private
   */
  private static _splitGroup;
  /**
   * Split a formula by identifying arithmetic terms
   * @param {string} _formula                 The raw formula to split
   * @returns {Array<(string|OperatorTerm)>}  An array of terms, split on arithmetic operators
   * @private
   */
  private static _splitOperators;
  /**
   * Temporarily remove flavor text from a string formula allowing it to be accurately parsed.
   * @param {string} formula                        The formula to extract
   * @returns {{formula: string, flavors: object}}  The cleaned formula and extracted flavor mapping
   * @private
   */
  private static _extractFlavors;
  /**
   * Restore flavor text to a string term
   * @param {string} term         The string term possibly containing flavor symbols
   * @param {object} flavors      The extracted flavors object
   * @returns {string}            The restored term containing flavor text
   * @private
   */
  private static _restoreFlavor;
  /**
   * Classify a remaining string term into a recognized RollTerm class
   * @param {string} term         A remaining un-classified string
   * @param {object} [options={}] Options which customize classification
   * @param {boolean} [options.intermediate=true]  Allow intermediate terms
   * @param {RollTerm|string} [options.prior]       The prior classified term
   * @param {RollTerm|string} [options.next]        The next term to classify
   * @returns {RollTerm}          A classified RollTerm instance
   * @internal
   */
  static _classifyStringTerm(
    term: string,
    {
      intermediate,
      prior,
      next,
    }?:
      | {
          intermediate?: boolean | undefined;
          prior?: string | RollTerm | undefined;
          next?: string | RollTerm | undefined;
        }
      | undefined
  ): RollTerm;
  /**
   * Expand an inline roll element to display it's contained dice result as a tooltip
   * @param {HTMLAnchorElement} a     The inline-roll button
   * @returns {Promise<void>}
   */
  static expandInlineResult(a: HTMLAnchorElement): Promise<void>;
  /**
   * Collapse an expanded inline roll to conceal it's tooltip
   * @param {HTMLAnchorElement} a     The inline-roll button
   */
  static collapseInlineResult(a: HTMLAnchorElement): void;
  /**
   * Recreate a Roll instance using a provided data object
   * @param {object} data   Unpacked data representing the Roll
   * @returns {Roll}         A reconstructed Roll instance
   */
  static fromData(data: object): Roll;
  /**
   * Recreate a Roll instance using a provided JSON string
   * @param {string} json   Serialized JSON data representing the Roll
   * @returns {Roll}        A reconstructed Roll instance
   */
  static fromJSON(json: string): Roll;
  /**
   * Manually construct a Roll object by providing an explicit set of input terms
   * @param {RollTerm[]} terms      The array of terms to use as the basis for the Roll
   * @param {object} [options={}]   Additional options passed to the Roll constructor
   * @returns {Roll}                The constructed Roll instance
   *
   * @example Construct a Roll instance from an array of component terms
   * ```js
   * const t1 = new Die({number: 4, faces: 8};
   * const plus = new OperatorTerm({operator: "+"});
   * const t2 = new NumericTerm({number: 8});
   * const roll = Roll.fromTerms([t1, plus, t2]);
   * roll.formula; // 4d8 + 8
   * ```
   */
  static fromTerms(terms: RollTerm[], options?: object | undefined): Roll;
  constructor(formula: any, data?: {}, options?: {});
  /**
   * The original provided data object which substitutes into attributes of the roll formula
   * @type {Object}
   */
  data: Object;
  /**
   * Options which modify or describe the Roll
   * @type {object}
   */
  options: object;
  /**
   * The identified terms of the Roll
   * @type {RollTerm[]}
   */
  terms: RollTerm[];
  /**
   * An array of inner DiceTerms which were evaluated as part of the Roll evaluation
   * @type {DiceTerm[]}
   */
  _dice: DiceTerm[];
  /**
   * Store the original cleaned formula for the Roll, prior to any internal evaluation or simplification
   * @type {string}
   */
  _formula: string;
  /**
   * Track whether this Roll instance has been evaluated or not. Once evaluated the Roll is immutable.
   * @type {boolean}
   */
  _evaluated: boolean;
  /**
   * Cache the numeric total generated through evaluation of the Roll.
   * @type {number}
   * @private
   */
  private _total;
  /**
   * Prepare the data structure used for the Roll.
   * This is factored out to allow for custom Roll classes to do special data preparation using provided input.
   * @param {object} data   Provided roll data
   * @returns {object}      The prepared data object
   * @protected
   */
  protected _prepareData(data: object): object;
  /**
   * Return an Array of the individual DiceTerm instances contained within this Roll.
   * @return {DiceTerm[]}
   */
  get dice(): DiceTerm[];
  /**
   * Return a standardized representation for the displayed formula associated with this Roll.
   * @return {string}
   */
  get formula(): string;
  /**
   * The resulting arithmetic expression after rolls have been evaluated
   * @return {string}
   */
  get result(): string;
  /**
   * Return the total result of the Roll expression if it has been evaluated.
   * @type {number}
   */
  get total(): number;
  /**
   * Whether this Roll contains entirely deterministic terms or whether there is some randomness.
   * @type {boolean}
   */
  get isDeterministic(): boolean;
  /**
   * Alter the Roll expression by adding or multiplying the number of dice which are rolled
   * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
   * @param {number} add        A number of dice to add. Dice are added after multiplication.
   * @param {boolean} [multiplyNumeric]  Apply multiplication factor to numeric scalar terms
   * @return {Roll}             The altered Roll expression
   */
  alter(
    multiply: number,
    add: number,
    { multiplyNumeric }?: boolean | undefined
  ): Roll;
  /**
   * Clone the Roll instance, returning a new Roll instance that has not yet been evaluated.
   * @return {Roll}
   */
  clone(): Roll;
  /**
   * Execute the Roll, replacing dice and evaluating the total result
   * @param {object} [options={}]     Options which inform how the Roll is evaluated
   * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
   * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
   * @param {boolean} [options.async=true]        Evaluate the roll asynchronously, receiving a Promise as the returned value.
   *                                              This will become the default behavior in version 10.x
   * @returns {Roll|Promise<Roll>}    The evaluated Roll instance
   *
   * @example Evaluate a Roll expression
   * ```js
   * let r = new Roll("2d6 + 4 + 1d4");
   * await r.evaluate();
   * console.log(r.result); // 5 + 4 + 2
   * console.log(r.total);  // 11
   * ```
   */
  evaluate({
    minimize,
    maximize,
    async,
  }?:
    | {
        minimize?: boolean | undefined;
        maximize?: boolean | undefined;
        async?: boolean | undefined;
      }
    | undefined): Roll | Promise<Roll>;
  /**
   * Evaluate the roll asynchronously.
   * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
   * @param {object} [options]      Options which inform how evaluation is performed
   * @param {boolean} [options.minimize]    Force the result to be minimized
   * @param {boolean} [options.maximize]    Force the result to be maximized
   * @returns {Promise<Roll>}
   * @private
   */
  private _evaluate;
  /**
   * Evaluate the roll synchronously.
   * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
   * @param {object} [options]      Options which inform how evaluation is performed
   * @param {boolean} [options.minimize]    Force the result to be minimized
   * @param {boolean} [options.maximize]    Force the result to be maximized
   * @returns {Roll}
   * @private
   */
  private _evaluateSync;
  /**
   * Safely evaluate the final total result for the Roll using its component terms.
   * @returns {number}    The evaluated total
   * @private
   */
  private _evaluateTotal;
  /**
   * Alias for evaluate.
   * @see {Roll#evaluate}
   */
  roll(options?: {}): Roll | Promise<Roll>;
  /**
   * Create a new Roll object using the original provided formula and data.
   * Each roll is immutable, so this method returns a new Roll instance using the same data.
   * @param {object} [options={}]     Evaluation options passed to Roll#evaluate
   * @return {Roll}                   A new Roll object, rolled using the same formula and data
   */
  reroll(options?: object | undefined): Roll;
  /**
   * Render the tooltip HTML for a Roll instance
   * @return {Promise<string>}      The rendered HTML tooltip as a string
   */
  getTooltip(): Promise<string>;
  /**
   * Render a Roll instance to HTML
   * @param {object} [options={}]               Options which affect how the Roll is rendered
   * @param {string} [options.flavor]             Flavor text to include
   * @param {string} [options.template]           A custom HTML template path
   * @param {boolean} [options.isPrivate=false]   Is the Roll displayed privately?
   * @returns {Promise<string>}                 The rendered HTML template as a string
   */
  render({
    flavor,
    template,
    isPrivate,
  }?:
    | {
        flavor?: string | undefined;
        template?: string | undefined;
        isPrivate?: boolean | undefined;
      }
    | undefined): Promise<string>;
  /**
   * Transform a Roll instance into a ChatMessage, displaying the roll result.
   * This function can either create the ChatMessage directly, or return the data object that will be used to create.
   *
   * @param {object} messageData          The data object to use when creating the message
   * @param {options} [options]           Additional options which modify the created message.
   * @param {string} [options.rollMode]   The template roll mode to use for the message from CONFIG.Dice.rollModes
   * @param {boolean} [options.create=true]   Whether to automatically create the chat message, or only return the
   *                                          prepared chatData object.
   * @returns {Promise<ChatMessage|object>} A promise which resolves to the created ChatMessage document if create is
   *                                        true, or the Object of prepared chatData otherwise.
   */
  toMessage(
    messageData?: object,
    { rollMode, create }?: any
  ): Promise<ChatMessage | object>;
  /**
   * Construct an inline roll link for this Roll.
   * @param {object} [options]                  Additional options to configure how the link is constructed.
   * @param {string} [options.label]            A custom label for the total.
   * @param {object<string>} [options.attrs]    Attributes to set on the link.
   * @param {object<string>} [options.dataset]  Custom data- attributes to set on the link.
   * @param {string[]} [options.classes]        Classes to add to the link.
   * @param {string} [options.icon]             A font-awesome icon class to use as the icon instead of a d20.
   * @returns {HTMLAnchorElement}
   */
  toAnchor({
    attrs,
    dataset,
    classes,
    label,
    icon,
  }?:
    | {
        label?: string | undefined;
      }
    | undefined): HTMLAnchorElement;
  /**
   * Represent the data of the Roll as an object suitable for JSON serialization.
   * @returns {object}     Structured data which can be serialized into JSON
   */
  toJSON(): object;
}
/**
 * An abstract class which represents a single token that can be used as part of a Roll formula.
 * Every portion of a Roll formula is parsed into a subclass of RollTerm in order for the Roll to be fully evaluated.
 */
declare class RollTerm {
  /**
   * A regular expression pattern which identifies optional term-level flavor text
   * @type {string}
   */
  static FLAVOR_REGEXP_STRING: string;
  /**
   * A regular expression which identifies term-level flavor text
   * @type {RegExp}
   */
  static FLAVOR_REGEXP: RegExp;
  /**
   * A regular expression used to match a term of this type
   * @type {RegExp}
   */
  static REGEXP: RegExp;
  /**
   * An array of additional attributes which should be retained when the term is serialized
   * @type {string[]}
   */
  static SERIALIZE_ATTRIBUTES: string[];
  /**
   * Construct a RollTerm from a provided data object
   * @param {object} data         Provided data from an un-serialized term
   * @return {RollTerm}           The constructed RollTerm
   */
  static fromData(data: object): RollTerm;
  /**
   * Define term-specific logic for how a de-serialized data object is restored as a functional RollTerm
   * @param {object} data         The de-serialized term data
   * @returns {RollTerm}          The re-constructed RollTerm object
   * @protected
   */
  protected static _fromData(data: object): RollTerm;
  /**
   * Reconstruct a RollTerm instance from a provided JSON string
   * @param {string} json   A serialized JSON representation of a DiceTerm
   * @return {RollTerm}     A reconstructed RollTerm from the provided JSON
   */
  static fromJSON(json: string): RollTerm;
  constructor({ options }?: { options?: {} | undefined });
  /**
   * An object of additional options which describes and modifies the term.
   * @type {object}
   */
  options: object;
  /**
   * An internal flag for whether the term has been evaluated
   * @type {boolean}
   */
  _evaluated: boolean;
  /**
   * Is this term intermediate, and should be evaluated first as part of the simplification process?
   * @type {boolean}
   */
  isIntermediate: boolean;
  /**
   * A string representation of the formula expression for this RollTerm, prior to evaluation.
   * @type {string}
   */
  get expression(): string;
  /**
   * A string representation of the formula, including optional flavor text.
   * @type {string}
   */
  get formula(): string;
  /**
   * A string or numeric representation of the final output for this term, after evaluation.
   * @type {number|string}
   */
  get total(): string | number;
  /**
   * Optional flavor text which modifies and describes this term.
   * @type {string}
   */
  get flavor(): string;
  /**
   * Whether this term is entirely deterministic or contains some randomness.
   * @type {boolean}
   */
  get isDeterministic(): boolean;
  /**
   * Evaluate the term, processing its inputs and finalizing its total.
   * @param {object} [options={}]           Options which modify how the RollTerm is evaluated
   * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
   * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
   * @param {boolean} [options.async=false]       Evaluate the term asynchronously, receiving a Promise as the returned value.
   *                                              This will become the default behavior in version 10.x
   * @returns {RollTerm}                     The evaluated RollTerm
   */
  evaluate({
    minimize,
    maximize,
    async,
  }?:
    | {
        minimize?: boolean | undefined;
        maximize?: boolean | undefined;
        async?: boolean | undefined;
      }
    | undefined): RollTerm;
  /**
   * Evaluate the term.
   * @param {object} [options={}]           Options which modify how the RollTerm is evaluated, see RollTerm#evaluate
   * @returns {Promise<RollTerm>}
   * @private
   */
  private _evaluate;
  /**
   * This method is temporarily factored out in order to provide different behaviors synchronous evaluation.
   * This will be removed in 0.10.x
   * @private
   */
  private _evaluateSync;
  /**
   * Serialize the RollTerm to a JSON string which allows it to be saved in the database or embedded in text.
   * This method should return an object suitable for passing to the JSON.stringify function.
   * @return {object}
   */
  toJSON(): object;
}
/**
 * @typedef {Object} DiceTermResult
 * @property {number} result        The numeric result
 * @property {boolean} [active]     Is this result active, contributing to the total?
 * @property {number} [count]       A value that the result counts as, otherwise the result is not used directly as
 * @property {boolean} [success]    Does this result denote a success?
 * @property {boolean} [failure]    Does this result denote a failure?
 * @property {boolean} [discarded]  Was this result discarded?
 * @property {boolean} [rerolled]   Was this result rerolled?
 * @property {boolean} [exploded]   Was this result exploded?
 */
/**
 * An abstract base class for any type of RollTerm which involves randomized input from dice, coins, or other devices.
 * @extends RollTerm
 *
 * @param {object} termData                 Data used to create the Dice Term, including the following:
 * @param {number} [termData.number=1]      The number of dice of this term to roll, before modifiers are applied
 * @param {number} termData.faces           The number of faces on each die of this type
 * @param {string[]} [termData.modifiers]   An array of modifiers applied to the results
 * @param {object[]} [termData.results]     An optional array of pre-cast results for the term
 * @param {object} [termData.options]       Additional options that modify the term
 */
declare class DiceTerm extends RollTerm {
  /**
   * Define the denomination string used to register this DiceTerm type in CONFIG.Dice.terms
   * @type {string}
   */
  static DENOMINATION: string;
  /**
   * Define the named modifiers that can be applied for this particular DiceTerm type.
   * @type {{string: (string|Function)}}
   */
  static MODIFIERS: {
    string: string | Function;
  };
  /**
   * A regular expression pattern which captures the full set of term modifiers
   * Anything until a space, group symbol, or arithmetic operator
   * @type {string}
   */
  static MODIFIERS_REGEXP_STRING: string;
  /**
   * A regular expression used to separate individual modifiers
   * @type {RegExp}
   */
  static MODIFIER_REGEXP: RegExp;
  /**
   * A helper comparison function.
   * Returns a boolean depending on whether the result compares favorably against the target.
   * @param {number} result         The result being compared
   * @param {string} comparison     The comparison operator in [=,&lt;,&lt;=,>,>=]
   * @param {number} target         The target value
   * @return {boolean}              Is the comparison true?
   */
  static compareResult(
    result: number,
    comparison: string,
    target: number
  ): boolean;
  /**
   * A helper method to modify the results array of a dice term by flagging certain results are kept or dropped.
   * @param {object[]} results      The results array
   * @param {number} number         The number to keep or drop
   * @param {boolean} [keep]        Keep results?
   * @param {boolean} [highest]     Keep the highest?
   * @return {object[]}             The modified results array
   */
  static _keepOrDrop(
    results: object[],
    number: number,
    { keep, highest }?: boolean | undefined
  ): object[];
  /**
   * A reusable helper function to handle the identification and deduction of failures
   */
  static _applyCount(
    results: any,
    comparison: any,
    target: any,
    {
      flagSuccess,
      flagFailure,
    }?: {
      flagSuccess?: boolean | undefined;
      flagFailure?: boolean | undefined;
    }
  ): void;
  /**
   * A reusable helper function to handle the identification and deduction of failures
   */
  static _applyDeduct(
    results: any,
    comparison: any,
    target: any,
    {
      deductFailure,
      invertFailure,
    }?: {
      deductFailure?: boolean | undefined;
      invertFailure?: boolean | undefined;
    }
  ): void;
  /**
   * Determine whether a string expression matches this type of term
   * @param {string} expression               The expression to parse
   * @param {object} [options={}]             Additional options which customize the match
   * @param {boolean} [options.imputeNumber=true]  Allow the number of dice to be optional, i.e. "d6"
   * @return {RegExpMatchArray|null}
   */
  static matchTerm(
    expression: string,
    {
      imputeNumber,
    }?:
      | {
          imputeNumber?: boolean | undefined;
        }
      | undefined
  ): RegExpMatchArray | null;
  /**
   * Construct a term of this type given a matched regular expression array.
   * @param {RegExpMatchArray} match          The matched regular expression array
   * @return {DiceTerm}                      The constructed term
   */
  static fromMatch(match: RegExpMatchArray): DiceTerm;
  constructor({
    number,
    faces,
    modifiers,
    results,
    options,
  }: {
    number?: number | undefined;
    faces?: number | undefined;
    modifiers?: any[] | undefined;
    results?: any[] | undefined;
    options?: {} | undefined;
  });
  /**
   * The number of dice of this term to roll, before modifiers are applied
   * @type {number}
   */
  number: number;
  /**
   * The number of faces on the die
   * @type {number}
   */
  faces: number;
  /**
   * An Array of dice term modifiers which are applied
   * @type {string[]}
   */
  modifiers: string[];
  /**
   * The array of dice term results which have been rolled
   * @type {DiceTermResult[]}
   */
  results: DiceTermResult[];
  /** @inheritdoc */
  get total(): number | undefined;
  /**
   * Return an array of rolled values which are still active within this term
   * @type {number[]}
   */
  get values(): number[];
  /**
   * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
   * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
   * @param {number} add        A number of dice to add. Dice are added after multiplication.
   * @return {DiceTerm}         The altered term
   */
  alter(multiply: number, add: number): DiceTerm;
  /** @inheritdoc */
  _evaluateSync({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): DiceTerm;
  /**
   * Roll the DiceTerm by mapping a random uniform draw against the faces of the dice term.
   * @param {object} [options={}]           Options which modify how a random result is produced
   * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
   * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
   * @return {DiceTermResult}               The produced result
   */
  roll({
    minimize,
    maximize,
  }?:
    | {
        minimize?: boolean | undefined;
        maximize?: boolean | undefined;
      }
    | undefined): DiceTermResult;
  /**
   * Return a string used as the label for each rolled result
   * @param {DiceTermResult} result     The rolled result
   * @return {string}                   The result label
   */
  getResultLabel(result: DiceTermResult): string;
  /**
   * Get the CSS classes that should be used to display each rolled result
   * @param {DiceTermResult} result     The rolled result
   * @return {string[]}                 The desired classes
   */
  getResultCSS(result: DiceTermResult): string[];
  /**
   * Render the tooltip HTML for a Roll instance
   * @return {object}      The data object used to render the default tooltip template for this DiceTerm
   */
  getTooltipData(): object;
  /**
   * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
   * Augment or modify the results array.
   * @private
   */
  private _evaluateModifiers;
  /**
   * Evaluate a single modifier command, recording it in the array of evaluated modifiers
   * @param {string} command        The parsed modifier command
   * @param {string} modifier       The full modifier request
   * @private
   */
  private _evaluateModifier;
}
type DiceTermResult = {
  /**
   * The numeric result
   */
  result: number;
  /**
   * Is this result active, contributing to the total?
   */
  active?: boolean | undefined;
  /**
   * A value that the result counts as, otherwise the result is not used directly as
   */
  count?: number | undefined;
  /**
   * Does this result denote a success?
   */
  success?: boolean | undefined;
  /**
   * Does this result denote a failure?
   */
  failure?: boolean | undefined;
  /**
   * Was this result discarded?
   */
  discarded?: boolean | undefined;
  /**
   * Was this result rerolled?
   */
  rerolled?: boolean | undefined;
  /**
   * Was this result exploded?
   */
  exploded?: boolean | undefined;
};
/**
 * A type of RollTerm used to apply a function from the Math library.
 * @extends {RollTerm}
 */
declare class MathTerm extends RollTerm {
  constructor({
    fn,
    terms,
    options,
  }?: {
    fn: any;
    terms?: any[] | undefined;
    options: any;
  });
  /**
   * The named function in the Math environment which should be applied to the term
   * @type {string}
   */
  fn: string;
  /**
   * An array of string argument terms for the function
   * @type {string[]}
   */
  terms: string[];
  /**
   * The cached Roll instances for each function argument
   * @type {Roll[]}
   */
  rolls: Roll[];
  /**
   * The cached result of evaluating the method arguments
   * @type {number}
   */
  result: number;
  /**
   * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
   * @type {DiceTerm[]}
   */
  get dice(): DiceTerm[];
  /** @inheritdoc */
  get total(): number;
  /** @inheritdoc */
  _evaluateSync({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): MathTerm;
  /** @inheritdoc */
  _evaluate({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): Promise<MathTerm>;
}
/**
 * A type of RollTerm used to represent static numbers.
 * @extends {RollTerm}
 */
declare class NumericTerm extends RollTerm {
  /**
   * Determine whether a string expression matches a NumericTerm
   * @param {string} expression               The expression to parse
   * @return {RegExpMatchArray|null}
   */
  static matchTerm(expression: string): RegExpMatchArray | null;
  /**
   * Construct a term of this type given a matched regular expression array.
   * @param {RegExpMatchArray} match          The matched regular expression array
   * @return {NumericTerm}                    The constructed term
   */
  static fromMatch(match: RegExpMatchArray): NumericTerm;
  constructor({ number, options }?: { number: any; options: any });
  number: number;
  /** @inheritdoc */
  get total(): number;
}
/**
 * A type of RollTerm used to denote and perform an arithmetic operation.
 * @extends {RollTerm}
 */
declare class OperatorTerm extends RollTerm {
  /**
   * An array of operators which represent arithmetic operations
   * @type {string[]}
   */
  static OPERATORS: string[];
  constructor({ operator, options }?: { operator: any; options: any });
  operator: any;
  /** @inheritdoc */
  get total(): string;
}
/**
 * A type of RollTerm used to enclose a parenthetical expression to be recursively evaluated.
 * @extends {RollTerm}
 */
declare class ParentheticalTerm extends RollTerm {
  /**
   * The regular expression pattern used to identify the opening of a parenthetical expression.
   * This could also identify the opening of a math function.
   * @type {RegExp}
   */
  static OPEN_REGEXP: RegExp;
  /**
   * A regular expression pattern used to identify the closing of a parenthetical expression.
   * @type {RegExp}
   */
  static CLOSE_REGEXP: RegExp;
  /**
   * Construct a ParentheticalTerm from an Array of component terms which should be wrapped inside the parentheses.
   * @param {RollTerm[]} terms      The array of terms to use as internal parts of the parenthetical
   * @param {object} [options={}]   Additional options passed to the ParentheticalTerm constructor
   * @returns {ParentheticalTerm}   The constructed ParentheticalTerm instance
   *
   * @example Create a Parenthetical Term from an array of component RollTerm instances
   * ```js
   * const d6 = new Die({number: 4, faces: 6});
   * const plus = new OperatorTerm({operator: "+"});
   * const bonus = new NumericTerm({number: 4});
   * t = ParentheticalTerm.fromTerms([d6, plus, bonus]);
   * t.formula; // (4d6 + 4)
   * ```
   */
  static fromTerms(
    terms: RollTerm[],
    options?: object | undefined
  ): ParentheticalTerm;
  constructor({ term, roll, options }: { term: any; roll: any; options: any });
  /**
   * The original provided string term used to construct the parenthetical
   * @type {string}
   */
  term: string;
  /**
   * Alternatively, an already-evaluated Roll instance may be passed directly
   * @type {Roll}
   */
  roll: Roll;
  /**
   * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
   * @type {DiceTerm[]}
   */
  get dice(): DiceTerm[];
  /** @inheritdoc */
  get total(): number;
  /** @inheritdoc */
  _evaluateSync({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): ParentheticalTerm;
  /** @inheritdoc */
  _evaluate({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): Promise<ParentheticalTerm>;
}
/**
 * A type of RollTerm which encloses a pool of multiple inner Rolls which are evaluated jointly.
 *
 * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total
 * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any
 * success count or margin.
 *
 * @example Keep the highest of the 3 roll expressions
 * ```js
 * let pool = new PoolTerm({
 *   rolls: ["4d6", "3d8 - 1", "2d10 + 3"],
 *   modifiers: ["kh"]
 * });
 * pool.evaluate();
 * ```
 */
declare class PoolTerm extends RollTerm {
  /**
   * Define the modifiers that can be used for this particular DiceTerm type.
   * @type {Object<string, Function>}
   */
  static MODIFIERS: {
    [x: string]: Function;
  };
  /**
   * The regular expression pattern used to identify the opening of a dice pool expression.
   * @type {RegExp}
   */
  static OPEN_REGEXP: RegExp;
  /**
   * A regular expression pattern used to identify the closing of a dice pool expression.
   * @type {RegExp}
   */
  static CLOSE_REGEXP: RegExp;
  /** @inheritdoc */
  static _fromData(data: any): RollTerm;
  /**
   * Given a string formula, create and return an evaluated PoolTerm object
   * @param {string} formula    The string formula to parse
   * @param {object} [options]  Additional options applied to the PoolTerm
   * @return {PoolTerm|null}    The evaluated PoolTerm object or null if the formula is invalid
   */
  static fromExpression(
    formula: string,
    options?: object | undefined
  ): PoolTerm | null;
  /**
   * Create a PoolTerm by providing an array of existing Roll objects
   * @param {Roll[]} rolls      An array of Roll objects from which to create the pool
   * @returns {RollTerm}        The constructed PoolTerm comprised of the provided rolls
   */
  static fromRolls(rolls?: Roll[]): RollTerm;
  constructor({
    terms,
    modifiers,
    rolls,
    results,
    options,
  }?: {
    terms?: any[] | undefined;
    modifiers?: any[] | undefined;
    rolls?: any[] | undefined;
    results?: any[] | undefined;
    options?: {} | undefined;
  });
  /**
   * The original provided terms to the Dice Pool
   * @type {string[]}
   */
  terms: string[];
  /**
   * The string modifiers applied to resolve the pool
   * @type {string[]}
   */
  modifiers: string[];
  /**
   * Each component term of a dice pool is evaluated as a Roll instance
   * @type {Roll[]}
   */
  rolls: Roll[];
  /**
   * The array of dice pool results which have been rolled
   * @type {DiceTermResult[]}
   */
  results: DiceTermResult[];
  /**
   * Return an Array of each individual DiceTerm instances contained within the PoolTerm.
   * @return {DiceTerm[]}
   */
  get dice(): DiceTerm[];
  /** @inheritdoc */
  get total(): number | undefined;
  /**
   * Return an array of rolled values which are still active within the PoolTerm
   * @type {number[]}
   */
  get values(): number[];
  /**
   * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
   * @param {any[]} args        Arguments passed to each contained Roll#alter method.
   * @return {PoolTerm}         The altered pool
   */
  alter(...args: any[]): PoolTerm;
  /** @inheritdoc */
  _evaluateSync({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): PoolTerm;
  /** @inheritdoc */
  _evaluate({
    minimize,
    maximize,
  }?: {
    minimize?: boolean | undefined;
    maximize?: boolean | undefined;
  }): Promise<PoolTerm>;
  /**
   * Use the same logic as for the DiceTerm to avoid duplication
   * @see DiceTerm#_evaluateModifiers
   */
  _evaluateModifiers(): void;
  /**
   * Use the same logic as for the DiceTerm to avoid duplication
   * @see DiceTerm#_evaluateModifier
   */
  _evaluateModifier(command: any, modifier: any): void;
  /**
   * Keep a certain number of highest or lowest dice rolls from the result set.
   *
   * {1d6,1d8,1d10,1d12}kh2       Keep the 2 best rolls from the pool
   * {1d12,6}kl                   Keep the lowest result in the pool
   *
   * @param {string} modifier     The matched modifier query
   */
  keep(modifier: string): false | undefined;
  /**
   * Keep a certain number of highest or lowest dice rolls from the result set.
   *
   * {1d6,1d8,1d10,1d12}dl3       Drop the 3 worst results in the pool
   * {1d12,6}dh                   Drop the highest result in the pool
   *
   * @param {string} modifier     The matched modifier query
   */
  drop(modifier: string): false | undefined;
  /**
   * Count the number of successful results which occurred in the pool.
   * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
   * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
   *
   * 20d20cs      Count the number of dice which rolled a 20
   * 20d20cs>10   Count the number of dice which rolled higher than 10
   * 20d20cs<10   Count the number of dice which rolled less than 10
   *
   * @param {string} modifier     The matched modifier query
   */
  countSuccess(modifier: string): false | undefined;
  /**
   * Count the number of failed results which occurred in a given result set.
   * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
   * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
   *
   * 6d6cf      Count the number of dice which rolled a 1 as failures
   * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
   * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
   *
   * @param {string} modifier     The matched modifier query
   */
  countFailures(modifier: string): false | undefined;
}
/**
 * A type of RollTerm used to represent strings which have not yet been matched.
 * @extends {RollTerm}
 */
declare class StringTerm extends RollTerm {
  constructor({ term, options }?: { term: any; options: any });
  term: any;
  /** @inheritdoc */
  get expression(): any;
  /** @inheritdoc */
  get total(): any;
  /** @inheritdoc */
  evaluate(options?: {}): void;
}
/**
 * A standalone, pure JavaScript implementation of the Mersenne Twister pseudo random number generator.
 *
 * @author Raphael Pigulla <pigulla@four66.com>
 * @version 0.2.3
 * @license
 * Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
declare class MersenneTwister {
  /**
   * A factory method for generating random uniform rolls
   * @returns {number}
   */
  static random(): number;
  /**
   * A factory method for generating random normal rolls
   * @return {number}
   */
  static normal(...args: any[]): number;
  /**
   * Instantiates a new Mersenne Twister.
   * @param {number} [seed]   The initial seed value, if not provided the current timestamp will be used.
   * @constructor
   */
  constructor(seed?: number | undefined);
  MAX_INT: number;
  N: number;
  M: number;
  UPPER_MASK: number;
  LOWER_MASK: number;
  MATRIX_A: number;
  mt: any[];
  mti: number;
  SEED: number;
  /**
   * Initializes the state vector by using one unsigned 32-bit integer "seed", which may be zero.
   *
   * @since 0.1.0
   * @param {number} seed The seed value.
   */
  seed(seed: number): number;
  /**
   * Initializes the state vector by using an array key[] of unsigned 32-bit integers of the specified length. If
   * length is smaller than 624, then each array of 32-bit integers gives distinct initial state vector. This is
   * useful if you want a larger seed space than 32-bit word.
   *
   * @since 0.1.0
   * @param {array} vector The seed vector.
   */
  seedArray(vector: array): void;
  /**
   * Generates a random unsigned 32-bit integer.
   *
   * @since 0.1.0
   * @returns {number}
   */
  int(): number;
  /**
   * Generates a random unsigned 31-bit integer.
   *
   * @since 0.1.0
   * @returns {number}
   */
  int31(): number;
  /**
   * Generates a random real in the interval [0;1] with 32-bit resolution.
   *
   * @since 0.1.0
   * @returns {number}
   */
  real(): number;
  /**
   * Generates a random real in the interval ]0;1[ with 32-bit resolution.
   *
   * @since 0.1.0
   * @returns {number}
   */
  realx(): number;
  /**
   * Generates a random real in the interval [0;1[ with 32-bit resolution.
   *
   * @since 0.1.0
   * @returns {number}
   */
  rnd(): number;
  /**
   * Generates a random real in the interval [0;1[ with 32-bit resolution.
   *
   * Same as .rnd() method - for consistency with Math.random() interface.
   *
   * @since 0.2.0
   * @returns {number}
   */
  random(): number;
  /**
   * Generates a random real in the interval [0;1[ with 53-bit resolution.
   *
   * @since 0.1.0
   * @returns {number}
   */
  rndHiRes(): number;
  /**
   * A pseudo-normal distribution using the Box-Muller transform.
   * @param {number} mu     The normal distribution mean
   * @param {number} sigma  The normal distribution standard deviation
   * @returns {number}
   */
  normal(mu: number, sigma: number): number;
}
declare const twist: MersenneTwister;
/**
 * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
 * The singleton instance of the Game class is available as the global variable game.
 */
declare class Game {
  /**
   * Fetch World data and return a Game instance
   * @param {string} view             The named view being created
   * @param {string|null} sessionId   The current sessionId of the connecting client
   * @returns {Promise<Game>}         A Promise which resolves to the created Game instance
   */
  static create(view: string, sessionId: string | null): Promise<Game>;
  /**
   * Establish a live connection to the game server through the socket.io URL
   * @param {string} sessionId  The client session ID with which to establish the connection
   * @returns {Promise<object>}  A promise which resolves to the connected socket, if successful
   */
  static connect(sessionId: string): Promise<object>;
  /**
   * Retrieve the cookies which are attached to the client session
   * @returns {object}   The session cookies
   */
  static getCookies(): object;
  /**
   * Request World data from server and return it
   * @param {Socket} socket     The active socket connection
   * @param {string} view       The view for which data is being requested
   * @returns {Promise<object>}
   */
  static getData(socket: Socket, view: string): Promise<object>;
  /**
   * Get the current World status upon initial connection.
   * @param {Socket} socket  The active client socket connection
   * @returns {Promise<boolean>}
   */
  static getWorldStatus(socket: Socket): Promise<boolean>;
  /**
   * Support mousewheel control for range type input elements
   * @param {WheelEvent} event    A Mouse Wheel scroll event
   * @private
   */
  private static _handleMouseWheelInputChange;
  /**
   * @param {string} view         The named view which is active for this game instance.
   * @param {object} data         An object of all the World data vended by the server when the client first connects
   * @param {string} sessionId    The ID of the currently active client session retrieved from the browser cookie
   * @param {Socket} socket       The open web-socket which should be used to transact game-state data
   */
  constructor(view: string, data: object, sessionId: string, socket: Socket);
  /**
   * The named view which is currently active.
   * Game views include: join, setup, players, license, game, stream
   * @type {string}
   */
  view: string;
  /**
   * The object of world data passed from the server
   * @type {object}
   */
  data: object;
  /**
   * The Release data for this version of Foundry
   * @type {config.ReleaseData}
   */
  release: config.ReleaseData;
  /**
   * The id of the active World user, if any
   * @type {string}
   */
  userId: string;
  /**
   * A mapping of WorldCollection instances, one per primary Document type.
   * @type {Collection<string,WorldCollection>}
   */
  collections: Collection<string, WorldCollection>;
  /**
   * A mapping of CompendiumCollection instances, one per Compendium pack.
   * @type {Collection<string,CompendiumCollection>}
   */
  packs: Collection<string, CompendiumCollection>;
  /**
   * A singleton web Worker manager.
   * @type {WorkerManager}
   */
  workers: WorkerManager;
  /**
   * Localization support
   * @type {Localization}
   */
  i18n: Localization;
  /**
   * The Keyboard Manager
   * @type {KeyboardManager}
   */
  keyboard: KeyboardManager;
  /**
   * The Mouse Manager
   * @type {MouseManager}
   */
  mouse: MouseManager;
  /**
   * The Gamepad Manager
   * @type {GamepadManager}
   */
  gamepad: GamepadManager;
  /**
   * The New User Experience manager.
   * @type {NewUserExperience}
   */
  nue: NewUserExperience;
  /**
   * The user role permissions setting
   * @type {object}
   */
  permissions: object;
  /**
   * The client session id which is currently active
   * @type {string}
   */
  sessionId: string;
  /**
   * Client settings which are used to configure application behavior
   * @type {ClientSettings}
   */
  settings: ClientSettings;
  /**
   * Client keybindings which are used to configure application behavior
   * @type {ClientKeybindings}
   */
  keybindings: ClientKeybindings;
  /**
   * A reference to the open Socket.io connection
   * @type {WebSocket|null}
   */
  socket: WebSocket | null;
  /**
   * A singleton GameTime instance which manages the progression of time within the game world.
   * @type {GameTime}
   */
  time: GameTime;
  /**
   * A singleton reference to the Canvas object which may be used.
   * @type {Canvas}
   */
  canvas: Canvas;
  /**
   * A singleton instance of the Audio Helper class
   * @type {AudioHelper}
   */
  audio: AudioHelper;
  /**
   * A singleton instance of the Video Helper class
   * @type {VideoHelper}
   */
  video: VideoHelper;
  /**
   * A singleton instance of the TooltipManager class
   * @type {TooltipManager}
   */
  tooltip: TooltipManager;
  /**
   * A singleton instance of the Clipboard Helper class.
   * @type {ClipboardHelper}
   */
  clipboard: ClipboardHelper;
  /**
   * A singleton instance of the Tour collection class
   * @type {Tours}
   */
  tours: Tours;
  /**
   * The global document index.
   * @type {DocumentIndex}
   */
  documentIndex: DocumentIndex;
  /**
   * Whether the Game is running in debug mode
   * @type {boolean}
   */
  debug: boolean;
  /**
   * A flag for whether texture assets for the game canvas are currently loading
   * @type {boolean}
   */
  loading: boolean;
  /**
   * A flag for whether the Game has successfully reached the "ready" hook
   * @type {boolean}
   */
  ready: boolean;
  /**
   * The game World which is currently active.
   * @type {World}
   */
  world: World;
  /**
   * The System which is used to power this game World.
   * @type {System}
   */
  system: System;
  /**
   * A Map of active Modules which are currently eligible to be enabled in this World.
   * The subset of Modules which are designated as active are currently enabled.
   * @type {Map<string, Module>}
   */
  modules: Map<string, Module>;
  /**
   * Returns the current version of the Release, usable for comparisons using isNewerVersion
   * @type {string}
   */
  get version(): string;
  /**
   * Configure package data that is currently enabled for this world
   * @param {object} data  Game data provided by the server socket
   */
  setupPackages(data: object): void;
  documentTypes: any;
  template: any;
  model: any;
  /**
   * Return the named scopes which can exist for packages.
   * Scopes are returned in the prioritization order that their content is loaded.
   * @returns {string[]}    An array of string package scopes
   */
  getPackageScopes(): string[];
  /**
   * Initialize the Game for the current window location
   */
  initialize(): Promise<void>;
  /**
   * Display certain usability error messages which are likely to result in the player having a bad experience.
   * @private
   */
  private _displayUsabilityErrors;
  /**
   * Shut down the currently active Game. Requires GameMaster user permission.
   * @returns {Promise<void>}
   */
  shutDown(): Promise<void>;
  /**
   * Fully set up the game state, initializing Documents, UI applications, and the Canvas
   * @returns {Promise<void>}
   */
  setupGame(): Promise<void>;
  /**
   * Initialize game state data by creating WorldCollection instances for every primary Document type
   */
  initializeDocuments(): void;
  _documentsReady: boolean | undefined;
  /**
   * Initialize the Compendium packs which are present within this Game
   * Create a Collection which maps each Compendium pack using it's collection ID
   * @returns {Collection<string,CompendiumCollection>}
   */
  initializePacks(): Collection<string, CompendiumCollection>;
  /**
   * Initialize the WebRTC implementation
   */
  initializeRTC(): Promise<boolean>;
  webrtc: AVMaster | undefined;
  /**
   * Initialize core UI elements
   */
  initializeUI(): void;
  /**
   * Initialize the game Canvas
   * @returns {Promise<void>}
   */
  initializeCanvas(): Promise<void>;
  /**
   * Initialize Keyboard controls
   */
  initializeKeyboard(): void;
  /**
   * Initialize Mouse controls
   */
  initializeMouse(): void;
  /**
   * Initialize Gamepad controls
   */
  initializeGamepads(): void;
  /**
   * Register core game settings
   */
  registerSettings(): void;
  /**
   * Register core Tours
   * @returns {Promise<void>}
   */
  registerTours(): Promise<void>;
  /**
   * Is the current session user authenticated as an application administrator?
   * @type {boolean}
   */
  get isAdmin(): boolean;
  /**
   * The currently connected User document, or null if Users is not yet initialized
   * @type {User|null}
   */
  get user(): User | null;
  /**
   * A convenience accessor for the currently viewed Combat encounter
   * @type {Combat}
   */
  get combat(): Combat;
  /**
   * A state variable which tracks whether the game session is currently paused
   * @type {boolean}
   */
  get paused(): boolean;
  /**
   * A convenient reference to the currently active canvas tool
   * @type {string}
   */
  get activeTool(): string;
  /**
   * Toggle the pause state of the game
   * Trigger the `pauseGame` Hook when the paused state changes
   * @param {boolean} pause         The desired pause state; true for paused, false for un-paused
   * @param {boolean} [push=false]  Push the pause state change to other connected clients? Requires an GM user.
   * @returns {boolean}             The new paused state
   */
  togglePause(pause: boolean, push?: boolean | undefined): boolean;
  /**
   * Open Character sheet for current token or controlled actor
   * @returns {ActorSheet|null}  The ActorSheet which was toggled, or null if the User has no character
   */
  toggleCharacterSheet(): ActorSheet | null;
  /**
   * Log out of the game session by returning to the Join screen
   */
  logOut(): void;
  /**
   * Scale the base font size according to the user's settings.
   * @param {number} [index]  Optionally supply a font size index to use, otherwise use the user's setting.
   *                          Available font sizes, starting at index 1, are: 8, 10, 12, 14, 16, 18, 20, 24, 28, and 32.
   */
  scaleFonts(index?: number | undefined): void;
  /**
   * Activate Socket event listeners which are used to transact game state data with the server
   */
  activateSocketListeners(): void;
  /**
   * Activate Event Listeners which apply to every Game View
   */
  activateListeners(): void;
  /**
   * On left mouse clicks, check if the element is contained in a valid hyperlink and open it in a new tab.
   * @param {MouseEvent} event
   * @private
   */
  private _onClickHyperlink;
  /**
   * Prevent starting a drag and drop workflow on elements within the document unless the element has the draggable
   * attribute explicitly defined or overrides the dragstart handler.
   * @param {DragEvent} event   The initiating drag start event
   * @private
   */
  private _onPreventDragstart;
  /**
   * Disallow dragging of external content onto anything but a file input element
   * @param {DragEvent} event   The requested drag event
   * @private
   */
  private _onPreventDragover;
  /**
   * Disallow dropping of external content onto anything but a file input element
   * @param {DragEvent} event   The requested drag event
   * @private
   */
  private _onPreventDrop;
  /**
   * On a left-click event, remove any currently displayed inline roll tooltip
   * @param {PointerEvent} event    The mousedown pointer event
   * @private
   */
  private _onPointerDown;
  /**
   * Fallback handling for mouse-up events which aren't handled further upstream.
   * @param {PointerEvent} event    The mouseup pointer event
   * @private
   */
  private _onPointerUp;
  /**
   * Handle resizing of the game window by adjusting the canvas and repositioning active interface applications.
   * @param {Event} event     The window resize event which has occurred
   * @private
   */
  private _onWindowResize;
  /**
   * Handle window unload operations to clean up any data which may be pending a final save
   * @param {Event} event     The window unload event which is about to occur
   * @private
   */
  private _onWindowBeforeUnload;
  /**
   * Handle cases where the browser window loses focus to reset detection of currently pressed keys
   * @param {Event} event   The originating window.blur event
   * @private
   */
  private _onWindowBlur;
  _onWindowPopState(event: any): void;
  /**
   * Initialize elements required for the current view
   * @private
   */
  private _initializeView;
  /**
   * Initialization steps for the primary Game view
   * @private
   */
  private _initializeGameView;
  /**
   * Initialization steps for the Stream helper view
   * @private
   */
  private _initializeStreamView;
}
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare const vtt: string;
/**
 * The singleton Game instance
 * @type {Game}
 */
declare let game: Game;
/**
 * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js
 * library. The canvas is comprised by an ordered sequence of layers which define rendering groups and collections of
 * objects that are drawn on the canvas itself.
 *
 * ### Hook Events
 * {@link hookEvents.canvasConfig}
 * {@link hookEvents.canvasInit}
 * {@link hookEvents.canvasReady}
 * {@link hookEvents.canvasPan}
 * {@link hookEvents.canvasTearDown}
 *
 * @category - Canvas
 *
 * @example Canvas State
 * ```js
 * canvas.ready; // Is the canvas ready for use?
 * canvas.scene; // The currently viewed Scene document.
 * canvas.dimensions; // The dimensions of the current Scene.
 * ```
 * @example Canvas Methods
 * ```js
 * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).
 * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.
 * canvas.recenter(); // Re-center the canvas on the currently controlled Token.
 * ```
 */
declare class Canvas {
  /**
   * A mapping of named CanvasLayer classes which defines the layers which comprise the Scene.
   * @type {Object<CanvasLayer>}
   */
  static get layers(): any;
  /**
   * Configure the usage of WebGL for the PIXI.Application that will be created.
   * @throws an Error if WebGL is not supported by this browser environment.
   * @private
   */
  private static "__#27@#configureWebGL";
  /**
   * Create the Canvas element which will be the render target for the PIXI.Application instance.
   * Replace the template element which serves as a placeholder in the initially served HTML response.
   * @returns {HTMLCanvasElement}
   * @private
   */
  private static "__#27@#createHTMLCanvas";
  /**
   * Configure the settings used to initialize the PIXI.Application instance.
   * @returns {object}    Options passed to the PIXI.Application constructor.
   * @private
   */
  private static "__#27@#configureCanvasSettings";
  /**
   * Remove all children of the display object and call one cleaning method:
   * clean first, then tearDown, and destroy if no cleaning method is found.
   * @param {PIXI.DisplayObject} displayObject  The display object to clean.
   * @param {boolean} destroy                   If textures should be destroyed.
   */
  static clearContainer(
    displayObject: PIXI.DisplayObject,
    destroy?: boolean
  ): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  static getDimensions(scene: any): any;
  /**
   * An Array of pending canvas operations which should trigger on the next re-paint
   * @type {object[]}
   */
  pendingOperations: object[];
  /**
   * A perception manager interface for batching lighting, sight, and sound updates
   * @type {PerceptionManager}
   */
  perception: PerceptionManager;
  /**
   * A flag to indicate whether a new Scene is currently being drawn.
   * @type {boolean}
   */
  loading: boolean;
  /**
   * A promise that resolves when the canvas is first initialized and ready.
   * @type {Promise<void>|null}
   */
  initializing: Promise<void> | null;
  /**
   * Track the last automatic pan time to throttle
   * @type {number}
   * @private
   */
  private _panTime;
  /**
   * A Set of unique pending operation names to ensure operations are only performed once
   * @type {Set<string>}
   */
  _pendingOperationNames: Set<string>;
  /**
   * An set of blur filter instances which are modified by the zoom level and the "soft shadows" setting
   * @type {Set<PIXI.filters>}
   */
  blurFilters: Set<PIXI.filters>;
  /**
   * A reference to the MouseInteractionManager that is currently controlling pointer-based interaction, or null.
   * @type {MouseInteractionManager|null}
   */
  currentMouseManager: MouseInteractionManager | null;
  /**
   * The current pixel dimensions of the displayed Scene, or null if the Canvas is blank.
   * @type {SceneDimensions}
   */
  dimensions: {
    /**
     * The width of the canvas.
     */
    width: number;
    /**
     * The height of the canvas.
     */
    height: number;
    /**
     * The grid size.
     */
    size: number;
    /**
     * The canvas rectangle.
     */
    rect: Rectangle;
    /**
     * The X coordinate of the scene rectangle within the larger canvas.
     */
    sceneX: number;
    /**
     * The Y coordinate of the scene rectangle within the larger canvas.
     */
    sceneY: number;
    /**
     * The width of the scene.
     */
    sceneWidth: number;
    /**
     * The height of the scene.
     */
    sceneHeight: number;
    /**
     * The scene rectangle.
     */
    sceneRect: Rectangle;
    /**
     * The number of distance units in a single grid space.
     */
    distance: number;
    /**
     * The aspect ratio of the scene rectangle.
     */
    ratio: number;
    /**
     * The length of the longest line that can be drawn on the canvas.
     */
    maxR: number;
  };
  /**
   * Record framerate performance data.
   * @type {{average: number, values: number[], element: HTMLElement, render: number}}
   */
  fps: {
    average: number;
    values: number[];
    element: HTMLElement;
    render: number;
  };
  /**
   * The singleton interaction manager instance which handles mouse interaction on the Canvas.
   * @type {MouseInteractionManager}
   */
  mouseInteractionManager: MouseInteractionManager;
  /**
   * @typedef {Object} CanvasPerformanceSettings
   * @property {number} mode      The performance mode in CONST.CANVAS_PERFORMANCE_MODES
   * @property {{enabled: boolean, illumination: boolean}} blur   Blur filter configuration
   * @property {string} mipmap    Whether to use mipmaps, "ON" or "OFF"
   * @property {boolean} msaa     Whether to apply MSAA at the overall canvas level
   * @property {number} fps       Maximum framerate which should be the render target
   * @property {boolean} tokenAnimation   Whether to display token movement animation
   * @property {boolean} lightAnimation   Whether to display light source animation
   * @property {boolean} lightSoftEdges   Whether to render soft edges for light sources
   * @property {{enabled: boolean, maxSize: number, p2Steps: number, p2StepsMax: 2}} textures  Texture configuration
   */
  /**
   * Configured performance settings which affect the behavior of the Canvas and its renderer.
   * @type {CanvasPerformanceSettings}
   */
  performance: {
    /**
     * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
     */
    mode: number;
    /**
     * Blur filter configuration
     */
    blur: {
      enabled: boolean;
      illumination: boolean;
    };
    /**
     * Whether to use mipmaps, "ON" or "OFF"
     */
    mipmap: string;
    /**
     * Whether to apply MSAA at the overall canvas level
     */
    msaa: boolean;
    /**
     * Maximum framerate which should be the render target
     */
    fps: number;
    /**
     * Whether to display token movement animation
     */
    tokenAnimation: boolean;
    /**
     * Whether to display light source animation
     */
    lightAnimation: boolean;
    /**
     * Whether to render soft edges for light sources
     */
    lightSoftEdges: boolean;
    /**
     * Texture configuration
     */
    textures: {
      enabled: boolean;
      maxSize: number;
      p2Steps: number;
      p2StepsMax: 2;
    };
  };
  /**
   * The renderer screen dimensions.
   * @type {number[]}
   */
  screenDimensions: number[];
  /**
   * The singleton Fog of War manager instance.
   * @type {FogManager}
   * @private
   */
  private _fog;
  /**
   * The singleton PIXI.Application instance rendered on the Canvas.
   * @type {PIXI.Application}
   */
  app: PIXI.Application;
  /**
   * The primary stage container of the PIXI.Application.
   * @type {PIXI.Container}
   */
  stage: PIXI.Container;
  /**
   * The primary Canvas group which generally contains tangible physical objects which exist within the Scene.
   * This group is a {@link CachedContainer} which is rendered to the Scene as a {@link SpriteMesh}.
   * This allows the rendered result of the Primary Canvas Group to be affected by a {@link BaseSamplerShader}.
   * @type {PrimaryCanvasGroup}
   */
  primary: PrimaryCanvasGroup;
  /**
   * The effects Canvas group which modifies the result of the {@link PrimaryCanvasGroup} by adding special effects.
   * This includes lighting, weather, vision, and other visual effects which modify the appearance of the Scene.
   * @type {EffectsCanvasGroup}
   */
  effects: EffectsCanvasGroup;
  /**
   * The interface Canvas group which is rendered above other groups and contains all interactive elements.
   * The various {@link InteractionLayer} instances of the interface group provide different control sets for
   * interacting with different types of {@link Document}s which can be represented on the Canvas.
   * @type {InterfaceCanvasGroup}
   */
  interface: InterfaceCanvasGroup;
  /**
   * The singleton HeadsUpDisplay container which overlays HTML rendering on top of this Canvas.
   * @type {HeadsUpDisplay}
   */
  hud: HeadsUpDisplay;
  /**
   * A flag for whether the game Canvas is fully initialized and ready for additional content to be drawn.
   * @type {boolean}
   */
  get initialized(): boolean;
  /**
   * A reference to the currently displayed Scene document, or null if the Canvas is currently blank.
   * @type {Scene|null}
   */
  get scene(): Scene | null;
  /**
   * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.
   * @type {boolean}
   */
  get ready(): boolean;
  /**
   * The fog of war bound to this canvas
   * @type {FogManager}
   */
  get fog(): FogManager;
  /**
   * The color manager class bound to this canvas
   * @type {CanvasColorManager}
   */
  get colorManager(): CanvasColorManager;
  /**
   * The colors bound to this scene and handled by the color manager.
   * @type {Color}
   */
  get colors(): any;
  /**
   * Shortcut to get the masks container from HiddenCanvasGroup.
   * @type {PIXI.Container}
   */
  get masks(): PIXI.Container;
  /**
   * The id of the currently displayed Scene.
   * @type {string|null}
   */
  get id(): string | null;
  /**
   * An Array of all CanvasLayer instances which are active on the Canvas board
   * @type {CanvasLayer[]}
   */
  get layers(): CanvasLayer[];
  /**
   * Return a reference to the active Canvas Layer
   * @type {CanvasLayer}
   */
  get activeLayer(): CanvasLayer;
  /**
   * The currently displayed darkness level, which may override the saved Scene value.
   * @type {number}
   */
  get darknessLevel(): number;
  /**
   * Initialize the Canvas by creating the HTML element and PIXI application.
   * This step should only ever be performed once per client session.
   * Subsequent requests to reset the canvas should go through Canvas#draw
   */
  initialize(): void;
  /**
   * TODO: Add a quality parameter
   * Compute the blur parameters according to grid size and performance mode.
   * @private
   */
  private _initializeBlur;
  blur:
    | {
        enabled: boolean;
        strength: number;
        passes: any;
        kernels: any;
      }
    | undefined;
  /**
   * Configure performance settings for hte canvas application based on the selected performance mode.
   * @returns {CanvasPerformanceSettings}
   * @internal
   */
  _configurePerformanceMode(): {
    /**
     * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
     */
    mode: number;
    /**
     * Blur filter configuration
     */
    blur: {
      enabled: boolean;
      illumination: boolean;
    };
    /**
     * Whether to use mipmaps, "ON" or "OFF"
     */
    mipmap: string;
    /**
     * Whether to apply MSAA at the overall canvas level
     */
    msaa: boolean;
    /**
     * Maximum framerate which should be the render target
     */
    fps: number;
    /**
     * Whether to display token movement animation
     */
    tokenAnimation: boolean;
    /**
     * Whether to display light source animation
     */
    lightAnimation: boolean;
    /**
     * Whether to render soft edges for light sources
     */
    lightSoftEdges: boolean;
    /**
     * Texture configuration
     */
    textures: {
      enabled: boolean;
      maxSize: number;
      p2Steps: number;
      p2StepsMax: 2;
    };
  };
  /**
   * Draw the game canvas.
   * @param {Scene} [scene]         A specific Scene document to render on the Canvas
   * @returns {Promise<Canvas>}     A Promise which resolves once the Canvas is fully drawn
   */
  draw(scene?: Scene | undefined): Promise<Canvas>;
  /**
   * When re-drawing the canvas, first tear down or discontinue some existing processes
   * @returns {Promise<void>}
   */
  tearDown(): Promise<void>;
  /**
   * Get the value of a GL parameter
   * @param {string} parameter  The GL parameter to retrieve
   * @returns {*}               The GL parameter value
   */
  getGLParameter(parameter: string): any;
  /**
   * Initialize the starting view of the canvas stage
   * If we are re-drawing a scene which was previously rendered, restore the prior view position
   * Otherwise set the view to the top-left corner of the scene at standard scale
   */
  initializeCanvasPosition(): void;
  /**
   * Given an embedded object name, get the canvas layer for that object
   * @param {string} embeddedName
   * @returns {PlaceablesLayer|null}
   */
  getLayerByEmbeddedName(embeddedName: string): PlaceablesLayer | null;
  /**
   * Activate framerate tracking by adding an HTML element to the display and refreshing it every frame.
   */
  activateFPSMeter(): void;
  /**
   * Deactivate framerate tracking by canceling ticker updates and removing the HTML element.
   */
  deactivateFPSMeter(): void;
  /**
   * @typedef {Object} CanvasViewPosition
   * @property {number|null} x      The x-coordinate which becomes stage.pivot.x
   * @property {number|null} y      The y-coordinate which becomes stage.pivot.y
   * @property {number|null} scale  The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
   */
  /**
   * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
   * @param {CanvasViewPosition} position     The canvas position to pan to
   */
  pan({
    x,
    y,
    scale,
  }?: {
    /**
     * The x-coordinate which becomes stage.pivot.x
     */
    x: number | null;
    /**
     * The y-coordinate which becomes stage.pivot.y
     */
    y: number | null;
    /**
     * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    scale: number | null;
  }): void;
  /**
   * Animate panning the canvas to a certain destination coordinate and zoom scale
   * Customize the animation speed with additional options
   * Returns a Promise which is resolved once the animation has completed
   *
   * @param {CanvasViewPosition} view    The desired view parameters
   * @param {number} [view.duration=250] The total duration of the animation in milliseconds; used if speed is not set
   * @param {number} [view.speed]        The speed of animation in pixels per second; overrides duration if set
   * @returns {Promise}           A Promise which resolves once the animation has been completed
   */
  animatePan({
    x,
    y,
    scale,
    duration,
    speed,
  }?: {
    /**
     * The x-coordinate which becomes stage.pivot.x
     */
    x: number | null;
    /**
     * The y-coordinate which becomes stage.pivot.y
     */
    y: number | null;
    /**
     * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    scale: number | null;
  }): Promise<any>;
  /**
   * Recenter the canvas with a pan animation that ends in the center of the canvas rectangle.
   * @param {CanvasViewPosition} initial    A desired initial position from which to begin the animation
   * @returns {Promise<void>}               A Promise which resolves once the animation has been completed
   */
  recenter(initial: {
    /**
     * The x-coordinate which becomes stage.pivot.x
     */
    x: number | null;
    /**
     * The y-coordinate which becomes stage.pivot.y
     */
    y: number | null;
    /**
     * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    scale: number | null;
  }): Promise<void>;
  /**
   * Highlight objects on any layers which are visible
   * @param {boolean} active
   */
  highlightObjects(active: boolean): void;
  /**
   * Displays a Ping both locally and on other connected client, following these rules:
   * 1) Displays on the current canvas Scene
   * 2) If ALT is held, becomes an ALERT ping
   * 3) Else if the user is GM and SHIFT is held, becomes a PULL ping
   * 4) Else is a PULSE ping
   * @param {Point} origin                  Point to display Ping at
   * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
   * @returns {Promise<boolean>}
   */
  ping(origin: Point, options?: PingOptions | undefined): Promise<boolean>;
  /**
   * Create a BlurFilter instance and register it to the array for updates when the zoom level changes.
   * @param {number} blurStrength         The desired blur strength to use for this filter
   * @returns {PIXI.filters.BlurFilter}
   */
  createBlurFilter(blurStrength?: number): PIXI.filters.BlurFilter;
  /**
   * Add a filter to the blur filter list. The filter must have the blur property
   * @param {PIXI.filters.BlurFilter} filter    The Filter instance to add
   * @returns {PIXI.filters.BlurFilter}         The added filter for method chaining
   */
  addBlurFilter(filter: PIXI.filters.BlurFilter): PIXI.filters.BlurFilter;
  /**
   * Update the blur strength depending on the scale of the canvas stage.
   * This number is zero if "soft shadows" are disabled
   * @param {number} [strength]      Optional blur strength to apply
   * @private
   */
  private updateBlur;
  /**
   * Convert canvas co-ordinates to the client's viewport.
   * @param {Point} origin  The canvas coordinates.
   * @returns {Point}       The corresponding co-ordinates relative to the client's viewport.
   */
  clientCoordinatesFromCanvas(origin: Point): Point;
  /**
   * Convert client viewport co-ordinates to canvas co-ordinates.
   * @param {Point} origin  The client coordinates.
   * @returns {Point}       The corresponding canvas co-ordinates.
   */
  canvasCoordinatesFromClient(origin: Point): Point;
  /**
   * Determine whether given canvas co-ordinates are off-screen.
   * @param {Point} position  The canvas co-ordinates.
   * @returns {boolean}       Is the coordinate outside the screen bounds?
   */
  isOffscreen(position: Point): boolean;
  /**
   * Handle mouse movement on the game canvas.
   * This handler fires on both a throttle and a debounce, ensuring that the final update is always recorded.
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onMouseMove;
  /**
   * Handle left mouse-click events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleClickLeft}
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onClickLeft;
  /**
   * Handle double left-click events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleClickLeft2}
   * @param {PIXI.InteractionEvent} event
   */
  _onClickLeft2(event: PIXI.InteractionEvent): void;
  /**
   * Handle long press events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleLongPress}
   * @param {PIXI.InteractionEvent} event   The triggering canvas interaction event.
   * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
   * @private
   */
  private _onLongPress;
  /**
   * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.
   * @see {MouseInteractionManager#_handleDragStart}
   * @param {PIXI.InteractionEvent} event
   * @internal
   */
  _onDragLeftStart(event: PIXI.InteractionEvent): any;
  /**
   * Handle mouse movement events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleDragMove}
   * @param {PIXI.InteractionEvent} event
   * @internal
   */
  _onDragLeftMove(event: PIXI.InteractionEvent): any;
  /**
   * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.
   * @see {MouseInteractionManager#_handleDragDrop}
   * @param {PIXI.InteractionEvent} event
   * @internal
   */
  _onDragLeftDrop(event: PIXI.InteractionEvent): any;
  /**
   * Handle the cancellation of a left-mouse drag workflow
   * @see {MouseInteractionManager#_handleDragCancel}
   * @param {PointerEvent} event
   * @internal
   */
  _onDragLeftCancel(event: PointerEvent): any;
  /**
   * Handle right mouse-click events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleClickRight}
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onClickRight;
  /**
   * Handle double right-click events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleClickRight}
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onClickRight2;
  /**
   * Handle right-mouse drag events occurring on the Canvas.
   * @see {MouseInteractionManager#_handleDragMove}
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onDragRightMove;
  /**
   * Handle the conclusion of a right-mouse drag workflow the Canvas stage.
   * @see {MouseInteractionManager#_handleDragDrop}
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onDragRightDrop;
  /**
   * Determine selection coordinate rectangle during a mouse-drag workflow
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onDragSelect;
  /**
   * Pan the canvas view when the cursor position gets close to the edge of the frame
   * @param {MouseEvent} event    The originating mouse movement event
   */
  _onDragCanvasPan(event: MouseEvent): Promise<any> | undefined;
  /**
   * Handle window resizing with the dimensions of the window viewport change
   * @param {Event} event     The Window resize event
   * @private
   */
  private _onResize;
  /**
   * Handle mousewheel events which adjust the scale of the canvas
   * @param {WheelEvent} event    The mousewheel event that zooms the canvas
   * @private
   */
  private _onMouseWheel;
  /**
   * Event handler for the drop portion of a drag-and-drop event.
   * @param {DragEvent} event  The drag event being dropped onto the canvas
   * @private
   */
  private _onDrop;
  /**
   * Add a pending canvas operation that should fire once the socket handling workflow concludes.
   * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.
   * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.
   * TODO: this should be deprecated
   * @param {string} name     A unique name for the pending operation, conventionally Class.method
   * @param {Function} fn     The unbound function to execute later
   * @param {*} scope         The scope to which the method should be bound when called
   * @param {...*} args       Arbitrary arguments to pass to the method when called
   */
  addPendingOperation(
    name: string,
    fn: Function,
    scope: any,
    args: any[]
  ): void;
  /**
   * Fire all pending functions that are registered in the pending operations queue and empty it.
   * TODO: this should be deprecated
   */
  triggerPendingOperations(): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  set blurDistance(arg: number);
  /**
   * @deprecated since v10
   * @ignore
   */
  get blurDistance(): number;
  /**
   * @deprecated since v10
   * @ignore
   */
  activateLayer(layerName: any): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  setBackgroundColor(color: any): void;
  #private;
}
type CanvasPerformanceSettings = {
  /**
   * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
   */
  mode: number;
  /**
   * Blur filter configuration
   */
  blur: {
    enabled: boolean;
    illumination: boolean;
  };
  /**
   * Whether to use mipmaps, "ON" or "OFF"
   */
  mipmap: string;
  /**
   * Whether to apply MSAA at the overall canvas level
   */
  msaa: boolean;
  /**
   * Maximum framerate which should be the render target
   */
  fps: number;
  /**
   * Whether to display token movement animation
   */
  tokenAnimation: boolean;
  /**
   * Whether to display light source animation
   */
  lightAnimation: boolean;
  /**
   * Whether to render soft edges for light sources
   */
  lightSoftEdges: boolean;
  /**
   * Texture configuration
   */
  textures: {
    enabled: boolean;
    maxSize: number;
    p2Steps: number;
    p2StepsMax: 2;
  };
};
type CanvasViewPosition = {
  /**
   * The x-coordinate which becomes stage.pivot.x
   */
  x: number | null;
  /**
   * The y-coordinate which becomes stage.pivot.y
   */
  y: number | null;
  /**
   * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
   */
  scale: number | null;
};
/**
 * A mixin which decorates any container with base canvas common properties.
 * @category - Mixins
 * @param {typeof Container} ContainerClass  The parent Container class being mixed.
 * @returns {typeof BaseCanvasMixin}         A ContainerClass subclass mixed with BaseCanvasMixin features.
 */
declare function BaseCanvasMixin(ContainerClass: any): typeof BaseCanvasMixin;
/**
 * A special type of PIXI.Container which draws its contents to a cached RenderTexture.
 * This is accomplished by overriding the Container#render method to draw to our own special RenderTexture.
 */
declare class CachedContainer {
  /**
   * Resize a render texture passed as a parameter with the renderer.
   * @param {PIXI.Renderer} renderer    The active canvas renderer.
   * @param {PIXI.RenderTexture} rt     The render texture to resize.
   */
  static resizeRenderTexture(
    renderer: PIXI.Renderer,
    rt: PIXI.RenderTexture
  ): void;
  /**
   * Construct a CachedContainer.
   * @param {PIXI.Sprite|SpriteMesh} [sprite]  A specific sprite to bind to this CachedContainer and its renderTexture.
   */
  constructor(sprite?: PIXI.Sprite | SpriteMesh);
  set sprite(arg: any);
  /**
   * A PIXI.Sprite or SpriteMesh which is bound to this CachedContainer.
   * The RenderTexture from this Container is associated with the Sprite which is automatically rendered.
   * @type {PIXI.Sprite|SpriteMesh}
   */
  get sprite(): any;
  /**
   * An RGBA array used to define the clear color of the RenderTexture
   * @type {number[]}
   */
  clearColor: number[];
  /**
   * Should our Container also be displayed on screen, in addition to being drawn to the cached RenderTexture?
   * @type {boolean}
   */
  displayed: boolean;
  /**
   * The primary render texture bound to this cached container.
   * @type {PIXI.RenderTexture}
   */
  get renderTexture(): PIXI.RenderTexture;
  /**
   * Set the alpha mode of the cached container render texture.
   * @param {PIXI.ALPHA_MODES} mode
   */
  set alphaMode(arg: PIXI.ALPHA_MODES);
  /**
   * Create a render texture, provide a render method and an optional clear color.
   * @param {object} [options={}]                 Optional parameters.
   * @param {Function} [options.renderFunction]   Render function that will be called to render into the RT.
   * @param {number[]} [options.clearColor]       An optional clear color to clear the RT before rendering into it.
   * @returns {PIXI.RenderTexture}              A reference to the created render texture.
   */
  createRenderTexture({
    renderFunction,
    clearColor,
  }?:
    | {
        renderFunction?: Function | undefined;
        clearColor?: number[] | undefined;
      }
    | undefined): PIXI.RenderTexture;
  /**
   * Remove a previously created render texture.
   * @param {PIXI.RenderTexture} renderTexture   The render texture to remove.
   * @param {boolean} [destroy=true]             Should the render texture be destroyed?
   */
  removeRenderTexture(
    renderTexture: PIXI.RenderTexture,
    destroy?: boolean | undefined
  ): void;
  /**
   * Clear the cached container, removing its current contents.
   * @param {boolean} [destroy=true]    Tell children that we should destroy texture as well.
   * @returns {CachedContainer}         A reference to the cleared container for chaining.
   */
  clear(destroy?: boolean | undefined): CachedContainer;
  /** @inheritdoc */
  destroy(options: any): void;
  /** @inheritdoc */
  render(renderer: any): void;
  #private;
}
/**
 * A specialized container where bounds are not computed with children, but with canvas dimensions.
 */
declare class FullCanvasContainer {
  /** @override */
  override calculateBounds(): void;
}
/**
 * Extension of a PIXI.Mesh, with the capabilities to provide a snapshot of the framebuffer.
 * @extends PIXI.Mesh
 */
declare class PointSourceMesh {
  /**
   * To store the previous blend mode of the last renderer PointSourceMesh.
   * @type {PIXI.BLEND_MODES}
   * @protected
   */
  protected static _priorBlendMode: PIXI.BLEND_MODES;
  /**
   * The current texture used by the mesh.
   * @type {PIXI.Texture}
   * @protected
   */
  protected static _currentTexture: PIXI.Texture;
  /** @override */
  override _render(renderer: any): void;
}
/**
 * @typedef {object} QuadtreeObject
 * @property {Rectangle} r
 * @property {*} t
 * @property {Set<Quadtree>} [n]
 */
/**
 * A Quadtree implementation that supports collision detection for rectangles.
 *
 * @param {Rectangle} bounds                The outer bounds of the region
 * @param {object} [options]                Additional options which configure the Quadtree
 * @param {number} [options.maxObjects=20]  The maximum number of objects per node
 * @param {number} [options.maxDepth=4]     The maximum number of levels within the root Quadtree
 * @param {number} [options._depth=0]       The depth level of the sub-tree. For internal use
 * @param {number} [options._root]          The root of the quadtree. For internal use
 */
declare class Quadtree {
  /**
   * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
   * @enum {number}
   */
  static INDICES: {
    tl: number;
    tr: number;
    bl: number;
    br: number;
  };
  constructor(
    bounds: any,
    {
      maxObjects,
      maxDepth,
      _depth,
      _root,
    }?: {
      maxObjects?: number | undefined;
      maxDepth?: number | undefined;
      _depth?: number | undefined;
      _root: any;
    }
  );
  /**
   * The bounding rectangle of the region
   * @type {Rectangle}
   */
  bounds: Rectangle;
  /**
   * The maximum number of objects allowed within this node before it must split
   * @type {number}
   */
  maxObjects: number;
  /**
   * The maximum number of levels that the base quadtree is allowed
   * @type {number}
   */
  maxDepth: number;
  /**
   * The depth of this node within the root Quadtree
   * @type {number}
   */
  depth: number;
  /**
   * The objects contained at this level of the tree
   * @type {QuadtreeObject[]}
   */
  objects: QuadtreeObject[];
  /**
   * Children of this node
   * @type {Quadtree[]}
   */
  nodes: Quadtree[];
  /**
   * The root Quadtree
   * @type {Quadtree}
   */
  root: Quadtree;
  /**
   * Return an array of all the objects in the Quadtree (recursive)
   * @returns {QuadtreeObject[]}
   */
  get all(): QuadtreeObject[];
  /**
   * Split this node into 4 sub-nodes.
   * @returns {Quadtree}     The split Quadtree
   */
  split(): Quadtree;
  /**
   * Clear the quadtree of all existing contents
   * @returns {Quadtree}     The cleared Quadtree
   */
  clear(): Quadtree;
  /**
   * Add a rectangle object to the tree
   * @param {QuadtreeObject} obj  The object being inserted
   * @returns {Quadtree[]}        The Quadtree nodes the object was added to.
   */
  insert(obj: QuadtreeObject): Quadtree[];
  /**
   * Remove an object from the quadtree
   * @param {*} target     The quadtree target being removed
   * @returns {Quadtree}   The Quadtree for method chaining
   */
  remove(target: any): Quadtree;
  /**
   * Remove an existing object from the quadtree and re-insert it with a new position
   * @param {QuadtreeObject} obj  The object being inserted
   * @returns {Quadtree[]}        The Quadtree nodes the object was added to
   */
  update(obj: QuadtreeObject): Quadtree[];
  /**
   * Get all the objects which could collide with the provided rectangle
   * @param {Rectangle} rect    The normalized target rectangle
   * @param {object} [options]                    Options affecting the collision test.
   * @param {Function} [options.collisionTest]    Function to further refine objects to return
   *   after a potential collision is found. Parameters are the object and rect, and the
   *   function should return true if the object should be added to the result set.
   * @param {Set} [options._s]                    The existing result set, for internal use.
   * @returns {Set}           The objects in the Quadtree which represent potential collisions
   */
  getObjects(
    rect: Rectangle,
    {
      collisionTest,
      _s,
    }?:
      | {
          collisionTest?: Function | undefined;
          _s?: Set<any> | undefined;
        }
      | undefined
  ): Set<any>;
  /**
   * Obtain the leaf nodes to which a target rectangle belongs.
   * This traverses the quadtree recursively obtaining the final nodes which have no children.
   * @param {Rectangle} rect  The target rectangle.
   * @returns {Quadtree[]}    The Quadtree nodes to which the target rectangle belongs
   */
  getLeafNodes(rect: Rectangle): Quadtree[];
  /**
   * Obtain the child nodes within the current node which a rectangle belongs to.
   * Note that this function is not recursive, it only returns nodes at the current or child level.
   * @param {Rectangle} rect  The target rectangle.
   * @returns {Quadtree[]}    The Quadtree nodes to which the target rectangle belongs
   */
  getChildNodes(rect: Rectangle): Quadtree[];
  /**
   * Identify all nodes which are adjacent to this one within the parent Quadtree.
   * @returns {Quadtree[]}
   */
  getAdjacentNodes(): Quadtree[];
  /**
   * Visualize the nodes and objects in the quadtree
   * @param {boolean} [objects]    Visualize the rectangular bounds of objects in the Quadtree. Default is false.
   * @private
   */
  private visualize;
}
/**
 * A subclass of Quadtree specifically intended for classifying the location of objects on the game canvas.
 */
declare class CanvasQuadtree extends Quadtree {
  constructor(options?: {});
}
/**
 * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
 */
type INDICES = number;
type QuadtreeObject = {
  r: Rectangle;
  t: any;
  n?: Set<Quadtree> | undefined;
};
/**
 * An extension of PIXI.Mesh which emulate a PIXI.Sprite with a specific shader.
 * @param [texture=PIXI.Texture.EMPTY]      Texture bound to this sprite mesh.
 * @param [shaderClass=BaseSamplerShader]   Shader class used by this sprite mesh.
 * @extends PIXI.Mesh
 */
declare class SpriteMesh {
  /**
   * Create a SpriteMesh from another source.
   * You can specify texture options and a specific shader class derived from AbstractBaseShader.
   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source  Source to create texture from.
   * @param {object} [textureOptions]               See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {AbstractBaseShader} [shaderCls]        The shader class to use. BaseSamplerShader by default.
   * @returns {SpriteMesh}
   */
  static from(
    source: string | PIXI.Texture | HTMLCanvasElement | HTMLVideoElement,
    textureOptions?: object | undefined,
    shaderCls?: AbstractBaseShader | undefined
  ): SpriteMesh;
  constructor(texture: any, shaderCls?: typeof BaseSamplerShader);
  /** @override */
  override _cachedTint: number[];
  vertexData: any;
  uvs: any;
  indices: any;
  _texture: any;
  _anchor: any;
  override set texture(arg: any);
  /** @override */
  override get texture(): any;
  alpha: number;
  override set tint(arg: any);
  /** @override */
  override get tint(): any;
  blendMode: any;
  /**
   * Snapshot of some parameters of this display object to render in batched mode.
   * TODO: temporary object until the upstream issue is fixed: https://github.com/pixijs/pixijs/issues/8511
   * @type {{_tintRGB: number, _texture: PIXI.Texture, indices: number[],
   * uvs: number[], blendMode: PIXI.BLEND_MODES, vertexData: number[], worldAlpha: number}}
   * @protected
   */
  protected _batchData: {
    _tintRGB: number;
    _texture: PIXI.Texture;
    indices: number[];
    uvs: number[];
    blendMode: PIXI.BLEND_MODES;
    vertexData: number[];
    worldAlpha: number;
  };
  /** @override */
  override _transformID: number;
  /** @override */
  override _textureID: number;
  /** @override */
  override _textureTrimmedID: number;
  /** @override */
  override _transformTrimmedID: number;
  /** @override */
  override _roundPixels: boolean;
  /** @override */
  override vertexTrimmedData: null;
  /** @override */
  override isSprite: boolean;
  set alphaMode(arg: any);
  /**
   * Used to force an alpha mode on this sprite mesh.
   * If this property is non null, this value will replace the texture alphaMode when computing color channels.
   * Affects how tint, worldAlpha and alpha are computed each others.
   * @type {PIXI.ALPHA_MODES|undefined}
   */
  get alphaMode(): any;
  set pluginName(arg: string);
  /**
   * Returns the SpriteMesh associated batch plugin. By default the returned plugin is that of the associated shader.
   * If a plugin is forced, it will returns the forced plugin.
   * @type {string}
   */
  get pluginName(): string;
  override set width(arg: number);
  /** @override */
  override get width(): number;
  _width: any;
  override set height(arg: number);
  /** @override */
  override get height(): number;
  _height: any;
  override set anchor(arg: any);
  /** @override */
  override get anchor(): any;
  _tint: any;
  _tintRGB: any;
  /**
   * The HTML source element for this SpriteMesh texture.
   * @type {HTMLImageElement|HTMLVideoElement|null}
   */
  get sourceElement(): HTMLVideoElement | HTMLImageElement | null;
  /**
   * Is this SpriteMesh rendering a video texture?
   * @type {boolean}
   */
  get isVideo(): boolean;
  /** @override */
  override _onTextureUpdate(): void;
  /** @override */
  override _onAnchorUpdate(): void;
  /**
   * Update uvs and push vertices and uv buffers on GPU if necessary.
   */
  updateUvs(): void;
  /**
   * Initialize shader based on the shader class type.
   * @param {class} shaderCls         Shader class used. Must inherit from AbstractBaseShader.
   */
  setShaderClass(shaderCls: class): void;
  shader: any;
  /** @override */
  override updateTransform(parentTransform: any): void;
  /** @override */
  override calculateVertices(): void;
  /** @override */
  override calculateTrimmedVertices(): any;
  /** @override */
  override _render(renderer: any): void;
  /** @override */
  override _renderToBatch(renderer: any): void;
  /** @override */
  override _renderDefault(renderer: any): void;
  /**
   * Update the batch data object.
   * TODO: temporary method until the upstream issue is fixed: https://github.com/pixijs/pixijs/issues/8511
   * @protected
   */
  protected _updateBatchData(): void;
  /** @override */
  override _calculateBounds(...args: any[]): any;
  /** @override */
  override getLocalBounds(...args: any[]): any;
  /** @override */
  override containsPoint(...args: any[]): any;
  /** @override */
  override destroy(...args: any[]): any;
  geometry: any;
  #private;
}
/**
 * @typedef {Object} CanvasAnimationAttribute
 * @property {string} attribute             The attribute name being animated
 * @property {Object} parent                The object within which the attribute is stored
 * @property {number} to                    The destination value of the attribute
 * @property {number} [from]                An initial value of the attribute, otherwise parent[attribute] is used
 * @property {number} [delta]               The computed delta between to and from
 * @property {number} [done]                The amount of the total delta which has been animated
 */
/**
 * @typedef {Object} CanvasAnimationOptions
 * @property {PIXI.DisplayObject} [context] A DisplayObject which defines context to the PIXI.Ticker function
 * @property {string} [name]                A unique name which can be used to reference the in-progress animation
 * @property {number} [duration]            A duration in milliseconds over which the animation should occur
 * @property {number} [priority]            A priority in PIXI.UPDATE_PRIORITY which defines when the animation
 *                                          should be evaluated related to others
 * @property {Function|string} [easing]     An easing function used to translate animation time or the string name
 *                                          of a static member of the CanvasAnimation class
 * @property {function(number, CanvasAnimationData)} [ontick] A callback function which fires after every frame
 */
/**
 * @typedef {CanvasAnimationOptions} CanvasAnimationData
 * @property {Function} fn                  The animation function being executed each frame
 * @property {number} time                  The current time of the animation, in milliseconds
 * @property {CanvasAnimationAttribute[]} attributes  The attributes being animated
 * @property {Promise} [promise]            A Promise which resolves once the animation is complete
 * @property {Function} [resolve]           The resolution function, allowing animation to be ended early
 * @property {Function} [reject]            The rejection function, allowing animation to be ended early
 */
/**
 * A helper class providing utility methods for PIXI Canvas animation
 */
declare class CanvasAnimation {
  static get ticker(): any;
  /**
   * Track an object of active animations by name, context, and function
   * This allows a currently playing animation to be referenced and terminated
   * @type {Object<string, CanvasAnimationData>}
   */
  static animations: {
    [x: string]: CanvasAnimationData;
  };
  /**
   * Apply an animation from the current value of some attribute to a new value
   * Resolve a Promise once the animation has concluded and the attributes have reached their new target
   *
   * @param {CanvasAnimationAttribute[]} attributes   An array of attributes to animate
   * @param {CanvasAnimationOptions} options          Additional options which customize the animation
   *
   * @returns {Promise}                               A Promise which resolves to true once the animation has concluded
   *                                                  or false if the animation was prematurely terminated
   *
   * @example Animate Token Position
   * ```js
   * let animation = [
   *   {
   *     parent: token,
   *     attribute: "x",
   *     to: 1000
   *   },
   *   {
   *     parent: token,
   *     attribute: "y",
   *     to: 2000
   *   }
   * ];
   * CanvasAnimation.animate(attributes, {duration:500});
   * ```
   */
  static animate(
    attributes: CanvasAnimationAttribute[],
    {
      context,
      name,
      duration,
      easing,
      ontick,
      priority,
    }?: CanvasAnimationOptions
  ): Promise<any>;
  /**
   * Retrieve an animation currently in progress by its name
   * @param {string} name             The animation name to retrieve
   * @returns {CanvasAnimationData}   The animation data, or undefined
   */
  static getAnimation(name: string): CanvasAnimationData;
  /**
   * If an animation using a certain name already exists, terminate it
   * @param {string} name       The animation name to terminate
   */
  static terminateAnimation(name: string): void;
  /**
   * Cosine based easing with smooth in-out.
   * @param {number} pt     The proportional animation timing on [0,1]
   * @returns {number}      The eased animation progress on [0,1]
   */
  static easeInOutCosine(pt: number): number;
  /**
   * Shallow ease out.
   * @param {number} pt     The proportional animation timing on [0,1]
   * @returns {number}      The eased animation progress on [0,1]
   */
  static easeOutCircle(pt: number): number;
  /**
   * Shallow ease in.
   * @param {number} pt     The proportional animation timing on [0,1]
   * @returns {number}      The eased animation progress on [0,1]
   */
  static easeInCircle(pt: number): number;
  /**
   * Generic ticker function to implement the animation.
   * This animation wrapper executes once per frame for the duration of the animation event.
   * Once the animated attributes have converged to their targets, it resolves the original Promise.
   * The user-provided ontick function runs each frame update to apply additional behaviors.
   *
   * @param {number} deltaTime                The incremental time which has elapsed
   * @param {CanvasAnimationData} animation   The animation which is being performed
   * @private
   */
  private static _animateFrame;
  /**
   * @alias CanvasAnimation.animate
   * @see {CanvasAnimation.animate}
   * @deprecated since v10
   * @ignore
   */
  static animateLinear(attributes: any, options: any): Promise<any>;
}
type CanvasAnimationAttribute = {
  /**
   * The attribute name being animated
   */
  attribute: string;
  /**
   * The object within which the attribute is stored
   */
  parent: Object;
  /**
   * The destination value of the attribute
   */
  to: number;
  /**
   * An initial value of the attribute, otherwise parent[attribute] is used
   */
  from?: number | undefined;
  /**
   * The computed delta between to and from
   */
  delta?: number | undefined;
  /**
   * The amount of the total delta which has been animated
   */
  done?: number | undefined;
};
type CanvasAnimationOptions = {
  /**
   * A DisplayObject which defines context to the PIXI.Ticker function
   */
  context?: any;
  /**
   * A unique name which can be used to reference the in-progress animation
   */
  name?: string | undefined;
  /**
   * A duration in milliseconds over which the animation should occur
   */
  duration?: number | undefined;
  /**
   * A priority in PIXI.UPDATE_PRIORITY which defines when the animation
   *             should be evaluated related to others
   */
  priority?: number | undefined;
  /**
   * An easing function used to translate animation time or the string name
   *      of a static member of the CanvasAnimation class
   */
  easing?: string | Function | undefined;
  /**
   * A callback function which fires after every frame
   */
  ontick?: ((arg0: number, arg1: CanvasAnimationData) => any) | undefined;
};
type CanvasAnimationData = CanvasAnimationOptions;
/**
 * A generic helper for drawing a standard Control Icon
 * @type {PIXI.Container}
 */
declare class ControlIcon {
  constructor(
    {
      texture,
      size,
      borderColor,
      tint,
    }?: {
      texture: any;
      size?: number | undefined;
      borderColor?: number | undefined;
      tint?: null | undefined;
    },
    ...args: any[]
  );
  iconSrc: any;
  size: number;
  rect: number[];
  borderColor: number;
  /**
   * The color of the icon tint, if any
   * @type {number|null}
   */
  tintColor: number | null;
  interactive: boolean;
  interactiveChildren: boolean;
  hitArea: PIXI.Rectangle;
  buttonMode: boolean;
  bg: any;
  icon: any;
  border: any;
  draw(): Promise<ControlIcon>;
  texture: any;
}
/**
 * Handle mouse interaction events for a Canvas object.
 * There are three phases of events: hover, click, and drag
 *
 * Hover Events:
 * _handleMouseOver
 *  action: hoverIn
 * _handleMouseOut
 *  action: hoverOut
 *
 * Left Click and Double-Click
 * _handleMouseDown
 *  action: clickLeft
 *  action: clickLeft2
 *
 * Right Click and Double-Click
 * _handleRightDown
 *  action: clickRight
 *  action: clickRight2
 *
 * Drag and Drop
 * _handleMouseMove
 *  action: dragLeftStart
 *  action: dragLeftMove
 *  action: dragRightStart
 *  action: dragLeftMove
 * _handleMouseUp
 *  action: dragLeftDrop
 *  action: dragRightDrop
 * _handleDragCancel
 *  action: dragLeftCancel
 *  action: dragRightCancel
 */
declare class MouseInteractionManager {
  /**
   * Enumerate the states of a mouse interaction workflow.
   * 0: NONE - the object is inactive
   * 1: HOVER - the mouse is hovered over the object
   * 2: CLICKED - the object is clicked
   * 3: DRAG - the object is being dragged
   * 4: DROP - the object is being dropped
   * @enum {number}
   */
  static INTERACTION_STATES: {
    NONE: number;
    HOVER: number;
    CLICKED: number;
    DRAG: number;
    DROP: number;
  };
  /**
   * The number of milliseconds of mouse click depression to consider it a long press.
   * @type {number}
   */
  static LONG_PRESS_DURATION_MS: number;
  /**
   * Global timeout for the long-press event.
   * @type {number|null}
   */
  static longPressTimeout: number | null;
  constructor(
    object: any,
    layer: any,
    permissions?: {},
    callbacks?: {},
    options?: {}
  );
  object: any;
  layer: any;
  permissions: {};
  callbacks: {};
  /**
   * Interaction options which configure handling workflows
   * @type {{target: PIXI.DisplayObject, dragResistance: number}}
   */
  options: {
    target: PIXI.DisplayObject;
    dragResistance: number;
  };
  /**
   * The current interaction state
   * @type {number}
   */
  state: number;
  /**
   * Bound handlers which can be added and removed
   * @type {Object<Function>}
   */
  handlers: any;
  /**
   * The drag handling time
   * @type {number}
   */
  dragTime: number;
  /**
   * The throttling time below which a mouse move event will not be handled
   * @type {number}
   * @private
   */
  private _dragThrottleMS;
  /**
   * The time of the last left-click event
   * @type {number}
   */
  lcTime: number;
  /**
   * The time of the last right-click event
   * @type {number}
   */
  rcTime: number;
  /**
   * A flag for whether we are right-click dragging
   * @type {boolean}
   */
  _dragRight: boolean;
  /**
   * An optional ControlIcon instance for the object
   * @type {ControlIcon}
   */
  controlIcon: ControlIcon;
  /**
   * Get the target
   * @return {*}
   */
  get target(): any;
  /**
   * Activate interactivity for the handled object
   */
  activate(): MouseInteractionManager;
  /**
   * Test whether the current user has permission to perform a step of the workflow
   * @param {string} action     The action being attempted
   * @param {Event} event       The event being handled
   * @returns {boolean}         Can the action be performed?
   */
  can(action: string, event: Event): boolean;
  /**
   * Execute a callback function associated with a certain action in the workflow
   * @param {string} action     The action being attempted
   * @param {Event} event       The event being handled
   * @param {...*} args         Additional callback arguments.
   */
  callback(action: string, event: Event, ...args: any[]): any;
  /**
   * A reference to the possible interaction states which can be observed
   * @return {Object<string, number>}
   */
  get states(): {
    [x: string]: number;
  };
  /**
   * Activate a set of listeners which handle hover events on the target object
   * @private
   */
  private _activateHoverEvents;
  /**
   * Activate a new set of listeners for click events on the target object
   * @private
   */
  private _activateClickEvents;
  /**
   * Deactivate event listeners for click events on the target object
   * @private
   */
  private _deactivateClickEvents;
  /**
   * Activate events required for handling a drag-and-drop workflow
   * @private
   */
  private _activateDragEvents;
  /**
   * Deactivate events required for handling drag-and-drop workflow.
   * @private
   */
  private _deactivateDragEvents;
  /**
   * Handle mouse-over events which activate downstream listeners and do not stop propagation.
   * @private
   */
  private _handleMouseOver;
  /**
   * Handle mouse-out events which terminate hover workflows and do not stop propagation.
   * @private
   */
  private _handleMouseOut;
  /**
   * Handle mouse-down events which activate downstream listeners.
   * Stop further propagation only if the event is allowed by either single or double-click.
   * @private
   */
  private _handleMouseDown;
  /**
   * Handle mouse-down which trigger a single left-click workflow.
   * @private
   */
  private _handleClickLeft;
  /**
   * Handle mouse-down which trigger a single left-click workflow.
   * @private
   */
  private _handleClickLeft2;
  /**
   * Handle a long mouse depression to trigger a long-press workflow.
   * @param {PIXI.InteractionEvent} event   The mousedown event.
   * @param {PIXI.Point}            origin  The local canvas co-ordinates of the mousepress.
   * @returns {*}
   * @private
   */
  private _handleLongPress;
  /**
   * Handle right-click mouse-down events.
   * Stop further propagation only if the event is allowed by either single or double-click.
   * @private
   */
  private _handleRightDown;
  /**
   * Handle single right-click actions.
   * @private
   */
  private _handleClickRight;
  /**
   * Handle double right-click actions.
   * @private
   */
  private _handleClickRight2;
  /**
   * Handle mouse movement during a drag workflow
   * @private
   */
  private _handleMouseMove;
  /**
   * Handle the beginning of a new drag start workflow, moving all controlled objects on the layer
   * @private
   */
  private _handleDragStart;
  /**
   * Handle the continuation of a drag workflow, moving all controlled objects on the layer
   * @private
   */
  private _handleDragMove;
  /**
   * Handle mouse up events which may optionally conclude a drag workflow
   * @private
   */
  private _handleMouseUp;
  /**
   * Handle the conclusion of a drag workflow, placing all dragged objects back on the layer
   * @private
   */
  private _handleDragDrop;
  /**
   * Handle the cancellation of a drag workflow, resetting back to the original state
   * @param {PointerEvent} event
   * @private
   */
  private _handleDragCancel;
  /**
   * A public method to cancel a current interaction workflow from this manager.
   * @param {Event} event     The event that initiates the cancellation
   */
  cancel(event: Event): void;
}
/**
 * Enumerate the states of a mouse interaction workflow.
 * 0: NONE - the object is inactive
 * 1: HOVER - the mouse is hovered over the object
 * 2: CLICKED - the object is clicked
 * 3: DRAG - the object is being dragged
 * 4: DROP - the object is being dropped
 */
type INTERACTION_STATES = number;
/**
 * @typedef {object} PingOptions
 * @property {number} [duration=900]   The duration of the animation in milliseconds.
 * @property {number} [size=128]       The size of the ping graphic.
 * @property {string} [color=#ff6400]  The color of the ping graphic.
 * @property {string} [name]           The name for the ping animation to pass to {@link CanvasAnimation.animate}.
 */
/**
 * A class to manage a user ping on the canvas.
 * @param {PIXI.Point} origin       The canvas co-ordinates of the origin of the ping.
 * @param {PingOptions} [options]   Additional options to configure the ping animation.
 */
declare class Ping {
  constructor(origin: any, options?: {});
  x: any;
  y: any;
  options: any;
  _color: any;
  /** @inheritdoc */
  destroy(options?: {}): void;
  /**
   * Start the ping animation.
   * @returns {Promise<boolean>}  Returns true if the animation ran to completion, false otherwise.
   */
  animate(): Promise<boolean>;
  /**
   * On each tick, advance the animation.
   * @param {number} dt                      The number of ms that elapsed since the previous frame.
   * @param {CanvasAnimationData} animation  The animation state.
   * @protected
   */
  protected _animateFrame(dt: number, animation: CanvasAnimationData): void;
}
type PingOptions = {
  /**
   * The duration of the animation in milliseconds.
   */
  duration?: number | undefined;
  /**
   * The size of the ping graphic.
   */
  size?: number | undefined;
  /**
   * The color of the ping graphic.
   */
  color?: string | undefined;
  /**
   * The name for the ping animation to pass to {@link CanvasAnimation.animate }.
   */
  name?: string | undefined;
};
/**
 * A type of ping that points to a specific location.
 * @param {PIXI.Point} origin      The canvas co-ordinates of the origin of the ping.
 * @param {PingOptions} [options]  Additional options to configure the ping animation.
 * @extends Ping
 */
declare class ChevronPing extends Ping {
  /**
   * The path to the chevron texture.
   * @type {string}
   * @private
   */
  private static _CHEVRON_PATH;
  _r: number;
  _rInner: number;
  _t14: number;
  _t12: number;
  _t34: number;
  _chevron: any;
  /** @inheritdoc */
  _animateFrame(dt: any, animation: any): void;
  /**
   * Draw the outer and inner rings.
   * @param {number} a  The alpha.
   * @private
   */
  private _drawRings;
  /**
   * Load the chevron texture.
   * @returns {Promise<PIXI.Sprite>}
   * @private
   */
  private _loadChevron;
  _h2: number | undefined;
  _y: number | undefined;
  /**
   * Draw the two rings that are used as part of the ping animation.
   * @returns {PIXI.Graphics[]}
   * @private
   */
  private _createRings;
  _outer: any;
  _inner: any;
}
/**
 * @typedef {PingOptions} PulsePingOptions
 * @property {number} [rings=3]         The number of rings used in the animation.
 * @property {string} [color2=#ffffff]  The alternate color that the rings begin at. Use white for a 'flashing' effect.
 */
/**
 * A type of ping that produces a pulsing animation.
 * @param {PIXI.Point} origin           The canvas co-ordinates of the origin of the ping.
 * @param {PulsePingOptions} [options]  Additional options to configure the ping animation.
 * @extends Ping
 */
declare class PulsePing extends Ping {
  constructor(
    origin: any,
    {
      rings,
      color2,
      ...options
    }?: {
      rings?: number | undefined;
      color2?: string | undefined;
    }
  );
  _color2: any;
  _r: number;
  _r0: number;
  /**
   * Initialize some time slice variables that will be used to control the animation.
   *
   * The animation for each ring can be separated into two consecutive stages.
   * Stage 1: Fade in a white ring with radius r0.
   * Stage 2: Expand radius outward. While the radius is expanding outward, we have two additional, consecutive
   * animations:
   *  Stage 2.1: Transition color from white to the configured color.
   *  Stage 2.2: Fade out.
   * 1/5th of the animation time is allocated to Stage 1. 4/5ths are allocated to Stage 2. Of those 4/5ths, 2/5ths
   * are allocated to Stage 2.1, and 2/5ths are allocated to Stage 2.2.
   * @private
   */
  private _computeTimeSlices;
  _timeSlice: number | undefined;
  _timeSlice2: number | undefined;
  _timeSlice15: number | undefined;
  _timeSlice25: number | undefined;
  _timeSlice45: number | undefined;
  filters: any[] | undefined;
  /** @inheritdoc */
  _animateFrame(dt: any, animation: any): void;
  /**
   * Transition linearly from one color to another.
   * @param {Color} from       The color to transition from.
   * @param {Color} to         The color to transition to.
   * @param {number} duration  The length of the transition in milliseconds.
   * @param {number} t         The current time along the duration.
   * @returns {number}         The incremental color between from and to.
   * @private
   */
  private _colorTransition;
  /**
   * Draw the shape for this ping.
   * @param {PIXI.Graphics} g  The graphics object to draw to.
   * @param {number} color     The color of the shape.
   * @param {number} alpha     The alpha of the shape.
   * @param {number} size      The size of the shape to draw.
   * @protected
   */
  protected _drawShape(
    g: any,
    color: number,
    alpha: number,
    size: number
  ): void;
}
/**
 * A type of ping that produces an arrow pointing in a given direction.
 * @property {PIXI.Point} origin            The canvas co-ordinates of the origin of the ping. This becomes the arrow's
 *                                          tip.
 * @property {PulsePingOptions} [options]   Additional options to configure the ping animation.
 * @property {number} [options.rotation=0]  The angle of the arrow in radians.
 * @extends PulsePing
 */
declare class ArrowPing extends PulsePing {
  constructor(
    origin: any,
    {
      rotation,
      ...options
    }?: {
      rotation?: number | undefined;
    }
  );
  rotation: any;
  /** @inheritdoc */
  _drawShape(g: any, color: any, alpha: any, size: any): void;
}
/**
 * A type of ping that produces a pulse warning sign animation.
 * @param {PIXI.Point} origin           The canvas co-ordinates of the origin of the ping.
 * @param {PulsePingOptions} [options]  Additional options to configure the ping animation.
 * @extends PulsePing
 */
declare class AlertPing extends PulsePing {
  constructor(
    origin: any,
    {
      color,
      ...options
    }?: {
      color?: string | undefined;
    }
  );
  _r: any;
  /** @inheritdoc */
  _drawShape(g: any, color: any, alpha: any, size: any): void;
}
type PulsePingOptions = PingOptions;
declare class ResizeHandle {
  constructor(offset: any, handlers?: {});
  offset: any;
  handlers: {};
  buttonMode: boolean;
  /**
   * Track whether the handle is being actively used for a drag workflow
   * @type {boolean}
   */
  active: boolean;
  refresh(bounds: any): void;
  hitArea: PIXI.Rectangle | undefined;
  updateDimensions(
    current: any,
    origin: any,
    destination: any,
    {
      aspectRatio,
    }?: {
      aspectRatio?: null | undefined;
    }
  ): {
    x: any;
    y: any;
    width: number;
    height: number;
  };
  activateListeners(): void;
  interactive: boolean | undefined;
  /**
   * Handle mouse-over event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseover event
   * @protected
   */
  protected _onHoverIn(event: PIXI.InteractionEvent): void;
  /**
   * Handle mouse-out event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseout event
   * @protected
   */
  protected _onHoverOut(event: PIXI.InteractionEvent): void;
  /**
   * When we start a drag event - create a preview copy of the Tile for re-positioning
   * @param {PIXI.InteractionEvent} event   The mousedown event
   * @protected
   */
  protected _onMouseDown(event: PIXI.InteractionEvent): void;
}
/**
 * A subclass of Set which manages the Token ids which the User has targeted.
 * @extends {Set}
 * @see User#targets
 */
declare class UserTargets extends Set<any> {
  constructor(user: any);
  user: any;
  /**
   * Return the Token IDs which are user targets
   * @type {string[]}
   */
  get ids(): string[];
  /** @override */
  override add(token: any): void;
  /** @override */
  override delete(token: any): void;
  /**
   * Dispatch the targetToken hook whenever the user's target set changes
   * @private
   */
  private _hook;
}
/**
 * Test whether a file source exists by performing a HEAD request against it
 * @param {string} src          The source URL or path to test
 * @returns {Promise<boolean>}   Does the file exist at the provided url?
 */
declare function srcExists(src: string): Promise<boolean>;
/**
 * Get a single texture from the cache
 * @param {string} src
 * @returns {PIXI.Texture}
 */
declare function getTexture(src: string): PIXI.Texture;
/**
 * Load a single texture and return a Promise which resolves once the texture is ready to use
 * @param {string} src                The requested texture source
 * @param {object} [options]          Additional options which modify texture loading
 * @param {string} [options.fallback]     A fallback texture URL to use if the requested source is unavailable
 * @returns {PIXI.Texture|null}        The loaded Texture, or null if loading failed with no fallback
 */
declare function loadTexture(
  src: string,
  {
    fallback,
  }?:
    | {
        fallback?: string | undefined;
      }
    | undefined
): PIXI.Texture | null;
/**
 * A Loader class which helps with loading video and image textures.
 */
declare class TextureLoader {
  /**
   * The duration in milliseconds for which a texture will remain cached
   * @type {number}
   */
  static CACHE_TTL: number;
  /**
   * Load all the textures which are required for a particular Scene
   * @param {Scene} scene           The Scene to load
   * @param {object} [options={}]   Additional options that configure texture loading
   * @param {boolean} [options.expireCache=true]  Destroy other expired textures
   * @returns {Promise<void[]>}
   */
  static loadSceneTextures(
    scene: Scene,
    {
      expireCache,
    }?:
      | {
          expireCache?: boolean | undefined;
        }
      | undefined
  ): Promise<void[]>;
  /**
   * Use the Fetch API to retrieve a resource and return a Blob instance for it.
   * @param {string} src
   * @param {object} [options]                   Options to configure the loading behaviour.
   * @param {boolean} [options.bustCache=false]  Append a cache-busting query parameter to the request.
   * @returns {Promise<Blob>}                    A Blob containing the loaded data
   */
  static fetchResource(
    src: string,
    {
      bustCache,
    }?:
      | {
          bustCache?: boolean | undefined;
        }
      | undefined
  ): Promise<Blob>;
  /**
   * Log texture loading progress in the console and in the Scene loading bar
   * @param {string} src          The source URL being loaded
   * @param {object} progress     Loading progress
   * @private
   */
  private static "__#29@#onProgress";
  /**
   * Log failed texture loading
   * @param {string} src          The source URL being loaded
   * @param {object} progress     Loading progress
   * @param {Error} error         The error which occurred
   * @private
   */
  private static "__#29@#onError";
  /**
   * Return a URL with a cache-busting query parameter appended.
   * @param {string} src        The source URL being attempted
   * @returns {string|boolean}  The new URL, or false on a failure.
   */
  static getCacheBustURL(src: string): string | boolean;
  /**
   * Load an Array of provided source URL paths
   * @param {string[]} sources      The source URLs to load
   * @param {object} [options={}]   Additional options which modify loading
   * @param {string} [options.message]              The status message to display in the load bar
   * @param {boolean} [options.expireCache=false]   Expire other cached textures?
   * @returns {Promise<void[]>}     A Promise which resolves once all textures are loaded
   */
  load(
    sources: string[],
    {
      message,
      expireCache,
    }?:
      | {
          message?: string | undefined;
          expireCache?: boolean | undefined;
        }
      | undefined
  ): Promise<void[]>;
  /**
   * Load a single texture on-demand from a given source URL path
   * @param {string} src                    The source texture path to load
   * @returns {Promise<PIXI.BaseTexture>}   The loaded texture object
   */
  loadTexture(src: string): Promise<PIXI.BaseTexture>;
  /**
   * Load an image texture from a provided source url.
   * @param {string} src                    The source image URL
   * @returns {Promise<PIXI.BaseTexture>}   The loaded BaseTexture
   */
  loadImageTexture(src: string): Promise<PIXI.BaseTexture>;
  /**
   * Load a video texture from a provided source url
   * @param {string} src                    The source video URL
   * @returns {Promise<PIXI.BaseTexture>}   The loaded BaseTexture
   */
  loadVideoTexture(src: string): Promise<PIXI.BaseTexture>;
  /**
   * Add an image url to the texture cache
   * @param {string} src              The source URL
   * @param {PIXI.BaseTexture} tex    The loaded base texture
   */
  setCache(src: string, tex: PIXI.BaseTexture): void;
  /**
   * Retrieve a texture from the texture cache
   * @param {string} src          The source URL
   * @returns {PIXI.BaseTexture}  The cached texture, or undefined
   */
  getCache(src: string): PIXI.BaseTexture;
  /**
   * Expire (and destroy) textures from the cache which have not been used for more than CACHE_TTL milliseconds.
   */
  expireCache(): void;
  #private;
}
declare namespace TextureLoader {
  const loader: TextureLoader;
}
/**
 * A special class of Polygon which implements a limited angle of emission for a Point Source.
 * The shape is defined by a point origin, radius, angle, and rotation.
 * The shape is further customized by a configurable density which informs the approximation.
 * An optional secondary externalRadius can be provided which adds supplementary visibility outside the primary angle.
 */
declare class LimitedAnglePolygon extends PIXI.Polygon {
  /**
   * Test whether a vertex lies between two boundary rays.
   * If the angle is greater than 180, test for points between rMax and rMin (inverse).
   * Otherwise, keep vertices that are between the rays directly.
   * @param {Point} point             The candidate point
   * @param {PolygonRay} rMin         The counter-clockwise bounding ray
   * @param {PolygonRay} rMax         The clockwise bounding ray
   * @param {number} angle            The angle being tested, in degrees
   * @returns {boolean}               Is the vertex between the two rays?
   */
  static pointBetweenRays(
    point: Point,
    rMin: PolygonRay,
    rMax: PolygonRay,
    angle: number
  ): boolean;
  constructor(
    origin: any,
    {
      radius,
      angle,
      rotation,
      density,
      externalRadius,
    }?: {
      radius: any;
      angle?: number | undefined;
      rotation?: number | undefined;
      density: any;
      externalRadius?: number | undefined;
    }
  );
  /**
   * The origin point of the Polygon
   * @type {Point}
   */
  origin: Point;
  /**
   * The radius of the emitted cone.
   * @type {number}
   */
  radius: number;
  /**
   * The angle of the Polygon in degrees.
   * @type {number}
   */
  angle: number;
  /**
   * The direction of rotation at the center of the emitted angle in degrees.
   * @type {number}
   */
  rotation: number;
  /**
   * The density of rays which approximate the cone, defined as rays per PI.
   * @type {number}
   */
  density: number;
  /**
   * An optional "external radius" which is included in the polygon for the supplementary area outside the cone.
   * @type {number}
   */
  externalRadius: number;
  /**
   * The angle of the left (counter-clockwise) edge of the emitted cone in radians.
   * @type {number}
   */
  aMin: number;
  /**
   * The angle of the right (clockwise) edge of the emitted cone in radians.
   * @type {number}
   */
  aMax: number;
  /**
   * The bounding box of the circle defined by the externalRadius, if any
   * @type {PIXI.Rectangle}
   */
  externalBounds: PIXI.Rectangle;
  /**
   * Restrict the edges which should be included in a PointSourcePolygon based on this specialized shape.
   * We use two tests to jointly keep or reject edges.
   * 1. If this shape uses an externalRadius, keep edges which collide with the bounding box of that circle.
   * 2. Keep edges which are contained within or collide with one of the primary angle boundary rays.
   * @param {Point} a             The first edge vertex
   * @param {Point} b             The second edge vertex
   * @returns {boolean}           Should the edge be included in the PointSourcePolygon computation?
   * @internal
   */
  _includeEdge(a: Point, b: Point): boolean;
  #private;
}
/**
 * An internal data structure for polygon vertices
 * @private
 * @ignore
 */
declare class PolygonVertex {
  /**
   * The effective maximum texture size that Foundry VTT "ever" has to worry about.
   * @type {number}
   */
  static "__#34@#MAX_TEXTURE_SIZE": number;
  /**
   * Determine the sort key to use for this vertex, arranging points from north-west to south-east.
   * @param {number} x    The x-coordinate
   * @param {number} y    The y-coordinate
   */
  static "__#34@#getSortKey"(x: number, y: number): number;
  /**
   * Construct a PolygonVertex instance from some other Point structure.
   * @param {Point} point           The point
   * @param {object} [options]      Additional options that apply to this vertex
   * @returns {PolygonVertex}       The constructed vertex
   */
  static fromPoint(point: Point, options?: object | undefined): PolygonVertex;
  constructor(
    x: any,
    y: any,
    {
      distance,
      index,
    }?: {
      distance: any;
      index: any;
    }
  );
  x: number;
  y: number;
  key: number;
  _distance: any;
  _d2: any;
  _index: any;
  /**
   * The set of edges which connect to this vertex.
   * This set is initially empty and populated later after vertices are de-duplicated.
   * @type {EdgeSet}
   */
  edges: EdgeSet;
  /**
   * The subset of edges which continue clockwise from this vertex.
   * @type {EdgeSet}
   */
  cwEdges: EdgeSet;
  /**
   * The subset of edges which continue counter-clockwise from this vertex.
   * @type {EdgeSet}
   */
  ccwEdges: EdgeSet;
  /**
   * The set of vertices collinear to this vertex
   * @type {Set<PolygonVertex>}
   */
  collinearVertices: Set<PolygonVertex>;
  /**
   * The maximum restriction type of this vertex
   * @type {number|null}
   */
  type: number | null;
  /**
   * Is this vertex an endpoint of one or more edges?
   * @type {boolean}
   */
  isEndpoint: boolean;
  /**
   * Does this vertex have a single counterclockwise limiting edge?
   * @type {boolean}
   */
  isLimitingCCW: boolean;
  /**
   * Does this vertex have a single clockwise limiting edge?
   * @type {boolean}
   */
  isLimitingCW: boolean;
  /**
   * Does this vertex have non-limited edges or 2+ limited edges counterclockwise?
   * @type {boolean}
   */
  isBlockingCCW: boolean;
  /**
   * Does this vertex have non-limited edges or 2+ limited edges clockwise?
   * @type {boolean}
   */
  isBlockingCW: boolean;
  /**
   * Associate an edge with this vertex.
   * @param {PolygonEdge} edge      The edge being attached
   * @param {number} orientation    The orientation of the edge with respect to the origin
   */
  attachEdge(edge: PolygonEdge, orientation?: number): void;
  /**
   * Is this vertex limited in type?
   * @returns {boolean}
   */
  get isLimited(): boolean;
  /**
   * Is this vertex terminal (at the maximum radius)
   * @returns {boolean}
   */
  get isTerminal(): boolean;
  /**
   * Is this vertex the same point as some other vertex?
   * @param {PolygonVertex} other   Some other vertex
   * @returns {boolean}             Are they the same point?
   */
  equals(other: PolygonVertex): boolean;
  #private;
}
/**
 * An internal data structure for polygon edges
 * @private
 * @ignore
 */
declare class PolygonEdge {
  /**
   * Construct a PolygonEdge instance from a Wall placeable object.
   * @param {Wall|WallDocument} wall  The Wall from which to construct an edge
   * @param {string} type             The type of polygon being constructed
   * @returns {PolygonEdge}
   */
  static fromWall(wall: Function | WallDocument, type: string): PolygonEdge;
  constructor(a: any, b: any, type: any, wall: any);
  A: PolygonVertex;
  B: PolygonVertex;
  type: any;
  wall: any;
  /**
   * An internal flag used to record whether an Edge represents a canvas boundary.
   * @type {boolean}
   * @internal
   */
  _isBoundary: boolean;
  /**
   * Is this edge limited in type?
   * @returns {boolean}
   */
  get isLimited(): boolean;
}
/**
 * An object containing the result of a collision test.
 * @private
 * @ignore
 */
declare class CollisionResult {
  constructor({
    target,
    collisions,
    cwEdges,
    ccwEdges,
    isBehind,
    isLimited,
    wasLimited,
  }?: {
    target?: null | undefined;
    collisions?: any[] | undefined;
    cwEdges: any;
    ccwEdges: any;
    isBehind: any;
    isLimited: any;
    wasLimited: any;
  });
  /**
   * The vertex that was the target of this result
   * @type {PolygonVertex}
   */
  target: PolygonVertex;
  /**
   * The array of collision points which apply to this result
   * @type {PolygonVertex[]}
   */
  collisions: PolygonVertex[];
  /**
   * The set of edges connected to the target vertex that continue clockwise
   * @type {EdgeSet}
   */
  cwEdges: EdgeSet;
  /**
   * The set of edges connected to the target vertex that continue counter-clockwise
   * @type {EdgeSet}
   */
  ccwEdges: EdgeSet;
  /**
   * Is the target vertex for this result behind some closer active edge?
   * @type {boolean}
   */
  isBehind: boolean;
  /**
   * Does the target vertex for this result impose a limited collision?
   * @type {boolean}
   */
  isLimited: boolean;
  /**
   * Has the set of collisions for this result encountered a limited edge?
   * @type {boolean}
   */
  wasLimited: boolean;
  /**
   * Is this result limited in the clockwise direction?
   * @type {boolean}
   */
  limitedCW: boolean;
  /**
   * Is this result limited in the counter-clockwise direction?
   * @type {boolean}
   */
  limitedCCW: boolean;
  /**
   * Is this result blocking in the clockwise direction?
   * @type {boolean}
   */
  blockedCW: boolean;
  /**
   * Is this result blocking in the counter-clockwise direction?
   * @type {boolean}
   */
  blockedCCW: boolean;
  /**
   * Previously blocking in the clockwise direction?
   * @type {boolean}
   */
  blockedCWPrev: boolean;
  /**
   * Previously blocking in the counter-clockwise direction?
   */
  blockedCCWPrev: boolean;
}
/**
 * A helper class used to construct triangulated polygon meshes
 * Allow to add padding and a specific depth value.
 * @param {number[]|PIXI.Polygon} poly      Closed polygon to be processed and converted to a mesh
 *                                          (array of points or PIXI Polygon)
 * @param {object|{}} options               Various options : normalizing, offsetting, add depth, ...
 */
declare class PolygonMesher {
  /**
   * Default options values
   * @type {Object<string,boolean|number>}
   */
  static _defaultOptions: {
    [x: string]: boolean | number;
  };
  /**
   * Convert a flat points array into a 2 dimensional ClipperLib path
   * @param {number[]|PIXI.Polygon} poly             PIXI.Polygon or points flat array.
   * @param {number} [dimension=2]                   Dimension.
   * @returns {number[]|undefined}                   The clipper lib path.
   */
  static getClipperPathFromPoints(
    poly: number[] | PIXI.Polygon,
    dimension?: number | undefined
  ): number[] | undefined;
  constructor(poly: any, options?: {});
  /**
   * Contains options to apply during the meshing process
   * @type {Object<string,boolean|number>}
   */
  options: {
    [x: string]: boolean | number;
  };
  /**
   * Polygon mesh vertices
   * @type {number[]}
   */
  vertices: number[];
  /**
   * Polygon mesh indices
   * @type {number[]}
   */
  indices: number[];
  /**
   * Execute the triangulation to create indices
   * @param {PIXI.Geometry} geometry    A geometry to update
   * @returns {PIXI.Geometry}           The resulting geometry
   */
  triangulate(geometry: PIXI.Geometry): PIXI.Geometry;
  #private;
}
/**
 * An extension of the default PIXI.Text object which forces double resolution.
 * At default resolution Text often looks blurry or fuzzy.
 */
declare class PreciseText {
  /**
   * Prepare a TextStyle object which merges the canvas defaults with user-provided options
   * @param {object} [options={}]   Additional options merged with the default TextStyle
   * @param {number} [options.anchor]       A text anchor point from CONST.TEXT_ANCHOR_POINTS
   * @returns {PIXI.TextStyle}      The prepared TextStyle
   */
  static getTextStyle({
    anchor,
    ...options
  }?:
    | {
        anchor?: number | undefined;
      }
    | undefined): PIXI.TextStyle;
  constructor(...args: any[]);
  _autoResolution: boolean;
  _resolution: number;
}
/**
 * @typedef {Object} RayIntersection
 * @property {number} x     The x-coordinate of intersection
 * @property {number} y     The y-coordinate of intersection
 * @property {number} t0    The proximity to the Ray origin, as a ratio of distance
 * @property {number} t1    The proximity to the Ray destination, as a ratio of distance
 */
/**
 * A ray for the purposes of computing sight and collision
 * Given points A[x,y] and B[x,y]
 *
 * Slope-Intercept form:
 * y = a + bx
 * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
 *
 * Parametric form:
 * R(t) = (1-t)A + tB
 *
 * @param {Point} A      The origin of the Ray
 * @param {Point} B      The destination of the Ray
 */
declare class Ray {
  /**
   * A factory method to construct a Ray from an origin point, an angle, and a distance
   * @param {number} x          The origin x-coordinate
   * @param {number} y          The origin y-coordinate
   * @param {number} radians    The ray angle in radians
   * @param {number} distance   The distance of the ray in pixels
   * @returns {Ray}             The constructed Ray instance
   */
  static fromAngle(
    x: number,
    y: number,
    radians: number,
    distance: number
  ): Ray;
  /**
   * A factory method to construct a Ray from points in array format.
   * @param {number[]} A    The origin point [x,y]
   * @param {number[]} B    The destination point [x,y]
   * @returns {Ray}         The constructed Ray instance
   */
  static fromArrays(A: number[], B: number[]): Ray;
  /**
   * Create a Ray by projecting a certain distance towards a known point.
   * @param {Point} origin      The origin of the Ray
   * @param {Point} point       The point towards which to project
   * @param {number} distance   The distance of projection
   * @returns {Ray}
   */
  static towardsPoint(origin: Point, point: Point, distance: number): Ray;
  /**
   * Create a Ray by projecting a certain squared-distance towards a known point.
   * @param {Point} origin      The origin of the Ray
   * @param {Point} point       The point towards which to project
   * @param {number} distance2  The squared distance of projection
   * @returns {Ray}
   */
  static towardsPointSquared(
    origin: Point,
    point: Point,
    distance2: number
  ): Ray;
  constructor(A: any, B: any);
  /**
   * The origin point, {x, y}
   * @type {Point}
   */
  A: Point;
  /**
   * The destination point, {x, y}
   * @type {Point}
   */
  B: Point;
  /**
   * The origin y-coordinate
   * @type {number}
   */
  y0: number;
  /**
   * The origin x-coordinate
   * @type {number}
   */
  x0: number;
  /**
   * The horizontal distance of the ray, x1 - x0
   * @type {number}
   */
  dx: number;
  /**
   * The vertical distance of the ray, y1 - y0
   * @type {number}
   */
  dy: number;
  /**
   * The slope of the ray, dy over dx
   * @type {number}
   */
  slope: number;
  /**
   * The cached angle, computed lazily in Ray#angle
   * @type {number}
   * @private
   */
  private _angle;
  /**
   * The cached distance, computed lazily in Ray#distance
   * @type {number}
   * @private
   */
  private _distance;
  set angle(arg: number);
  /**
   * The normalized angle of the ray in radians on the range (-PI, PI).
   * The angle is computed lazily (only if required) and cached.
   * @type {number}
   */
  get angle(): number;
  /**
   * A normalized bounding rectangle that encompasses the Ray
   * @type {PIXI.Rectangle}
   */
  get bounds(): PIXI.Rectangle;
  set distance(arg: number);
  /**
   * The distance (length) of the Ray in pixels.
   * The distance is computed lazily (only if required) and cached.
   * @type {number}
   */
  get distance(): number;
  /**
   * Project the Array by some proportion of it's initial distance.
   * Return the coordinates of that point along the path.
   * @param {number} t    The distance along the Ray
   * @returns {Object}    The coordinates of the projected point
   */
  project(t: number): Object;
  /**
   * Reverse the direction of the Ray, returning a second Ray
   * @returns {Ray}
   */
  reverse(): Ray;
  /**
   * Create a new ray which uses the same origin point, but a slightly offset angle and distance
   * @param {number} offset       An offset in radians which modifies the angle of the original Ray
   * @param {number} [distance]   A distance the new ray should project, otherwise uses the same distance.
   * @return {Ray}                A new Ray with an offset angle
   */
  shiftAngle(offset: number, distance?: number | undefined): Ray;
  /**
   * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
   * @see foundry.utils.lineLineIntersection
   */
  intersectSegment(coords: any): any;
}
type RayIntersection = {
  /**
   * The x-coordinate of intersection
   */
  x: number;
  /**
   * The y-coordinate of intersection
   */
  y: number;
  /**
   * The proximity to the Ray origin, as a ratio of distance
   */
  t0: number;
  /**
   * The proximity to the Ray destination, as a ratio of distance
   */
  t1: number;
};
/**
 * @typedef {Object} PointSourcePolygonConfig
 * @property {string} [type]        The type of polygon being computed
 * @property {number} [angle=360]   The angle of emission, if limited
 * @property {number} [density]     The desired density of padding rays, a number per PI
 * @property {number} [radius]      A limited radius of the resulting polygon
 * @property {number} [rotation]    The direction of facing, required if the angle is limited
 * @property {boolean} [debug]      Display debugging visualization and logging for the polygon
 * @property {boolean} [walls]      Is this polygon constrained by any walls?
 * @property {PointSource} [source] The object (if any) that spawned this polygon.
 * @property {Array<PIXI.Rectangle|PIXI.Circle|PIXI.Polygon>} [boundaryShapes] Limiting polygon boundary shapes
 */
/**
 * An extension of the default PIXI.Polygon which is used to represent the line of sight for a point source.
 * @extends {PIXI.Polygon}
 */
declare class PointSourcePolygon extends PIXI.Polygon {
  /**
   * Benchmark the performance of polygon computation for this source
   * @param {number} iterations                 The number of test iterations to perform
   * @param {Point} origin                      The origin point to benchmark
   * @param {PointSourcePolygonConfig} config   The polygon configuration to benchmark
   */
  static benchmark(
    iterations: number,
    origin: Point,
    config: PointSourcePolygonConfig
  ): any;
  /**
   * Compute the polygon given a point origin and radius
   * @param {Point} origin                          The origin source point
   * @param {PointSourcePolygonConfig} [config={}]  Configuration options which customize the polygon computation
   * @returns {PointSourcePolygon}                  The computed polygon instance
   */
  static create(
    origin: Point,
    config?: PointSourcePolygonConfig | undefined
  ): PointSourcePolygon;
  /**
   * Test whether a Ray between the origin and destination points would collide with a boundary of this Polygon.
   * A valid wall restriction type is compulsory and must be passed into the config options.
   * @param {Point} origin                          An origin point
   * @param {Point} destination                     A destination point
   * @param {PointSourcePolygonConfig} config       The configuration that defines a certain Polygon type
   * @param {string} [config.mode]                  The collision mode to test: "any", "all", or "closest"
   * @returns {boolean|PolygonVertex|PolygonVertex[]|null} The collision result depends on the mode of the test:
   *                                                * any: returns a boolean for whether any collision occurred
   *                                                * all: returns a sorted array of PolygonVertex instances
   *                                                * closest: returns a PolygonVertex instance or null
   */
  static testCollision(
    origin: Point,
    destination: Point,
    { mode, ...config }?: PointSourcePolygonConfig
  ): boolean | PolygonVertex | PolygonVertex[] | null;
  /**
   * The rectangular bounds of this polygon
   * @type {PIXI.Rectangle}
   */
  bounds: PIXI.Rectangle;
  /**
   * The origin point of the source polygon.
   * @type {Point}
   */
  origin: Point;
  /**
   * The configuration of this polygon.
   * @type {PointSourcePolygonConfig}
   */
  config: PointSourcePolygonConfig;
  /**
   * A cached array of SightRay objects used to compute the polygon.
   * @type {PolygonRay[]}
   */
  rays: PolygonRay[];
  /**
   * An indicator for whether this polygon is constrained by some boundary shape?
   * @type {boolean}
   */
  get isConstrained(): boolean;
  /** @inheritDoc */
  contains(x: any, y: any): any;
  /**
   * Compute the polygon using the origin and configuration options.
   * @returns {PointSourcePolygon}    The computed polygon
   */
  compute(): PointSourcePolygon;
  /**
   * Perform the implementation-specific computation
   * @protected
   */
  protected _compute(): void;
  /**
   * Customize the provided configuration object for this polygon type.
   * @param {Point} origin                        The provided polygon origin
   * @param {PointSourcePolygonConfig} config     The provided configuration object
   */
  initialize(origin: Point, config: PointSourcePolygonConfig): void;
  /**
   * Apply a constraining boundary shape to an existing PointSourcePolygon.
   * Return a new instance of the polygon with the constraint applied.
   * The new instance is only a "shallow clone", as it shares references to component properties with the original.
   * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Polygon} constraint      The constraining boundary shape
   * @param {object} [intersectionOptions]                            Options passed to the shape intersection method
   * @returns {PointSourcePolygon}                                    A new constrained polygon
   */
  applyConstraint(
    constraint: PIXI.Circle | PIXI.Rectangle | PIXI.Polygon,
    intersectionOptions?: object | undefined
  ): PointSourcePolygon;
  /**
   * Determine the set of collisions which occurs for a Ray.
   * @param {Ray} ray                           The Ray to test
   * @param {string} mode                       The collision mode being tested
   * @returns {boolean|PolygonVertex|PolygonVertex[]|null} The collision test result
   * @protected
   * @abstract
   */
  protected _testCollision(
    ray: Ray,
    mode: string
  ): boolean | PolygonVertex | PolygonVertex[] | null;
  /**
   * Visualize the polygon, displaying its computed area, rays, and collision points
   */
  visualize(): void;
}
type PointSourcePolygonConfig = {
  /**
   * The type of polygon being computed
   */
  type?: string | undefined;
  /**
   * The angle of emission, if limited
   */
  angle?: number | undefined;
  /**
   * The desired density of padding rays, a number per PI
   */
  density?: number | undefined;
  /**
   * A limited radius of the resulting polygon
   */
  radius?: number | undefined;
  /**
   * The direction of facing, required if the angle is limited
   */
  rotation?: number | undefined;
  /**
   * Display debugging visualization and logging for the polygon
   */
  debug?: boolean | undefined;
  /**
   * Is this polygon constrained by any walls?
   */
  walls?: boolean | undefined;
  /**
   * The object (if any) that spawned this polygon.
   */
  source?: PointSource | undefined;
  /**
   * Limiting polygon boundary shapes
   */
  boundaryShapes?: (PIXI.Polygon | PIXI.Circle | PIXI.Rectangle)[] | undefined;
};
/**
 * A container group which contains visual effects rendered above the primary group.
 *
 * ### Hook Events
 * - {@link hookEvents.drawEffectsCanvasGroup}
 * - {@link hookEvents.createEffectsCanvasGroup}
 * - {@link hookEvents.lightingRefresh}
 *
 * @category - Canvas
 */
declare class EffectsCanvasGroup {
  /**
   * The current global light source.
   * @type {LightSource}
   */
  globalLightSource: LightSource;
  /**
   * Whether to currently animate light sources.
   * @type {boolean}
   */
  animateLightSources: boolean;
  /**
   * Whether to currently animate vision sources.
   * @type {boolean}
   */
  animateVisionSources: boolean;
  /**
   * A mapping of light sources which are active within the rendered Scene.
   * @type {Collection<string, LightSource>}
   */
  lightSources: Collection<string, LightSource>;
  /**
   * A Collection of vision sources which are currently active within the rendered Scene.
   * @type {Collection<string, VisionSource>}
   */
  visionSources: Collection<string, VisionSource>;
  /**
   * A set of vision mask filters used in visual effects group
   * @type {Set<VisualEffectsMaskingFilter>}
   */
  visualEffectsMaskingFilters: Set<VisualEffectsMaskingFilter> | undefined;
  /**
   * A layer of background alteration effects which change the appearance of the primary group render texture.
   * @type {CanvasBackgroundAlterationEffects}
   */
  background: CanvasBackgroundAlterationEffects | undefined;
  /**
   * A layer which adds illumination-based effects to the scene.
   * @type {CanvasIlluminationEffects}
   */
  illumination: CanvasIlluminationEffects | undefined;
  /**
   * A layer which adds color-based effects to the scene.
   * @type {CanvasColorationEffects}
   */
  coloration: CanvasColorationEffects | undefined;
  /**
   * A layer which controls the current visibility of the scene.
   * @type {CanvasVisibility}
   */
  visibility: CanvasVisibility | undefined;
  /**
   * Clear all effects containers and animated sources.
   */
  clearEffects(): void;
  /**
   * Draw the component layers of the canvas group.
   * @returns {Promise<void>}
   */
  draw(): Promise<void>;
  /**
   * Initialize LightSource objects for all AmbientLightDocument instances which exist within the active Scene.
   */
  initializeLightSources(): void;
  /**
   * Update the global light source which provide global illumination to the Scene.
   * @returns {GlobalLightSource}
   * @protected
   */
  protected _updateGlobalLightSource(): GlobalLightSource;
  /**
   * Refresh the state and uniforms of all LightSource objects.
   */
  refreshLightSources(): void;
  /**
   * Refresh the state and uniforms of all LightSource objects.
   */
  refreshVisionSources(): void;
  /**
   * Refresh the active display of lighting.
   */
  refreshLighting(): void;
  /**
   * Perform a deconstruction workflow for this canvas group when the canvas is retired.
   * @returns {Promise<void>}
   */
  tearDown(): Promise<void>;
  /**
   * Activate vision masking for visual effects
   * @param {boolean} [enabled=true]    Whether to enable or disable vision masking
   */
  toggleMaskingFilters(enabled?: boolean | undefined): void;
  /**
   * Activate post-processing effects for a certain effects channel.
   * @param {string} filterMode                     The filter mode to target.
   * @param {string[]} [postProcessingModes=[]]     The post-processing modes to apply to this filter.
   * @param {Object} [uniforms={}]                  The uniforms to update.
   */
  activatePostProcessingFilters(
    filterMode: string,
    postProcessingModes?: string[] | undefined,
    uniforms?: Object | undefined
  ): void;
  /**
   * Reset post-processing modes on all Visual Effects masking filters.
   */
  resetPostProcessingFilters(): void;
  /**
   * Activate light source animation for AmbientLight objects within this layer
   */
  activateAnimation(): void;
  /**
   * Deactivate light source animation for AmbientLight objects within this layer
   */
  deactivateAnimation(): void;
  /**
   * Animate a smooth transition of the darkness overlay to a target value.
   * Only begin animating if another animation is not already in progress.
   * @param {number} target     The target darkness level between 0 and 1
   * @param {number} duration   The desired animation time in milliseconds. Default is 10 seconds
   * @returns {Promise}         A Promise which resolves once the animation is complete
   */
  animateDarkness(target?: number, { duration }?: number): Promise<any>;
  #private;
}
/**
 * A container group which contains the primary canvas group and the effects canvas group.
 *
 * @category - Canvas
 */
declare class EnvironmentCanvasGroup {
  /** @override */
  static override groupName: string;
  /** @override */
  override tearDown(options?: {}): Promise<void>;
}
/**
 * A specialized canvas group for rendering hidden containers before all others (like masks).
 * @extends {PIXI.Container}
 */
declare class HiddenCanvasGroup {
  /** @override */
  static override groupName: string;
  interactive: boolean;
  interactiveChildren: boolean;
  /**
   * The container which hold masks.
   * @type {PIXI.Container}
   */
  masks: PIXI.Container;
  /**
   * Add a mask to this group.
   * @param {string} name                           Name of the mask.
   * @param {PIXI.DisplayObject} displayObject      Display object to add.
   * @param {number|undefined} [position=undefined] Position of the mask.
   */
  addMask(
    name: string,
    displayObject: PIXI.DisplayObject,
    position?: number | undefined
  ): void;
  /** @override */
  override draw(): Promise<void>;
  /** @override */
  override tearDown(): Promise<void>;
  #private;
}
/**
 * A container group which displays interface elements rendered above other canvas groups.
 * @extends {BaseCanvasMixin(PIXI.Container)}
 */
declare class InterfaceCanvasGroup {
  /** @override */
  static override groupName: string;
  /**
   * Draw the canvas group and all its component layers.
   * @returns {Promise<void>}
   */
  draw(): Promise<void>;
  reverseMaskfilter: any;
  /**
   * Display scrolling status text originating from this ObjectHUD container.
   * @param {Point} origin            An origin point where the text should first emerge
   * @param {string} content          The text content to display
   * @param {object} [options]        Options which customize the text animation
   * @param {number} [options.duration=2000]  The duration of the scrolling effect in milliseconds
   * @param {number} [options.distance]       The distance in pixels that the scrolling text should travel
   * @param {TEXT_ANCHOR_POINTS} [options.anchor]     The original anchor point where the text appears
   * @param {TEXT_ANCHOR_POINTS} [options.direction]  The direction in which the text scrolls
   * @param {number} [options.jitter=0]       An amount of randomization between [0, 1] applied to the initial position
   * @param {object} [options.textStyle={}]   Additional parameters of PIXI.TextStyle which are applied to the text
   * @returns {Promise<PreciseText|null>}   The created PreciseText object which is scrolling
   */
  createScrollingText(
    origin: Point,
    content: string,
    {
      duration,
      distance,
      jitter,
      anchor,
      direction,
      ...textStyle
    }?:
      | {
          duration?: number | undefined;
          distance?: number | undefined;
          anchor?: any;
          direction?: any;
          jitter?: number | undefined;
          textStyle?: object | undefined;
        }
      | undefined
  ): Promise<PreciseText | null>;
  #private;
}
/**
 * The primary Canvas group which generally contains tangible physical objects which exist within the Scene.
 * This group is a {@link CachedContainer} which is rendered to the Scene as a {@link SpriteMesh}.
 * This allows the rendered result of the Primary Canvas Group to be affected by a {@link BaseSamplerShader}.
 * @extends {BaseCanvasMixin(CachedContainer)}
 * @category - Canvas
 */
declare class PrimaryCanvasGroup {
  /** @override */
  static override groupName: string;
  /**
   * Allow API users to override the default elevation of the background layer.
   * This is a temporary solution until more formal support for scene levels is added in a future release.
   * @type {number}
   */
  static BACKGROUND_ELEVATION: number;
  /**
   * The sorting function used to order objects inside the Primary Canvas Group.
   * Overrides the default sorting function defined for the PIXI.Container.
   * Sort TokenMesh above other objects, then DrawingShape, all else held equal.
   * @param {PrimaryCanvasObject|PIXI.DisplayObject} a     An object to display
   * @param {PrimaryCanvasObject|PIXI.DisplayObject} b     Some other object to display
   * @returns {number}
   * @private
   */
  private static _sortObjects;
  constructor(sprite: any);
  interactive: boolean;
  interactiveChildren: boolean;
  tokensRenderTexture: any;
  /** @override */
  override clearColor: number[];
  /**
   * Track the set of HTMLVideoElements which are currently playing as part of this group.
   * @type {Set<SpriteMesh>}
   */
  videoMeshes: Set<SpriteMesh>;
  /**
   * The primary background image configured for the Scene, rendered as a SpriteMesh.
   * @type {SpriteMesh}
   */
  background: SpriteMesh;
  /**
   * The primary foreground image configured for the Scene, rendered as a SpriteMesh.
   * @type {SpriteMesh}
   */
  foreground: SpriteMesh;
  /**
   * The collection of PrimaryDrawingContainer objects which are rendered in the Scene.
   * @type {Collection<string, PrimaryDrawingContainer>}
   */
  drawings: Collection<string, PrimaryDrawingContainer>;
  /**
   * The collection of SpriteMesh objects which are rendered in the Scene.
   * @type {Collection<string, TokenMesh>}
   */
  tokens: Collection<string, TokenMesh>;
  /**
   * The collection of SpriteMesh objects which are rendered in the Scene.
   * @type {Collection<string, TileMesh|TileSprite>}
   */
  tiles: Collection<string, TileMesh | TileSprite>;
  /**
   * Render all tokens in their own render texture.
   * @param {PIXI.Renderer} renderer    The renderer to use.
   * @private
   */
  private _renderTokens;
  /**
   * Return the base HTML image or video element which provides the background texture.
   * @type {HTMLImageElement|HTMLVideoElement}
   */
  get backgroundSource(): HTMLVideoElement | HTMLImageElement;
  /**
   * Return the base HTML image or video element which provides the foreground texture.
   * @type {HTMLImageElement|HTMLVideoElement}
   */
  get foregroundSource(): HTMLVideoElement | HTMLImageElement;
  /**
   * Refresh the primary mesh.
   */
  refreshPrimarySpriteMesh(): void;
  /**
   * Draw the canvas group and all its component layers.
   * @returns {Promise<void>}
   */
  draw(): Promise<void>;
  /**
   * Remove and destroy all children from the group.
   * Clear container references to rendered objects.
   * @returns {Promise<void>}
   */
  tearDown(): Promise<void>;
  /**
   * Draw the SpriteMesh for a specific Token object.
   * @param {Token} token     The Token being added
   * @returns {TokenMesh}     The added TokenMesh
   */
  addToken(token: Function): TokenMesh;
  /**
   * Remove a TokenMesh from the group.
   * @param {Token} token     The Token being removed
   */
  removeToken(token: Function): void;
  /**
   * Draw the SpriteMesh for a specific Token object.
   * @param {Tile} tile               The Tile being added
   * @returns {TileMesh|TileSprite}   The added TileMesh or TileSprite
   */
  addTile(tile: Function): TileMesh | TileSprite;
  /**
   * Remove a TokenMesh from the group.
   * @param {Tile} tile     The Tile being removed
   */
  removeTile(tile: Function): void;
  /**
   * Add a DrawingShape to the group.
   * @param {Drawing} drawing     The Drawing being added
   * @returns {DrawingShape}      The created DrawingShape instance
   */
  addDrawing(drawing: Function): DrawingShape;
  /**
   * Remove a DrawingShape from the group.
   * @param {Drawing} drawing     The Drawing being removed
   */
  removeDrawing(drawing: Function): void;
  /**
   * Map a zIndex to an elevation ratio to draw as an intensity to the occlusion mask.
   * @param {number} elevation      A current elevation (or zIndex) in distance units.
   * @returns {number}              The color intensity for this elevation on the range [0.19, 1.0]
   */
  mapElevationAlpha(elevation: number): number;
  /**
   * Override the default PIXI.Container behavior for how objects in this container are sorted.
   * @override
   */
  override sortChildren(): void;
  sortDirty: boolean | undefined;
  #private;
}
/**
 * A container group which contains the environment canvas group and the interface canvas group.
 *
 * @category - Canvas
 */
declare class RenderedCanvasGroup {
  /** @override */
  static override groupName: string;
  /** @override */
  override tearDown(options?: {}): Promise<void>;
}
/**
 * An abstract pattern for primary layers of the game canvas to implement.
 * @category - Canvas
 * @abstract
 * @interface
 */
declare class CanvasLayer {
  /**
   * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
   * @type {{name: string}}
   */
  static get layerOptions(): {
    name: string;
  };
  /**
   * Return a reference to the active instance of this canvas layer
   * @type {CanvasLayer}
   */
  static get instance(): CanvasLayer;
  /**
   * Options for this layer instance.
   * @type {{name: string}}
   */
  options: {
    name: string;
  };
  interactiveChildren: boolean;
  /**
   * The canonical name of the CanvasLayer
   * @type {string}
   */
  get name(): string;
  /**
   * The name used by hooks to construct their hook string.
   * Note: You should override this getter if hookName should not return the class constructor name.
   * @type {string}
   */
  get hookName(): string;
  /**
   * Draw the canvas layer, rendering its internal components and returning a Promise.
   * The Promise resolves to the drawn layer once its contents are successfully rendered.
   * @param {object} [options]      Options which configure how the layer is drawn
   * @returns {Promise<CanvasLayer>}
   */
  draw(options?: object | undefined): Promise<CanvasLayer>;
  /**
   * The inner _draw method which must be defined by each CanvasLayer subclass.
   * @param {object} [options]      Options which configure how the layer is drawn
   * @abstract
   * @protected
   */
  protected _draw(options?: object | undefined): Promise<void>;
  /**
   * Deconstruct data used in the current layer in preparation to re-draw the canvas
   * @param {object} [options]      Options which configure how the layer is deconstructed
   * @returns {Promise<CanvasLayer>}
   */
  tearDown(options?: object | undefined): Promise<CanvasLayer>;
  renderable: boolean | undefined;
  /**
   * The inner _tearDown method which may be customized by each CanvasLayer subclass.
   * @param {object} [options]      Options which configure how the layer is deconstructed
   * @protected
   */
  protected _tearDown(options?: object | undefined): Promise<void>;
}
/**
 * A subclass of CanvasLayer which provides support for user interaction with its contained objects.
 * @category - Canvas
 */
declare class InteractionLayer extends CanvasLayer {
  /**
   * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
   * @type {{name: string, sortActiveTop: boolean, zIndex: number}}
   */
  static get layerOptions(): {
    name: string;
    sortActiveTop: boolean;
    zIndex: number;
  };
  /**
   * Is this layer currently active
   * @type {boolean}
   */
  get active(): boolean;
  /**
   * Activate the InteractionLayer, deactivating other layers and marking this layer's children as interactive.
   * @param {object} [options]      Options which configure layer activation
   * @param {string} [options.tool]   A specific tool in the control palette to set as active
   * @returns {InteractionLayer}    The layer instance, now activated
   */
  activate({
    tool,
  }?:
    | {
        tool?: string | undefined;
      }
    | undefined): InteractionLayer;
  zIndex: number | undefined;
  interactive: boolean | undefined;
  /**
   * The inner _activate method which may be defined by each InteractionLayer subclass.
   * @protected
   */
  protected _activate(): void;
  /**
   * Deactivate the InteractionLayer, removing interactivity from its children.
   * @returns {InteractionLayer}    The layer instance, now inactive
   */
  deactivate(): InteractionLayer;
  /**
   * The inner _deactivate method which may be defined by each InteractionLayer subclass.
   * @protected
   */
  protected _deactivate(): void;
  /** @override */
  override _draw(options: any): Promise<void>;
  hitArea: any;
  /**
   * Get the zIndex that should be used for ordering this layer vertically relative to others in the same Container.
   * @returns {number}
   */
  getZIndex(): number;
  /**
   * Handle left mouse-click events which originate from the Canvas stage.
   * @see {@link Canvas._onClickLeft}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onClickLeft(event: PIXI.InteractionEvent): void;
  /**
   * Handle double left-click events which originate from the Canvas stage.
   * @see {@link Canvas._onClickLeft2}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onClickLeft2(event: PIXI.InteractionEvent): void;
  /**
   * Start a left-click drag workflow originating from the Canvas stage.
   * @see {@link Canvas._onDragLeftStart}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onDragLeftStart(event: PIXI.InteractionEvent): Promise<void>;
  /**
   * Continue a left-click drag workflow originating from the Canvas stage.
   * @see {@link Canvas._onDragLeftMove}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onDragLeftMove(event: PIXI.InteractionEvent): void;
  /**
   * Conclude a left-click drag workflow originating from the Canvas stage.
   * @see {@link Canvas._onDragLeftDrop}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onDragLeftDrop(event: PIXI.InteractionEvent): Promise<void>;
  /**
   * Cancel a left-click drag workflow originating from the Canvas stage.
   * @see {@link Canvas._onDragLeftDrop}
   * @param {PointerEvent} event              A right-click pointer event on the document.
   * @protected
   */
  protected _onDragLeftCancel(event: PointerEvent): void;
  /**
   * Handle right mouse-click events which originate from the Canvas stage.
   * @see {@link Canvas._onClickRight}
   * @param {PIXI.InteractionEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
   * @protected
   */
  protected _onClickRight(event: PIXI.InteractionEvent): void;
  /**
   * Handle mouse-wheel events which occur for this active layer.
   * @see {@link MouseManager._onWheel}
   * @param {WheelEvent} event                The WheelEvent initiated on the document
   * @protected
   */
  protected _onMouseWheel(event: WheelEvent): void;
  /**
   * Handle a DELETE keypress while this layer is active.
   * @see {@link ClientKeybindings._onDelete}
   * @param {KeyboardEvent} event             The delete key press event
   * @protected
   */
  protected _onDeleteKey(event: KeyboardEvent): Promise<void>;
  #private;
}
/**
 * @typedef {Object} CanvasHistory
 * @property {string} type    The type of operation stored as history (create, update, delete)
 * @property {Object[]} data  The data corresponding to the action which may later be un-done
 */
/**
 * A subclass of Canvas Layer which is specifically designed to contain multiple PlaceableObject instances,
 * each corresponding to an embedded Document.
 * @category - Canvas
 */
declare class PlaceablesLayer extends InteractionLayer {
  /**
   * @inheritdoc
   * @property {boolean} canDragCreate        Does this layer support a mouse-drag workflow to create new objects?
   * @property {boolean} canDelete            Can objects be deleted from this layer?
   * @property {boolean} controllableObjects  Can placeable objects in this layer be controlled?
   * @property {boolean} rotatableObjects     Can placeable objects in this layer be rotated?
   * @property {boolean} snapToGrid           Do objects in this layer snap to the grid
   * @property {PlaceableObject} objectClass  The class used to represent an object on this layer.
   * @property {boolean} quadtree             Does this layer use a quadtree to track object positions?
   * @property {boolean} elevationSorting     Are contained objects sorted based on elevation instead of zIndex
   */
  static get layerOptions(): any;
  /**
   * A reference to the named Document type which is contained within this Canvas Layer.
   * @type {string}
   */
  static documentName: string;
  /**
   * Creation states affected to placeables during their construction.
   * @enum {number}
   */
  static CREATION_STATES: {
    NONE: number;
    POTENTIAL: number;
    CONFIRMED: number;
    COMPLETED: number;
  };
  /**
   * Obtain a reference to the PlaceableObject class definition which represents the Document type in this layer.
   * @type {Function}
   */
  static get placeableClass(): Function;
  /**
   * Placeable Layer Objects
   * @type {PIXI.Container|null}
   */
  objects: PIXI.Container | null;
  /**
   * Preview Object Placement
   */
  preview: null;
  /**
   * Keep track of history so that CTRL+Z can undo changes
   * @type {CanvasHistory[]}
   */
  history: CanvasHistory[];
  /**
   * Track whether "highlight all objects" is currently active
   * @type {boolean}
   */
  _highlight: boolean;
  /**
   * Keep track of an object copied with CTRL+C which can be pasted later
   * @type {PlaceableObject[]}
   */
  _copy: PlaceableObject[];
  /**
   * A Quadtree which partitions and organizes Walls into quadrants for efficient target identification.
   * @type {Quadtree|null}
   */
  quadtree: Quadtree | null;
  /**
   * Obtain a reference to the Collection of embedded Document instances within the currently viewed Scene
   * @type {Collection|null}
   */
  get documentCollection(): any;
  /**
   * Return the precision relative to the Scene grid with which Placeable objects should be snapped
   * @type {number}
   */
  get gridPrecision(): number;
  /**
   * If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance
   * @type {BasePlaceableHUD|null}
   */
  get hud(): BasePlaceableHUD | null;
  /**
   * A convenience method for accessing the placeable object instances contained in this layer
   * @type {PlaceableObject[]}
   */
  get placeables(): PlaceableObject[];
  /**
   * An Array of placeable objects in this layer which have the _controlled attribute
   * @returns {PlaceableObject[]}
   */
  get controlled(): PlaceableObject[];
  /**
   * Track the set of PlaceableObjects on this layer which are currently controlled.
   * @type {Map<string,PlaceableObject>}
   */
  get controlledObjects(): Map<string, PlaceableObject>;
  set hover(arg: PlaceableObject | null);
  /**
   * Track the PlaceableObject on this layer which is currently hovered upon.
   * @type {PlaceableObject|null}
   */
  get hover(): PlaceableObject | null;
  /**
   * Obtain an iterable of objects which should be added to this PlaceableLayer
   * @returns {Document[]}
   */
  getDocuments(): Document[];
  visible: boolean | undefined;
  /**
   * Draw a single placeable object
   * @param {ClientDocument} document     The Document instance used to create the placeable object
   * @returns {PlaceableObject|null}
   */
  createObject(document: abstract.Document): PlaceableObject | null;
  /** @override */
  override _tearDown(options: any): Promise<void>;
  /**
   * Override the default PIXI.Container behavior for how objects in this container are sorted.
   * @internal
   */
  _sortObjectsByElevation(): void;
  sortDirty: boolean | undefined;
  /**
   * Clear the contents of the preview container, restoring visibility of original (non-preview) objects.
   */
  clearPreviewContainer(): void;
  /**
   * Get a PlaceableObject contained in this layer by its ID.
   * Returns undefined if the object doesn't exist or if the canvas is not rendering a Scene.
   * @param {string} objectId   The ID of the contained object to retrieve
   * @returns {PlaceableObject}  The object instance, or undefined
   */
  get(objectId: string): PlaceableObject;
  /**
   * Acquire control over all PlaceableObject instances which are visible and controllable within the layer.
   * @param {object} options      Options passed to the control method of each object
   * @returns {PlaceableObject[]}  An array of objects that were controlled
   */
  controlAll(options?: object): PlaceableObject[];
  /**
   * Release all controlled PlaceableObject instance from this layer.
   * @param {object} options   Options passed to the release method of each object
   * @returns {number}         The number of PlaceableObject instances which were released
   */
  releaseAll(options?: object): number;
  /**
     * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
     * This executes a single database operation using Scene.update.
     * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.
     *
     * @param {object} options    Options which configure how multiple objects are rotated
     * @param {number} [options.angle]      A target angle of rotation (in degrees) where zero faces "south"
     * @param {number} [options.delta]      An incremental angle of rotation (in degrees)
     * @param {number} [options.snap]       Snap the resulting angle to a multiple of some increment (in degrees)
     * @param {Array} [options.ids]         An Array of object IDs to target for rotation
  
     * @return {Promise<PlaceableObject[]>} An array of objects which were rotated
     */
  rotateMany({
    angle,
    delta,
    snap,
    ids,
  }?: {
    angle?: number | undefined;
    delta?: number | undefined;
    snap?: number | undefined;
    ids?: any[] | undefined;
  }): Promise<PlaceableObject[]>;
  /**
   * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
   * This executes a single database operation using Scene.update.
   * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
   *
   * @param {object} options    Options which configure how multiple objects are moved
   * @param {number} [options.dx=0]       The number of incremental grid units in the horizontal direction
   * @param {number} [options.dy=0]       The number of incremental grid units in the vertical direction
   * @param {boolean} [options.rotate=false] Rotate the token to the keyboard direction instead of moving
   * @param {Array} [options.ids]         An Array of object IDs to target for movement
   *
   * @returns {Promise<PlaceableObject[]>} An array of objects which were moved during the operation
   */
  moveMany({
    dx,
    dy,
    rotate,
    ids,
  }?: {
    dx?: number | undefined;
    dy?: number | undefined;
    rotate?: boolean | undefined;
    ids?: any[] | undefined;
  }): Promise<PlaceableObject[]>;
  /**
   * Undo a change to the objects in this layer
   * This method is typically activated using CTRL+Z while the layer is active
   * @returns {Promise<Document[]>}     An array of documents which were modified by the undo operation
   */
  undoHistory(): Promise<Document[]>;
  /**
   * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
   * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
   * @returns {Promise<Document[]>}    An array of Document objects which were deleted by the operation
   */
  deleteAll(): Promise<Document[]>;
  /**
   * Record a new CRUD event in the history log so that it can be undone later
   * @param {string} type   The event type (create, update, delete)
   * @param {Object[]} data   The object data
   */
  storeHistory(type: string, data: Object[]): void;
  /**
   * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
   * @returns {PlaceableObject[]}             The Array of copied PlaceableObject instances
   */
  copyObjects(): PlaceableObject[];
  /**
   * Paste currently copied PlaceableObjects back to the layer by creating new copies
   * @param {Point} position      The destination position for the copied data.
   * @param {object} [options]    Options which modify the paste operation
   * @param {boolean} [options.hidden]    Paste data in a hidden state, if applicable. Default is false.
   * @param {boolean} [options.snap]      Snap the resulting objects to the grid. Default is true.
   * @returns {Promise<Document[]>} An Array of created Document instances
   */
  pasteObjects(
    position: Point,
    {
      hidden,
      snap,
    }?:
      | {
          hidden?: boolean | undefined;
          snap?: boolean | undefined;
        }
      | undefined
  ): Promise<Document[]>;
  /**
   * Select all PlaceableObject instances which fall within a coordinate rectangle.
   *
   * @param {number} x      The top-left x-coordinate of the selection rectangle
   * @param {number} y      The top-left y-coordinate of the selection rectangle
   * @param {number} width  The width of the selection rectangle
   * @param {number} height The height of the selection rectangle
   * @param {object} releaseOptions   Optional arguments provided to any called release() method
   * @param {object} controlOptions   Optional arguments provided to any called control() method
   * @param {object} [options]        Additional options to configure selection behaviour.
   * @param {boolean} [options.releaseOthers=true]  Whether to release other selected objects.
   * @returns {boolean}       A boolean for whether the controlled set was changed in the operation
   */
  selectObjects(
    { x, y, width, height, releaseOptions, controlOptions }?: number,
    { releaseOthers }?: number
  ): boolean;
  /**
   * Update all objects in this layer with a provided transformation.
   * Conditionally filter to only apply to objects which match a certain condition.
   * @param {Function|object} transformation    An object of data or function to apply to all matched objects
   * @param {Function|null}  condition          A function which tests whether to target each object
   * @param {object} [options]                  Additional options passed to Document.update
   * @return {Promise<Document[]>}              An array of updated data once the operation is complete
   */
  updateAll(
    transformation: Function | object,
    condition?: Function | null,
    options?: object | undefined
  ): Promise<Document[]>;
  /**
   * Get the world-transformed drop position.
   * @param {DragEvent} event
   * @param {object} [options]
   * @param {boolean} [center=true]  Return the co-ordinates of the center of the nearest grid element.
   * @returns {number[]|boolean}     Returns the transformed x, y co-ordinates, or false if the drag event was outside
   *                                 the canvas.
   * @protected
   */
  protected _canvasCoordinatesFromDrop(
    event: DragEvent,
    { center }?: object | undefined
  ): number[] | boolean;
  /**
   * Create a preview of this layer's object type from a world document and show its sheet so it can be finalized.
   * @param {object} createData                     The data to create the object with.
   * @param {{top: number, left: number}} position  The position to render the sheet at.
   * @protected
   */
  protected _createPreview(
    createData: object,
    {
      top,
      left,
    }: {
      top: number;
      left: number;
    }
  ): Promise<any>;
  /** @override */
  override _onClickLeft(event: any): void;
  /** @override */
  override _onDragLeftStart(event: any): Promise<void>;
  /** @override */
  override _onDragLeftMove(event: any): void;
  /** @override */
  override _onDragLeftDrop(event: any): Promise<any>;
  /** @override */
  override _onDragLeftCancel(event: any): void;
  /** @override */
  override _onClickRight(event: any): void;
  /** @override */
  override _onMouseWheel(event: any): Promise<PlaceableObject[]> | undefined;
  /** @override */
  override _onDeleteKey(event: any): Promise<any>;
  #private;
}
/**
 * Creation states affected to placeables during their construction.
 */
type CREATION_STATES = number;
type CanvasHistory = {
  /**
   * The type of operation stored as history (create, update, delete)
   */
  type: string;
  /**
   * The data corresponding to the action which may later be un-done
   */
  data: Object[];
};
/**
 * A single Mouse Cursor
 * @type {PIXI.Container}
 */
declare class Cursor {
  constructor(user: any);
  target: {
    x: number;
    y: number;
  };
  /**
   * Draw the user's cursor as a small dot with their user name attached as text
   */
  draw(user: any): void;
  /**
   * Move an existing cursor to a new position smoothly along the animation loop
   */
  _animate(): void;
  /** @inheritdoc */
  destroy(options: any): void;
}
/**
 * An icon representing a Door Control
 * @extends {PIXI.Container}
 */
declare class DoorControl {
  constructor(wall: any);
  wall: any;
  visible: boolean;
  /**
   * The center of the wall which contains the door.
   * @returns {PIXI.Point|PIXI.Point|boolean|*}
   */
  get center(): any;
  /**
   * Draw the DoorControl icon, displaying its icon texture and border
   * @returns {Promise<DoorControl>}
   */
  draw(): Promise<DoorControl>;
  bg: any;
  icon: any;
  border: any;
  interactive: boolean | undefined;
  interactiveChildren: boolean | undefined;
  hitArea: PIXI.Rectangle | undefined;
  buttonMode: boolean | undefined;
  alpha: number | undefined;
  /**
   * Get the icon texture to use for the Door Control icon based on the door state
   * @returns {PIXI.Texture}
   */
  _getTexture(): PIXI.Texture;
  reposition(): void;
  /**
   * Determine whether the DoorControl is visible to the calling user's perspective.
   * The control is always visible if the user is a GM and no Tokens are controlled.
   * @see {CanvasVisibility#testVisibility}
   * @type {boolean}
   */
  get isVisible(): boolean;
  /**
   * Handle mouse over events on a door control icon.
   * @param {PIXI.InteractionEvent} event      The originating interaction event
   * @protected
   */
  protected _onMouseOver(event: PIXI.InteractionEvent): false | undefined;
  /**
   * Handle mouse out events on a door control icon.
   * @param {PIXI.InteractionEvent} event      The originating interaction event
   * @protected
   */
  protected _onMouseOut(event: PIXI.InteractionEvent): false | undefined;
  /**
   * Handle left mouse down events on a door control icon.
   * This should only toggle between the OPEN and CLOSED states.
   * @param {PIXI.InteractionEvent} event      The originating interaction event
   * @protected
   */
  protected _onMouseDown(event: PIXI.InteractionEvent): any;
  /**
   * Handle right mouse down events on a door control icon.
   * This should toggle whether the door is LOCKED or CLOSED.
   * @param {PIXI.InteractionEvent} event      The originating interaction event
   * @protected
   */
  protected _onRightDown(event: PIXI.InteractionEvent): any;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class SynchronizedTransform {
  /**
   * A list of attributes from the transform reference which should be synchronized
   * @type {string}
   */
  static synchronizedAttributes: string;
  constructor(transform: any);
  set reference(arg: PIXI.Transform);
  /**
   * A Transform instance which defines the reference point for the worldTransform
   * @type {PIXI.Transform}
   */
  get reference(): PIXI.Transform;
  _reference: any;
  _syncLocalID: any;
  /** @override */
  override updateTransform(parentTransform: any): void;
  _parentID: number | undefined;
  /** @override */
  override updateLocalTransform(): void;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class ObjectHUD {
  constructor(object: any);
  /**
   * The object that this HUD container is linked to
   * @type {PIXI.DisplayObject}
   */
  object: PIXI.DisplayObject;
  /**
   * Use the linked object's transform matrix to easily synchronize position
   * @type {PIXI.Transform}
   */
  transform: PIXI.Transform;
  cullable: boolean;
  override set visible(arg: any);
  /** @override */
  override get visible(): any;
  override set renderable(arg: any);
  /** @override */
  override get renderable(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  createScrollingText(
    content: any,
    {
      direction,
      ...options
    }?: {
      direction?: any;
    }
  ): Promise<any>;
}
/**
 * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
 *
 * We track three types of events:
 * 1) Cursor movement
 * 2) Ruler measurement
 * 3) Map pings
 */
declare class ControlsLayer extends InteractionLayer {
  /** @override */
  static override get layerOptions(): any;
  /**
   * A container of DoorControl instances
   * @type {PIXI.Container}
   */
  doors: PIXI.Container;
  /**
   * A container of HUD interface elements
   * @type {PIXI.Container}
   */
  hud: PIXI.Container;
  /**
   * A container of cursor interaction elements.
   * Contains cursors, rulers, interaction rectangles, and pings
   * @type {PIXI.Container}
   */
  cursors: PIXI.Container;
  /**
   * Ruler tools, one per connected user
   * @type {PIXI.Container}
   */
  rulers: PIXI.Container;
  /**
   * A graphics instance used for drawing debugging visualization
   * @type {PIXI.Graphics}
   */
  debug: any;
  /**
   * The Canvas selection rectangle
   * @type {PIXI.Graphics}
   */
  select: any;
  /**
   * A mapping of user IDs to Cursor instances for quick access
   * @type {Object<string, Cursor>}
   */
  _cursors: {
    [x: string]: Cursor;
  };
  /**
   * A mapping of user IDs to Ruler instances for quick access
   * @type {Object<string, Ruler>}
   * @private
   */
  private _rulers;
  /**
   * The positions of any offscreen pings we are tracking.
   * @type {Object<string, Point>}
   * @private
   */
  private _offscreenPings;
  /**
   * A convenience accessor to the Ruler for the active game user
   * @type {Ruler}
   */
  get ruler(): Ruler;
  /**
   * Get the Ruler display for a specific User ID
   * @param {string} userId
   * @returns {Ruler|null}
   */
  getRulerForUser(userId: string): Ruler | null;
  /** @override */
  override _tearDown(options: any): Promise<void>;
  /**
   * Draw the cursors container
   */
  drawCursors(): void;
  /**
   * Create and add Ruler graphics instances for every game User.
   */
  drawRulers(): void;
  /**
   * Draw door control icons to the doors container.
   */
  drawDoors(): void;
  /**
   * Draw the select rectangle given an event originated within the base canvas layer
   * @param {Object} coords   The rectangle coordinates of the form {x, y, width, height}
   */
  drawSelect({ x, y, width, height }: Object): void;
  visible: boolean | undefined;
  /**
   * Handle mousemove events on the game canvas to broadcast activity of the user's cursor position
   * @param {PIXI.InteractionEvent} event
   */
  _onMouseMove(event: PIXI.InteractionEvent): void;
  /**
   * Handle pinging the canvas.
   * @param {PIXI.InteractionEvent} event   The triggering canvas interaction event.
   * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
   * @protected
   */
  protected _onLongPress(event: PIXI.InteractionEvent, origin: PIXI.Point): any;
  /**
   * Handle the canvas panning to a new view.
   * @protected
   */
  protected _onCanvasPan(): void;
  /**
   * Create and draw the Cursor object for a given User
   * @param {User} user   The User document for whom to draw the cursor Container
   */
  drawCursor(user: User): any;
  /**
   * Update the cursor when the user moves to a new position
   * @param {User} user         The User for whom to update the cursor
   * @param {Point} position    The new cursor position
   */
  updateCursor(user: User, position: Point): void;
  /**
   * Update display of an active Ruler object for a user given provided data
   * @param {User} user             The User for whom to update the ruler
   * @param {object} rulerData      Data which describes the new ruler measurement to display
   */
  updateRuler(user: User, rulerData: object): void;
  /**
   * Handle a broadcast ping.
   * @param {User} user                 The user who pinged.
   * @param {PIXI.Point} position       The position on the canvas that was pinged.
   * @param {PingData} [data]           The broadcast ping data.
   * @returns {Promise<boolean>}   {@see Ping#animate}
   */
  handlePing(
    user: User,
    position: PIXI.Point,
    {
      scene,
      style,
      pull,
      zoom,
      ...pingOptions
    }?:
      | {
          /**
           * Pulls all connected clients' views to the pinged co-ordinates.
           */
          pull?: boolean | undefined;
          /**
           * The ping style, see CONFIG.Canvas.pings.
           */
          style: string;
          /**
           * The ID of the scene that was pinged.
           */
          scene: string;
          /**
           * The zoom level at which the ping was made.
           */
          zoom: number;
        }
      | undefined
  ): Promise<boolean>;
  /**
   * Draw a ping at the edge of the viewport, pointing to the location of an off-screen ping.
   * @param {PIXI.Point} position           The co-ordinates of the off-screen ping.
   * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
   * @param {string} [options.style=arrow]  The style of ping to draw, from CONFIG.Canvas.pings.
   * @param {User} [options.user]           The user who pinged.
   * @returns {Promise<boolean>}            {@see Ping#animate}
   */
  drawOffscreenPing(
    position: PIXI.Point,
    { style, user, ...pingOptions }?: PingOptions | undefined
  ): Promise<boolean>;
  /**
   * Draw a ping on the canvas.
   * @param {PIXI.Point} position           The position on the canvas that was pinged.
   * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
   * @param {string} [options.style=pulse]  The style of ping to draw, from CONFIG.Canvas.pings.
   * @param {User} [options.user]           The user who pinged.
   * @returns {Promise<boolean>}            {@see Ping#animate}
   */
  drawPing(
    position: PIXI.Point,
    { style, user, ...pingOptions }?: PingOptions | undefined
  ): Promise<boolean>;
  /**
   * Given an off-screen co-ordinate, determine the closest point at the edge of the viewport to that co-ordinate.
   * @param {Point} position                                     The off-screen co-ordinate.
   * @returns {{ray: Ray, intersection: LineIntersection|null}}  The closest point at the edge of the viewport to that
   *                                                             co-ordinate and a ray cast from the centre of the
   *                                                             screen towards it.
   * @private
   */
  private _findViewportIntersection;
}
/**
 * @typedef {Object} RulerMeasurementSegment
 * @property {Ray} ray              The Ray which represents the point-to-point line segment
 * @property {PreciseText} label    The text object used to display a label for this segment
 * @property {number} distance      The measured distance of the segment
 * @property {string} text          The string text displayed in the label
 * @property {boolean} last         Is this segment the last one?
 */
/**
 * The Ruler - used to measure distances and trigger movements
 * @param {User}  The User for whom to construct the Ruler instance
 * @type {PIXI.Container}
 */
declare class Ruler {
  /**
   * An enumeration of the possible Ruler measurement states.
   * @enum {number}
   */
  static STATES: {
    INACTIVE: number;
    STARTING: number;
    MEASURING: number;
    MOVING: number;
  };
  constructor(
    user: any,
    {
      color,
    }?: {
      color?: null | undefined;
    }
  );
  /**
   * Record the User which this Ruler references
   * @type {User}
   */
  user: User;
  /**
   * The ruler name - used to differentiate between players
   * @type {string}
   */
  name: string;
  /**
   * The ruler color - by default the color of the active user
   * @type {Color}
   */
  color: any;
  /**
   * This Array tracks individual waypoints along the ruler's measured path.
   * The first waypoint is always the origin of the route.
   * @type {Array<PIXI.Point>}
   */
  waypoints: Array<PIXI.Point>;
  /**
   * The Ruler element is a Graphics instance which draws the line and points of the measured path
   * @type {PIXI.Graphics}
   */
  ruler: any;
  /**
   * The Labels element is a Container of Text elements which label the measured path
   * @type {PIXI.Container}
   */
  labels: PIXI.Container;
  /**
   * Track the current measurement state
   * @type {number}
   */
  _state: number;
  /**
   * The current destination point at the end of the measurement
   * @type {PIXI.Point}
   */
  destination: PIXI.Point;
  /**
   * The array of most recently computed ruler measurement segments
   * @type {RulerMeasurementSegment[]}
   */
  segments: RulerMeasurementSegment[];
  /**
   * Is the Ruler being actively used to measure distance?
   * @type {boolean}
   */
  get active(): boolean;
  /**
   * Get a GridHighlight layer for this Ruler
   * @type {GridHighlight}
   */
  get highlightLayer(): GridHighlight;
  /**
   * Clear display of the current Ruler
   */
  clear(): void;
  /**
   * Measure the distance between two points and render the ruler UI to illustrate it
   * @param {PIXI.Point} destination  The destination point to which to measure
   * @param {boolean} gridSpaces      Restrict measurement only to grid spaces
   * @returns {RulerMeasurementSegment[]} The array of measured segments
   */
  measure(
    destination: PIXI.Point,
    { gridSpaces }?: boolean
  ): RulerMeasurementSegment[];
  /**
   * While measurement is in progress, update the destination to be the central point of the target grid space.
   * @param {Point} destination     The current pixel coordinates of the mouse movement
   * @returns {Point}               The destination point, a center of a grid space
   * @protected
   */
  protected _getMeasurementDestination(destination: Point): Point;
  /**
   * Translate the waypoints and destination point of the Ruler into an array of Ray segments.
   * @returns {RulerMeasurementSegment[]} The segments of the measured path
   * @protected
   */
  protected _getMeasurementSegments(): RulerMeasurementSegment[];
  /**
   * Compute the distance of each segment and the total distance of the measured path.
   * @param {boolean} gridSpaces    Base distance on the number of grid spaces moved?
   * @protected
   */
  protected _computeDistance(gridSpaces: boolean): void;
  /**
   * Get the text label for a segment of the measured path
   * @param {RulerMeasurementSegment} segment
   * @param {number} totalDistance
   * @returns {string}
   * @protected
   */
  protected _getSegmentLabel(
    segment: RulerMeasurementSegment,
    totalDistance: number
  ): string;
  /**
   * Draw each segment of the measured path.
   * @protected
   */
  protected _drawMeasuredPath(): void;
  /**
   * Highlight the measurement required to complete the move in the minimum number of discrete spaces
   * @param {RulerMeasurementSegment} segment
   * @protected
   */
  protected _highlightMeasurementSegment(
    segment: RulerMeasurementSegment
  ): void;
  /**
   * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
   * @returns {Promise<boolean>}  An indicator for whether a token was successfully moved or not. If True the
   *                              event should be prevented from propagating further, if False it should move on
   *                              to other handlers.
   */
  moveToken(): Promise<boolean>;
  /**
   * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler
   * @returns {Token}
   * @protected
   */
  protected _getMovementToken(): Function;
  /**
   * Animate piecewise Token movement along the measured segment path.
   * @param {Token} token           The Token being animated
   * @returns {Promise<void>}       A Promise which resolves once all animation is completed
   * @protected
   */
  protected _animateMovement(token: Function): Promise<void>;
  /**
   * Update Token position and configure its animation properties for the next leg of its animation.
   * @param {Token} token                         The Token being updated
   * @param {RulerMeasurementSegment} segment     The measured segment being moved
   * @param {Point} destination                   The adjusted destination coordinate
   * @returns {Promise<unknown>}                  A Promise which resolves once the animation for this segment is done
   * @protected
   */
  protected _animateSegment(
    token: Function,
    segment: RulerMeasurementSegment,
    destination: Point
  ): Promise<unknown>;
  /**
   * Handle the beginning of a new Ruler measurement workflow
   * @param {PIXI.InteractionEvent} event   The drag start event
   * @see {Canvas._onDragLeftStart}
   */
  _onDragStart(event: PIXI.InteractionEvent): void;
  /**
   * Handle left-click events on the Canvas during Ruler measurement.
   * @param {PIXI.InteractionEvent} event   The pointer-down event
   * @see {Canvas._onClickLeft}
   */
  _onClickLeft(event: PIXI.InteractionEvent): void;
  /**
   * Handle right-click events on the Canvas during Ruler measurement.
   * @param {PIXI.InteractionEvent} event   The pointer-down event
   * @see {Canvas._onClickRight}
   */
  _onClickRight(event: PIXI.InteractionEvent): false | void;
  /**
   * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.
   * @param {PIXI.InteractionEvent} event   The mouse move event
   * @see {Canvas._onDragLeftMove}
   */
  _onMouseMove(event: PIXI.InteractionEvent): void;
  /**
   * Conclude a Ruler measurement workflow by releasing the left-mouse button.
   * @param {PIXI.InteractionEvent} event   The pointer-up event
   * @see {Canvas._onDragLeftDrop}
   */
  _onMouseUp(event: PIXI.InteractionEvent): void;
  /**
   * Handle the addition of a new waypoint in the Ruler measurement path
   * @param {PIXI.Point} point
   * @private
   */
  private _addWaypoint;
  /**
   * Handle the removal of a waypoint in the Ruler measurement path
   * @param {PIXI.Point} point      The current cursor position to snap to
   * @param {boolean} [snap]        Snap exactly to grid spaces?
   * @private
   */
  private _removeWaypoint;
  /**
   * Handle the conclusion of a Ruler measurement workflow
   * @private
   */
  private _endMeasurement;
  /**
   * @typedef {object} RulerData
   * @property {number} _state           The ruler measurement state.
   * @property {string} name             A unique name for the ruler containing the owning user's ID.
   * @property {PIXI.Point} destination  The current point the ruler has been extended to.
   * @property {string} class            The class name of this ruler instance.
   * @property {PIXI.Point[]} waypoints  Additional waypoints along the ruler's length, including the starting point.
   */
  /**
   * Package Ruler data to an object which can be serialized to a string.
   * @returns {RulerData}
   */
  toJSON(): {
    /**
     * The ruler measurement state.
     */
    _state: number;
    /**
     * A unique name for the ruler containing the owning user's ID.
     */
    name: string;
    /**
     * The current point the ruler has been extended to.
     */
    destination: PIXI.Point;
    /**
     * The class name of this ruler instance.
     */
    class: string;
    /**
     * Additional waypoints along the ruler's length, including the starting point.
     */
    waypoints: PIXI.Point[];
  };
  /**
   * Update a Ruler instance using data provided through the cursor activity socket
   * @param {Object} data   Ruler data with which to update the display
   */
  update(data: Object): void;
}
/**
 * An enumeration of the possible Ruler measurement states.
 */
type STATES = number;
type RulerData = {
  /**
   * The ruler measurement state.
   */
  _state: number;
  /**
   * A unique name for the ruler containing the owning user's ID.
   */
  name: string;
  /**
   * The current point the ruler has been extended to.
   */
  destination: PIXI.Point;
  /**
   * The class name of this ruler instance.
   */
  class: string;
  /**
   * Additional waypoints along the ruler's length, including the starting point.
   */
  waypoints: PIXI.Point[];
};
type RulerMeasurementSegment = {
  /**
   * The Ray which represents the point-to-point line segment
   */
  ray: Ray;
  /**
   * The text object used to display a label for this segment
   */
  label: PreciseText;
  /**
   * The measured distance of the segment
   */
  distance: number;
  /**
   * The string text displayed in the label
   */
  text: string;
  /**
   * Is this segment the last one?
   */
  last: boolean;
};
/**
 * A layer of background alteration effects which change the appearance of the primary group render texture.
 * @category - Canvas
 */
declare class CanvasBackgroundAlterationEffects extends CanvasLayer {
  /**
   * A collection of effects which provide background vision alterations.
   * @type {PIXI.Container}
   */
  vision: PIXI.Container;
  /**
   * A collection of effects which provide background preferred vision alterations.
   * @type {PIXI.Container}
   */
  visionPreferred: PIXI.Container;
  /**
   * A collection of effects which provide other background alterations.
   * @type {PIXI.Container}
   */
  lighting: PIXI.Container;
  /** @override */
  override _draw(options: any): Promise<void>;
  /** @override */
  override _tearDown(options: any): Promise<void>;
  /**
   * Clear background alteration effects vision and lighting containers
   */
  clear(): void;
}
/**
 * A CanvasLayer for displaying coloration visual effects
 * @category - Canvas
 */
declare class CanvasColorationEffects extends CanvasLayer {
  sortableChildren: boolean;
  /**
   * The filter used to mask visual effects on this layer
   * @type {VisualEffectsMaskingFilter}
   */
  filter: VisualEffectsMaskingFilter;
  /**
   * Clear coloration effects container
   */
  clear(): void;
  /** @override */
  override _draw(options: any): Promise<void>;
  filterArea: any;
  filters: VisualEffectsMaskingFilter[] | undefined;
  /** @override */
  override _tearDown(options: any): Promise<void>;
}
/**
 * A CanvasLayer for displaying illumination visual effects
 * @category - Canvas
 */
declare class CanvasIlluminationEffects extends CanvasLayer {
  /**
   * A minimalist texture that holds the background color.
   * @type {PIXI.Texture}
   */
  backgroundColorTexture: PIXI.Texture;
  background: any;
  lights: any;
  /**
   * Is global illumination currently applied to the canvas?
   * @type {boolean}
   */
  globalLight: boolean;
  /**
   * The filter used to mask visual effects on this layer
   * @type {VisualEffectsMaskingFilter}
   */
  filter: VisualEffectsMaskingFilter;
  /**
   * Set or retrieve the illumination background color.
   * @param {number} color
   */
  set backgroundColor(arg: number);
  /**
   * Clear illumination effects container
   */
  clear(): void;
  /**
   * Create the background color texture used by illumination point source meshes.
   * 1x1 single pixel texture.
   * @returns {PIXI.Texture}    The background color texture.
   * @protected
   */
  protected _createBackgroundColorTexture(): PIXI.Texture;
  /** @override */
  override render(renderer: any): void;
  /** @override */
  override _draw(options: any): Promise<void>;
  darknessLevel: any;
  filterArea: any;
  filters: VisualEffectsMaskingFilter[] | undefined;
  /** @override */
  override _tearDown(options: any): Promise<void>;
  /**
   * Draw illumination baseline
   */
  drawBaseline(): void;
  /**
   * Does this scene currently benefit from global illumination?
   * @returns {boolean}     Did the value of global light change?
   */
  updateGlobalLight(): boolean;
}
/**
 * An interface for defining particle-based weather effects
 * @param {PIXI.Container} parent     The parent container within which the effect is rendered
 * @param {object} [options]          Options passed to the getParticleEmitters method which can be used to customize
 *                                    values of the emitter configuration.
 * @interface
 */
declare class ParticleEffect {
  /**
   * A human-readable label for the weather effect. This can be a localization string.
   * @type {string}
   */
  static label: string;
  constructor(parent: any, options?: {});
  /**
   * The parent particle container within which the effect is rendered
   * @type {FullCanvasContainer}
   */
  parent: FullCanvasContainer;
  /**
   * The array of emitters which are active for this particle effect
   * @type {PIXI.particles.Emitter[]}
   */
  emitters: PIXI.particles.Emitter[];
  /**
   * Create an emitter instance which automatically updates using the shared PIXI.Ticker
   * @param {PIXI.particles.EmitterConfigV3} config   The emitter configuration
   * @returns {PIXI.particles.Emitter}                The created Emitter instance
   */
  createEmitter(config: PIXI.particles.EmitterConfigV3): PIXI.particles.Emitter;
  /**
   * Get the particle emitters which should be active for this particle effect.
   * @param {object} [options]    Options provided to the ParticleEffect constructor which can be used to customize
   *                              configuration values for created emitters.
   * @returns {PIXI.particles.Emitter[]}
   */
  getParticleEmitters(options?: object | undefined): PIXI.particles.Emitter[];
  /**
   * Destroy all emitters related to this ParticleEffect
   */
  destroy(): void;
  /**
   * Begin animation for the configured emitters.
   */
  play(): void;
  /**
   * Stop animation for the configured emitters.
   */
  stop(): void;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class SpecialEffect extends ParticleEffect {
  constructor(parent: any);
}
/**
 * A full-screen weather effect which renders gently falling autumn leaves.
 * @extends {ParticleEffect}
 */
declare class AutumnLeavesWeatherEffect extends ParticleEffect {
  /**
   * Configuration for the particle emitter for falling leaves
   * @type {PIXI.particles.EmitterConfigV3}
   */
  static LEAF_CONFIG: PIXI.particles.EmitterConfigV3;
  /** @inheritdoc */
  getParticleEmitters(): PIXI.particles.Emitter[];
}
/**
 * A full-screen weather effect which renders rain drops and splashes.
 * @extends {ParticleEffect}
 */
declare class RainWeatherEffect extends ParticleEffect {
  /**
   * Configuration for the particle emitter for rain
   * @type {PIXI.particles.EmitterConfigV3}
   */
  static RAIN_CONFIG: PIXI.particles.EmitterConfigV3;
  /**
   * Configuration for the particle emitter for splashes
   * @type {PIXI.particles.EmitterConfigV3}
   */
  static SPLASH_CONFIG: PIXI.particles.EmitterConfigV3;
  /** @inheritdoc */
  getParticleEmitters({
    maxParticles,
    ...options
  }: {
    [x: string]: any;
    maxParticles: any;
  }): any[];
}
/**
 * A full-screen weather effect which renders drifting snowflakes.
 * @extends {ParticleEffect}
 */
declare class SnowWeatherEffect extends ParticleEffect {
  /**
   * Configuration for the particle emitter for snow
   * @type {PIXI.particles.EmitterConfigV3}
   */
  static SNOW_CONFIG: PIXI.particles.EmitterConfigV3;
  /** @inheritdoc */
  getParticleEmitters(): PIXI.particles.Emitter[];
}
/**
 * The visibility Layer which implements dynamic vision, lighting, and fog of war
 * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.
 * @see {@link PointSource}
 * @category - Canvas
 *
 * @property {PIXI.Graphics} unexplored       The unexplored background which spans the entire canvas
 * @property {PIXI.Container} explored        The exploration container which tracks exploration progress
 * @property {PIXI.Container} revealed        A container of regions which have previously been revealed
 * @property {PIXI.Sprite} saved              The saved fog exploration texture
 * @property {PIXI.Container} pending         Pending exploration which has not yet been committed to the texture
 * @property {CanvasVisionContainer} vision   The container of current vision exploration
 */
declare class CanvasVisibility extends CanvasLayer {
  /**
   * Give the visibility requirement of the lighting background shader.
   * @param {VisionMode} visionMode             The single Vision Mode active at the moment (if any).
   * @returns {VisionMode.LIGHTING_VISIBILITY}
   */
  static "__#42@#requireBackgroundShader"(visionMode: VisionMode): {
    DISABLED: number;
    ENABLED: number;
    REQUIRED: number;
  };
  /**
   * The current vision container which provides line-of-sight for vision sources and field-of-view of light sources.
   * @type {PIXI.Container}
   */
  vision: PIXI.Container;
  /**
   * The canonical line-of-sight polygon which defines current Token visibility.
   * @type {PIXI.Graphics}
   */
  los: any;
  /**
   * The optional fog overlay sprite that should be drawn instead of the unexplored color in the fog of war.
   * @type {PIXI.Sprite}
   */
  fogOverlay: PIXI.Sprite;
  /**
   * The active vision source data object
   * @type {{source: VisionSource|null, activeLightingOptions: object}}
   */
  visionModeData: {
    source: VisionSource | null;
    activeLightingOptions: object;
  };
  /**
   * Define whether each lighting layer is enabled, required, or disabled by this vision mode.
   * The value for each lighting channel is a number in LIGHTING_VISIBILITY
   * @type {{illumination: number, background: number, coloration: number, any: boolean}}
   */
  lightingVisibility: {
    illumination: number;
    background: number;
    coloration: number;
    any: boolean;
  };
  /**
   * A status flag for whether the layer initialization workflow has succeeded.
   * @type {boolean}
   */
  get initialized(): boolean;
  /**
   * Does the currently viewed Scene support Token field of vision?
   * @type {boolean}
   */
  get tokenVision(): boolean;
  /**
   * Initialize all Token vision sources which are present on this layer
   */
  initializeSources(): void;
  /** @override */
  override _draw(options: any): Promise<void>;
  explored: any;
  revealed: any;
  saved: any;
  pending: any;
  filter: AbstractBaseFilter | undefined;
  filters: AbstractBaseFilter[] | undefined;
  filterArea: any;
  visible: boolean | undefined;
  /** @override */
  override _tearDown(options: any): Promise<void>;
  /**
   * Update the display of the sight layer.
   * Organize sources into rendering queues and draw lighting containers for each source
   *
   * @param {object} [options]        Options which affect how visibility is refreshed
   * @param {boolean} [options.forceUpdateFog=false]  Always update the Fog exploration progress for this update
   */
  refresh({
    forceUpdateFog,
  }?:
    | {
        forceUpdateFog?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
   * These assets should only be displayed if they are visible given the current player's field of view
   */
  restrictVisibility(): void;
  /**
   * @typedef {Object} CanvasVisibilityTestConfig
   * @property {PlaceableObject} object           The target object
   * @property {CanvasVisibilityTest[]} tests     An array of visibility tests
   */
  /**
   * @typedef {Object} CanvasVisibilityTest
   * @property {PIXI.Point} point
   * @property {Map<VisionSource, boolean>} los
   */
  /**
   * Test whether a target point on the Canvas is visible based on the current vision and LOS polygons.
   * @param {Point} point                         The point in space to test, an object with coordinates x and y.
   * @param {object} [options]                    Additional options which modify visibility testing.
   * @param {number} [options.tolerance=2]        A numeric radial offset which allows for a non-exact match.
   *                                              For example, if tolerance is 2 then the test will pass if the point
   *                                              is within 2px of a vision polygon.
   * @param {PIXI.DisplayObject} [options.object] An optional reference to the object whose visibility is being tested
   * @returns {boolean}                           Whether the point is currently visible.
   */
  testVisibility(
    point: Point,
    {
      tolerance,
      object,
    }?:
      | {
          tolerance?: number | undefined;
          object?: any;
        }
      | undefined
  ): boolean;
  #private;
}
type CanvasVisibilityTestConfig = {
  /**
   * The target object
   */
  object: PlaceableObject;
  /**
   * An array of visibility tests
   */
  tests: {
    point: PIXI.Point;
    los: Map<VisionSource, boolean>;
  }[];
};
type CanvasVisibilityTest = {
  point: PIXI.Point;
  los: Map<VisionSource, boolean>;
};
/**
 * A CanvasLayer for displaying visual effects like weather, transitions, flashes, or more.
 */
declare class WeatherEffects extends CanvasLayer {
  /** @inheritdoc */
  static get layerOptions(): any;
  /**
   * The weather overlay container
   * @type {FullCanvasContainer}
   */
  weather: FullCanvasContainer;
  /**
   * The currently active weather effect
   * @type {ParticleEffect}
   */
  weatherEffect: ParticleEffect;
  /**
   * An occlusion filter that prevents weather from being displayed in certain regions
   * @type {AbstractBaseMaskFilter}
   */
  weatherOcclusionFilter: AbstractBaseMaskFilter;
  set elevation(arg: number);
  /**
   * Define an elevation property on the WeatherEffects layer.
   * This approach is used for now until the weather elevation property is formally added to the Scene data schema.
   * @type {number}
   */
  get elevation(): number;
  /** @override */
  override _draw(options: any): Promise<void>;
  /** @inheritdoc */
  _tearDown(options: any): Promise<void>;
  /**
   * Draw the weather container.
   * @returns {FullCanvasContainer|null}    The weather container, or null if no effect is present
   */
  drawWeather(): FullCanvasContainer | null;
  #private;
}
/**
 * The base grid class.
 * This double-dips to implement the "gridless" option
 */
declare class BaseGrid {
  /**
   * Returns the class responsible for the implementation of a given grid type.
   * @param {number} gridType  The grid type. {@see CONST.GRID_TYPES}
   * @returns {Function}  (typeof BaseGrid) A constructor for a grid of the given type.
   */
  static implementationFor(gridType: number): Function;
  /**
   * Calculate the total size of the canvas with padding applied, as well as the top-left co-ordinates of the inner
   * rectangle that houses the scene.
   * @param {number} gridType           The grid type to calculate padding for. {@see CONST.GRID_TYPES}
   * @param {number} width              The width of the scene.
   * @param {number} height             The height of the scene.
   * @param {number} size               The grid size.
   * @param {number} padding            The percentage of padding.
   * @param {object} [options]          Options to configure the padding calculation.
   * @param {boolean} [options.legacy]  Are we computing padding for a legacy scene?
   * @returns {{width: number, height: number, x: number, y: number}}
   */
  static calculatePadding(
    gridType: number,
    width: number,
    height: number,
    size: number,
    padding: number,
    options?:
      | {
          legacy?: boolean | undefined;
        }
      | undefined
  ): {
    width: number;
    height: number;
    x: number;
    y: number;
  };
  constructor(options: any);
  options: any;
  /**
   * Grid Unit Width
   */
  w: any;
  /**
   * Grid Unit Height
   */
  h: any;
  /**
   * Draw the grid. Subclasses are expected to override this method to perform their type-specific drawing logic.
   * @param {object} [options]                  Override settings used in place of those saved to the scene data.
   * @param {string|null} [options.color=null]  The grid color.
   * @param {number|null} [options.alpha=null]  The grid transparency.
   * @returns {BaseGrid}
   */
  draw(
    options?:
      | {
          color?: string | null | undefined;
          alpha?: number | null | undefined;
        }
      | undefined
  ): BaseGrid;
  /**
   * Highlight a grid position for a certain coordinate
   * @param {GridHighlight} layer                The highlight layer to use
   * @param {object} [options]                   Additional options to configure behaviour.
   * @param {number} [options.x]                 The x-coordinate of the highlighted position
   * @param {number} [options.y]                 The y-coordinate of the highlighted position
   * @param {number} [options.color=0x33BBFF]    The hex fill color of the highlight
   * @param {number|null} [options.border=null]  The hex border color of the highlight
   * @param {number} [options.alpha=0.25]        The opacity of the highlight
   * @param {PIXI.Polygon} [options.shape=null]  A predefined shape to highlight
   */
  highlightGridPosition(
    layer: GridHighlight,
    {
      x,
      y,
      color,
      border,
      alpha,
      shape,
    }?:
      | {
          x?: number | undefined;
          y?: number | undefined;
          color?: number | undefined;
          border?: number | null | undefined;
          alpha?: number | undefined;
          shape?: PIXI.Polygon | undefined;
        }
      | undefined
  ): void;
  /**
   * Tests whether the given co-ordinates at the center of a grid space are contained within a given shape.
   * @param {number} x            The X co-ordinate.
   * @param {number} y            The Y co-ordinate.
   * @param {PIXI.Polygon} shape  The shape.
   * @returns {boolean}
   * @private
   */
  private _testShape;
  /**
   * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
   * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
   */
  getTopLeft(x: any, y: any): number[];
  /**
   * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
   * @param {number} x          The x-coordinate
   * @param {number} y          The y-coordinate
   * @return {number[]}         An array [cx, cy] of the central point of the grid space which contains (x, y)
   */
  getCenter(x: number, y: number): number[];
  /**
   * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
   * Under a "gridless" system, every pixel position is a valid snapping position
   *
   * @param {number} x                The exact target location x
   * @param {number} y                The exact target location y
   * @param {number|null} [interval]  An interval of grid spaces at which to snap.
   *                                  At interval=1, snapping occurs at pixel intervals defined by the grid size
   *                                  At interval=2, snapping would occur at the center-points of each grid size
   *                                  At interval=null, no snapping occurs
   * @param {object} [options]        Additional options to configure snapping behaviour.
   * @param {Token} [options.token]   The token that is being moved.
   * @returns {{x, y}}                An object containing the coordinates of the snapped location
   */
  getSnappedPosition(
    x: number,
    y: number,
    interval?: number | null | undefined,
    options?:
      | {
          token?: Function | undefined;
        }
      | undefined
  ): {
    x;
    y;
  };
  /**
   * Given a pair of pixel coordinates, return the grid position as an Array.
   * Always round down to the nearest grid position so the pixels are within the grid space (from top-left).
   * @param {number} x    The x-coordinate pixel position
   * @param {number} y    The y-coordinate pixel position
   * @return {number[]}   An array representing the position in grid units
   */
  getGridPositionFromPixels(x: number, y: number): number[];
  /**
   * Given a pair of grid coordinates, return the pixel position as an Array.
   * Always round up to a whole pixel so the pixel is within the grid space (from top-left).
   * @param {number} x    The x-coordinate grid position
   * @param {number} y    The y-coordinate grid position
   * @return {number[]}   An array representing the position in pixels
   */
  getPixelsFromGridPosition(x: number, y: number): number[];
  /**
   * Shift a pixel position [x,y] by some number of grid units dx and dy
   * @param {number} x               The starting x-coordinate in pixels
   * @param {number} y               The starting y-coordinate in pixels
   * @param {number} dx              The number of grid positions to shift horizontally
   * @param {number} dy              The number of grid positions to shift vertically
   * @param {object} [options]       Additional options to configure shift behaviour.
   * @param {Token} [options.token]  The token that is being shifted.
   */
  shiftPosition(
    x: number,
    y: number,
    dx: number,
    dy: number,
    options?:
      | {
          token?: Function | undefined;
        }
      | undefined
  ): number[];
  /**
   * Measure the distance traversed over an array of measured segments
   * @param {object[]} segments                An Array of measured movement segments
   * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
   * @returns {number[]}                       An Array of distance measurements for each segment
   */
  measureDistances(
    segments: object[],
    options?: {
      /**
       * Return the distance in grid increments rather than the co-ordinate distance.
       */
      gridSpaces?: boolean | undefined;
    }
  ): number[];
  /**
   * Get the grid row and column positions which are neighbors of a certain position
   * @param {number} row  The grid row coordinate against which to test for neighbors
   * @param {number} col  The grid column coordinate against which to test for neighbors
   * @returns {Array<[number, number]>} An array of grid positions which are neighbors of the row and column
   */
  getNeighbors(row: number, col: number): Array<[number, number]>;
  /**
   * Determine a placeable's bounding box based on the size of the grid.
   * @param {number} w  The width in grid spaces.
   * @param {number} h  The height in grid spaces.
   * @returns {PIXI.Rectangle}
   */
  getRect(w: number, h: number): PIXI.Rectangle;
  /**
   * Calculate the resulting token position after moving along a ruler segment.
   * @param {Ray} ray       The ray being moved along.
   * @param {Point} offset  The offset of the ruler's origin relative to the token's position.
   * @param {Token} token   The token placeable being moved.
   * @internal
   */
  _getRulerDestination(
    ray: Ray,
    offset: Point,
    token: Function
  ): {
    x: number;
    y: number;
  };
}
/**
 * @typedef {Object} GridHexCubeCoordinate
 * @property {number} q     Coordinate along the SW - NE axis
 * @property {number} r     Coordinate along the S - N axis
 * @property {number} s     Coordinate along the NW - SE axis
 */
/**
 * @typedef {Object} GridHexOffsetCoordinate
 * @property {number} row   The row coordinate
 * @property {number} col   The column coordinate
 */
/**
 * A helper class which represents a single hexagon as part of a HexagonalGrid.
 * This class relies on having an active canvas scene in order to know the configuration of the hexagonal grid.
 */
declare class GridHex {
  /**
   * Construct a GridHex instance by providing a hex coordinate.
   * @param {GridHexOffsetCoordinate|GridHexCubeCoordinate} coordinate The coordinates of the hex to construct
   */
  constructor(coordinate: GridHexOffsetCoordinate | GridHexCubeCoordinate);
  /**
   * The cube coordinates representation of this Hexagon
   * @type {GridHexCubeCoordinate}
   */
  cube: GridHexCubeCoordinate;
  /**
   * The offset coordinates representation of this Hexagon
   * @type {GridHexOffsetCoordinate}
   */
  offset: GridHexOffsetCoordinate;
  /**
   * Return a reference to the pixel point in the center of this hexagon.
   * @type {Point}
   */
  get center(): Point;
  /**
   * Return a reference to the pixel point of the top-left corner of this hexagon.
   * @type {Point}
   */
  get topLeft(): Point;
  /**
   * Return the array of hexagons which are neighbors of this one.
   * This result is un-bounded by the confines of the game canvas and may include hexes which are off-canvas.
   * @returns {GridHex[]}
   */
  getNeighbors(): GridHex[];
  /**
   * Get a neighboring hex by shifting along cube coordinates
   * @param {number} dq     A number of hexes to shift along the q axis
   * @param {number} dr     A number of hexes to shift along the r axis
   * @param {number} ds     A number of hexes to shift along the s axis
   * @returns {GridHex}     The shifted hex
   */
  shiftCube(dq: number, dr: number, ds: number): GridHex;
  /**
   * Return whether this GridHex equals the same position as some other GridHex instance.
   * @param {GridHex} other     Some other GridHex
   * @returns {boolean}         Are the positions equal?
   */
  equals(other: GridHex): boolean;
}
/**
 * Construct a hexagonal grid
 * @extends {BaseGrid}
 */
declare class HexagonalGrid extends BaseGrid {
  /**
   * Legacy hex sizing set the 'size' of a hexagon (the distance from a hexagon's centre to a vertex) to be equal to
   * half the grid size. This created some measuring inaccuracies that added up over larger distances.
   * @param {number} s                  The grid size.
   * @param {boolean} columnar          Are the hexagons stacked in columns, or rows?
   * @returns {{w: number, h: number}}  The width and height of a single hexagon, in pixels.
   * @private
   */
  private static _computeLegacySizing;
  /**
   * We set the 'size' of a hexagon (the distance from a hexagon's centre to a vertex) to be equal to the grid size
   * divided by √3. This makes the distance from top-to-bottom on a flat-topped hexagon, or left-to-right on a pointy-
   * topped hexagon equal to the grid size.
   * @param {number} s                  The grid size.
   * @param {boolean} columnar          Are the hexagons stacked in columns, or rows?
   * @returns {{w: number, h: number}}  The width and height of a single hexagon, in pixels.
   * @private
   */
  private static _computeHexSizing;
  /**
   * Special border polygons for different token sizes.
   * @type {Object<PointArray[]>}
   */
  static POINTY_HEX_BORDERS: any;
  /**
   * Special border polygons for different token sizes.
   * @type {Object<PointArray[]>}
   */
  static FLAT_HEX_BORDERS: any;
  /**
   * A matrix of x and y offsets which is multiplied by the width/height vector to get pointy-top polygon coordinates
   * @type {Array<number[]>}
   */
  static get pointyHexPoints(): number[][];
  /**
   * A matrix of x and y offsets which is multiplied by the width/height vector to get flat-top polygon coordinates
   * @type {Array<number[]>}
   */
  static get flatHexPoints(): number[][];
  /** @inheritdoc */
  static calculatePadding(
    gridType: any,
    width: any,
    height: any,
    size: any,
    padding: any,
    {
      legacy,
    }?: {
      legacy: any;
    }
  ): {
    width: any;
    height: any;
    x: number;
    y: number;
  };
  /**
   * Given a cursor position (x, y), obtain the cube coordinate hex (q, r, s) of the hex which contains it
   * http://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html
   * @param {Point} point                 The pixel point
   * @returns {GridHexCubeCoordinate}     The cube coordinate
   */
  static pixelToCube({ x, y }?: Point): GridHexCubeCoordinate;
  /**
   * Measure the distance in hexagons between two cube coordinates.
   * @param {GridHexCubeCoordinate} a     The first cube coordinate
   * @param {GridHexCubeCoordinate} b     The second cube coordinate
   * @returns {number}                    The distance between the two cube coordinates in hexagons
   */
  static cubeDistance(
    a: GridHexCubeCoordinate,
    b: GridHexCubeCoordinate
  ): number;
  /**
   * Is this hex grid column-based (flat-topped), or row-based (pointy-topped)?
   * @type {boolean}
   */
  columnar: boolean;
  /**
   * Is this hex grid even or odd?
   * @type {boolean}
   */
  even: boolean;
  /**
   * The legacy flag allows scenes created using the old hex measurements to be preserved. Newer hex scenes should
   * never use this flag.
   * @type {boolean}
   * @private
   */
  private _legacy;
  /**
   * Compute hexagonal grid width and height.
   * @param {number} size                     Size of the hex.
   * @param {object} [options]
   * @param {boolean} [options.legacy]        If computation should be done using the legacy method.
   * @protected
   */
  protected _computeHexGridDimensions(
    size: number,
    {
      legacy,
    }?:
      | {
          legacy?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * An array of the points which define a hexagon for this grid shape
   * @returns {PointArray[]}
   */
  get hexPoints(): PointArray[];
  /** @inheritdoc */
  draw(options?: {}): HexagonalGrid;
  width: any;
  height: any;
  /**
   * A convenience method for getting all the polygon points relative to a top-left [x,y] coordinate pair
   * @param {number} x               The top-left x-coordinate
   * @param {number} y               The top-right y-coordinate
   * @param {number} [w]             An optional polygon width
   * @param {number} [h]             An optional polygon height
   * @param {PointArray[]} [points]  An optional list of polygon points.
   */
  getPolygon(
    x: number,
    y: number,
    w?: number | undefined,
    h?: number | undefined,
    points?: PointArray[] | undefined
  ): number[];
  /**
   * Get a border polygon based on the width and height of a given token.
   * @param {number} w  The width of the token in hexes.
   * @param {number} h  The height of the token in hexes.
   * @param {number} p  The padding size in pixels.
   * @returns {number[]|null}
   */
  getBorderPolygon(w: number, h: number, p: number): number[] | null;
  /**
   * Draw the grid lines.
   * @param {object} [preview]                  Override settings used in place of those saved to the scene data.
   * @param {string|null} [preview.color=null]  The grid color.
   * @param {number|null} [preview.alpha=null]  The grid transparency.
   * @returns {Graphics}
   * @private
   */
  private _drawGrid;
  /**
   * Compute and draw row style hexagons.
   * @param {PIXI.Graphics} grid    Reference to the grid graphics.
   * @param {number} nrows          Number of rows.
   * @param {number} ncols          Number of columns.
   * @protected
   */
  protected _drawRows(grid: any, nrows: number, ncols: number): void;
  /**
   * Compute and draw column style hexagons.
   * @param {PIXI.Graphics} grid    Reference to the grid graphics.
   * @param {number} nrows          Number of rows.
   * @param {number} ncols          Number of columns.
   * @protected
   */
  protected _drawColumns(grid: any, nrows: number, ncols: number): void;
  /**
   * Draw a hexagon from polygon points.
   * @param {PIXI.Graphics} grid    Reference to the grid graphics.
   * @param {number[]} poly         Array of points to draw the hexagon.
   * @protected
   */
  protected _drawHexagon(grid: any, poly: number[]): void;
  /** @override */
  override getGridPositionFromPixels(x: any, y: any): number[];
  /**
   * Get the position in grid space from a pixel coordinate.
   * @param {number} x        The origin x-coordinate
   * @param {number} y        The origin y-coordinate
   * @param {string} method   The rounding method applied
   * @returns {number[]}      The row, column combination
   * @private
   */
  private _getGridPositionFromPixels;
  /** @override */
  override getPixelsFromGridPosition(row: any, col: any): number[];
  /** @override */
  override getCenter(x: any, y: any): number[];
  /** @override */
  override getSnappedPosition(
    x: any,
    y: any,
    interval?: number,
    {
      token,
    }?: {
      token: any;
    }
  ): {
    x: any;
    y: any;
  };
  _getClosestVertex(
    xc: any,
    yc: any,
    ox: any,
    oy: any
  ): {
    x: number;
    y: number;
  };
  /** @override */
  override shiftPosition(
    x: any,
    y: any,
    dx: any,
    dy: any,
    {
      token,
    }?: {
      token: any;
    }
  ): number[];
  /** @inheritdoc */
  _getRulerDestination(
    ray: any,
    offset: any,
    token: any
  ): {
    x: number;
    y: number;
  };
  /**
   * Implement special rules for snapping tokens of various sizes on a hex grid.
   * @param {number} x     The X co-ordinate of the hexagon's top-left bounding box.
   * @param {number} y     The Y co-ordinate of the hexagon's top-left bounding box.
   * @param {Token} token  The token.
   * @returns {[number, number]}
   * @protected
   */
  protected _adjustSnapForTokenSize(
    x: number,
    y: number,
    token: Function
  ): [number, number];
  /**
   * Implement special rules for determining the grid position of tokens of various sizes on a hex grid.
   * @param {number} row          The row number.
   * @param {number} col          The column number.
   * @param {Token} token         The token.
   * @returns {[number, number]}  The adjusted row and column number.
   * @protected
   */
  protected _adjustPositionForTokenSize(
    row: number,
    col: number,
    token: Function
  ): [number, number];
  /** @inheritdoc */
  getRect(w: any, h: any): PIXI.Rectangle;
  /** @override */
  override highlightGridPosition(layer: any, options?: {}): void;
  /** @override */
  override getNeighbors(row: any, col: any): number[][];
  /** @override */
  override measureDistances(segments: any, options?: {}): any;
  /**
   * Measure the distance in grid units between two pixel-based coordinates.
   * @param {Point} p0      The initial point
   * @param {Point} p1      The terminal point
   * @returns {number}      The measured distance in grid units
   */
  measureDistance(p0: Point, p1: Point): number;
  /**
   * Compute the shortest path between two hexagons using the A-star algorithm.
   * See https://www.redblobgames.com/pathfinding/a-star/introduction.html for reference
   * @param {GridHex} start     The starting hexagon
   * @param {GridHex} goal      The objective hexagon
   * @returns {{cost: number, path: GridHex[]}} The optimal path of hexagons to traverse
   */
  getAStarPath(
    start: GridHex,
    goal: GridHex
  ): {
    cost: number;
    path: GridHex[];
  };
  /**
   * Convert an offset coordinate (row, col) into a cube coordinate (q, r, s).
   * See https://www.redblobgames.com/grids/hexagons/ for reference
   * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
   * @param {GridHexOffsetCoordinate} offset    The offset coordinate
   * @returns {GridHexCubeCoordinate}           The cube coordinate
   */
  offsetToCube({ row, col }?: GridHexOffsetCoordinate): GridHexCubeCoordinate;
  /**
   * Convert a cube coordinate (q, r, s) into an offset coordinate (row, col).
   * See https://www.redblobgames.com/grids/hexagons/ for reference
   * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
   * @param {GridHexCubeCoordinate} cube    The cube coordinate
   * @returns {GridHexOffsetCoordinate}     The offset coordinate
   */
  cubeToOffset({ q, r, s }?: GridHexCubeCoordinate): GridHexOffsetCoordinate;
}
type GridHexCubeCoordinate = {
  /**
   * Coordinate along the SW - NE axis
   */
  q: number;
  /**
   * Coordinate along the S - N axis
   */
  r: number;
  /**
   * Coordinate along the NW - SE axis
   */
  s: number;
};
type GridHexOffsetCoordinate = {
  /**
   * The row coordinate
   */
  row: number;
  /**
   * The column coordinate
   */
  col: number;
};
/**
 * A special Graphics class which handles Grid layer highlighting
 * @extends {PIXI.Graphics}
 */
declare class GridHighlight {
  constructor(name: any, ...args: any[]);
  /**
   * Track the Grid Highlight name
   * @type {string}
   */
  name: string;
  /**
   * Track distinct positions which have already been highlighted
   * @type {Set}
   */
  positions: Set<any>;
  /**
   * Record a position that is highlighted and return whether or not it should be rendered
   * @param {number} x    The x-coordinate to highlight
   * @param {number} y    The y-coordinate to highlight
   * @return {boolean}    Whether or not to draw the highlight for this location
   */
  highlight(x: number, y: number): boolean;
  /** @inheritdoc */
  clear(): any;
  /** @inheritdoc */
  destroy(...args: any[]): any;
}
/**
 * A CanvasLayer responsible for drawing a square grid
 */
declare class GridLayer extends CanvasLayer {
  /** @inheritdoc */
  static get layerOptions(): any;
  /**
   * The Grid container
   * @type {BaseGrid}
   */
  grid: BaseGrid;
  /**
   * The Grid Highlight container
   * @type {PIXI.Container}
   */
  highlight: PIXI.Container;
  /**
   * Map named highlight layers
   * @type {Object<GridHighlight>}
   */
  highlightLayers: any;
  /**
   * Placeable Object borders which are drawn overtop of the Grid
   * @type {PIXI.Container}
   */
  borders: PIXI.Container;
  /**
   * The grid type rendered in this Scene
   * @type {number}
   */
  get type(): number;
  /**
   * A convenient reference to the pixel grid size used throughout this layer
   * @type {number}
   */
  get size(): number;
  /**
   * Get grid unit width
   */
  get w(): any;
  /**
   * Get grid unit height
   */
  get h(): any;
  /**
   * A boolean flag for whether the current grid is hexagonal
   * @type {boolean}
   */
  get isHex(): boolean;
  /**
   * Draw the grid
   * @param {Object} preview    Override settings used in place of those saved to the Scene data
   * @param {number|null} [preview.type]
   * @param {object|null} [preview.dimensions]
   * @param {number} preview.color
   * @param {number} preview.alpha
   * @param {number} preview.gridColor
   * @param {number} preview.gridAlpha
   */
  _draw({
    type,
    dimensions,
    color,
    alpha,
    gridColor,
    gridAlpha,
  }?: {
    type?: number | null | undefined;
    dimensions?: object | null | undefined;
    color: number;
    alpha: number;
    gridColor: number;
    gridAlpha: number;
  }): Promise<void>;
  /**
   * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
   * @param {number} x          The exact target location x
   * @param {number} y          The exact target location y
   * @param {number} [interval=1]  An interval of grid spaces at which to snap, default is 1.
   *                               If the interval is zero, no snapping occurs.
   * @param {object} [options]  Additional options to configure snapping behaviour.
   * @param {Token} [options.token]  The token.
   */
  getSnappedPosition(
    x: number,
    y: number,
    interval?: number | undefined,
    options?:
      | {
          token?: Function | undefined;
        }
      | undefined
  ): {
    x: any;
    y: any;
  };
  /**
   * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
   * @param {number} x      Coordinate X.
   * @param {number} y      Coordinate Y.
   * @returns {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
   */
  getTopLeft(x: number, y: number): number[];
  /**
   * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
   * @param {number} x      Coordinate X.
   * @param {number} y      Coordinate Y.
   * @returns {number[]}    An Array [x, y] of the central point of the square which contains (x, y)
   */
  getCenter(x: number, y: number): number[];
  /**
   * @typedef {object} MeasureDistancesOptions
   * @property {boolean} [gridSpaces]  Return the distance in grid increments rather than the co-ordinate distance.
   */
  /**
   * Measure the distance between two point coordinates.
   * @param {{x: number, y: number}} origin    The origin point
   * @param {{x: number, y: number}} target    The target point
   * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
   * @returns {number}                         The measured distance between these points
   *
   * @example Measure grid distance between two points
   * ```js
   * let distance = canvas.grid.measureDistance({x: 1000, y: 1000}, {x: 2000, y: 2000});
   * ```
   */
  measureDistance(
    origin: {
      x: number;
      y: number;
    },
    target: {
      x: number;
      y: number;
    },
    options?: {
      /**
       * Return the distance in grid increments rather than the co-ordinate distance.
       */
      gridSpaces?: boolean | undefined;
    }
  ): number;
  /**
   * Measure the distance traveled over an array of distance segments.
   * @param {object[]} segments                An array of measured segments
   * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
   */
  measureDistances(
    segments: object[],
    options?: {
      /**
       * Return the distance in grid increments rather than the co-ordinate distance.
       */
      gridSpaces?: boolean | undefined;
    }
  ): number[];
  /**
   * Define a new Highlight graphic
   * @param {string} name     The name for the referenced highlight layer
   */
  addHighlightLayer(name: string): any;
  /**
   * Clear a specific Highlight graphic
   * @param {string} name     The name for the referenced highlight layer
   */
  clearHighlightLayer(name: string): void;
  /**
   * Destroy a specific Highlight graphic
   * @param {string} name     The name for the referenced highlight layer
   */
  destroyHighlightLayer(name: string): void;
  /**
   * Obtain the highlight layer graphic by name
   * @param {string} name     The name for the referenced highlight layer
   */
  getHighlightLayer(name: string): any;
  /**
   * Add highlighting for a specific grid position to a named highlight graphic
   * @param {string} name       The name for the referenced highlight layer
   * @param {object} options    Options for the grid position that should be highlighted
   */
  highlightPosition(name: string, options: object): false | undefined;
  /**
   * Test if a specific row and column position is a neighboring location to another row and column coordinate
   * @param {number} r0     The original row position
   * @param {number} c0     The original column position
   * @param {number} r1     The candidate row position
   * @param {number} c1     The candidate column position
   */
  isNeighbor(r0: number, c0: number, r1: number, c1: number): boolean;
}
type MeasureDistancesOptions = {
  /**
   * Return the distance in grid increments rather than the co-ordinate distance.
   */
  gridSpaces?: boolean | undefined;
};
/**
 * Construct a square grid container
 * @type {BaseGrid}
 */
declare class SquareGrid extends BaseGrid {
  /** @inheritdoc */
  draw(options?: {}): SquareGrid;
  width: any;
  height: any;
  _drawLine(points: any, lineColor: any, lineAlpha: any): any;
  /** @override */
  override getCenter(x: any, y: any): number[];
  /** @override */
  override getGridPositionFromPixels(x: any, y: any): number[];
  /** @override */
  override getPixelsFromGridPosition(row: any, col: any): number[];
  /** @override */
  override getSnappedPosition(
    x: any,
    y: any,
    interval?: number,
    options?: {}
  ): {
    x: number;
    y: number;
  };
  /** @inheritdoc */
  shiftPosition(x: any, y: any, dx: any, dy: any, options?: {}): any;
  _getNearestVertex(x: any, y: any): number[];
  /** @override */
  override highlightGridPosition(layer: any, options?: {}): void;
  /** @override */
  override measureDistances(segments: any, options?: {}): any;
  /** @override */
  override getNeighbors(row: any, col: any): any[][];
}
/**
 * The depth mask which contains a mapping of elevation. Needed to know if we must render objects according to depth.
 * @category - Canvas
 */
declare class CanvasDepthMask extends CachedContainer {
  constructor(...args: any[]);
  /**
   * Container in which roofs are rendered with depth data.
   * @type {PIXI.Container}
   */
  roofs: PIXI.Container;
  /**
   * Clear the depth mask.
   */
  clear(): void;
  #private;
}
/**
 * The occlusion mask which contains radial occlusion and vision occlusion from tokens.
 * @category - Canvas
 */
declare class CanvasOcclusionMask extends CachedContainer {
  constructor(...args: any[]);
  /**
   * Graphics in which token radial and vision occlusion shapes are drawn.
   * @type {PIXI.LegacyGraphics}
   */
  tokens: any;
  /**
   * Clear the occlusion mask.
   */
  clear(): void;
  /**
   * Update the state of occlusion, rendering a new occlusion mask and updating the occluded flag on all Tiles.
   */
  updateOcclusion(): void;
  /**
   * Determine the set of Tiles which should be currently occluded by a Token.
   * @param {Token[]} tokens      The set of currently controlled Token objects
   * @returns {Set<Tile>}         The Tile objects which should be currently occluded
   * @protected
   */
  protected _identifyOccludedTiles(tokens: Function[]): Set<Function>;
  #private;
}
/**
 * @typedef {PIXI.Container} CanvasVisionContainer
 * @property {PIXI.Graphics} los      LOS polygons
 * @property {PIXI.Graphics} base     Base vision
 * @property {PIXI.Graphics} fov      FOV polygons
 * @property {PIXI.Graphics} mask     Alias of los
 * @property {boolean} _explored      Does this vision point represent an explored position?
 */
/**
 * The vision mask which contains the current line-of-sight texture.
 * @category - Canvas
 */
declare class CanvasVisionMask extends CachedContainer {
  /**
   * The current vision Container.
   * @type {CanvasVisionContainer}
   */
  vision: PIXI.Container;
  /**
   * The BlurFilter which applies to the vision mask texture.
   * This filter applies a NORMAL blend mode to the container.
   * @type {AlphaBlurFilter}
   */
  filter: AlphaBlurFilter;
  /**
   * Current LOS polygons
   * @type {PIXI.Graphics}
   */
  get los(): any;
  /**
   * Current FOV polygons
   * @type {PIXI.Graphics}
   */
  get fov(): any;
  filterArea: any;
  filters: AlphaBlurFilter[] | undefined;
  /**
   * Initialize the vision mask with the los and the fov graphics objects.
   * @returns {CanvasVisionContainer}
   */
  createVision(): PIXI.Container;
  /**
   * Detach the current vision container and return it
   * @returns {CanvasVisionContainer}
   */
  detachVision(): PIXI.Container;
  draw(): Promise<void>;
  /**
   * Clear the vision mask
   */
  clear(): void;
  #private;
}
type CanvasVisionContainer = PIXI.Container;
/**
 * The DrawingsLayer subclass of PlaceablesLayer.
 * This layer implements a container for drawings.
 * @category - Canvas
 */
declare class DrawingsLayer extends PlaceablesLayer {
  /**
   * The named game setting which persists default drawing configuration for the User
   * @type {string}
   */
  static DEFAULT_CONFIG_SETTING: string;
  /** @inheritdoc */
  get hud(): any;
  /**
   * Render a configuration sheet to configure the default Drawing settings
   */
  configureDefault(): void;
  /**
   * Get initial data for a new drawing.
   * Start with some global defaults, apply user default config, then apply mandatory overrides per tool.
   * @param {Point} origin      The initial coordinate
   * @returns {object}          The new drawing data
   */
  _getNewDrawingData(origin: Point): object;
  /** @inheritdoc */
  _onClickLeft(event: any): any;
  /** @inheritdoc */
  _onClickLeft2(event: any): Promise<any> | undefined;
  /** @inheritdoc */
  _onDragLeftStart(event: any): Promise<any>;
  /**
   * Handling of mouse-up events which conclude a new object creation after dragging
   * @param {PIXI.InteractionEvent} event       The drag drop event
   * @private
   */
  private _onDragLeftDrop;
  /** @inheritdoc */
  _onDragLeftCancel(event: any): any;
  /** @inheritdoc */
  _onClickRight(event: any): false | undefined;
}
/**
 * The Lighting Layer which ambient light sources as part of the CanvasEffectsGroup.
 * @category - Canvas
 */
declare class LightingLayer extends PlaceablesLayer {
  /** @override */
  override _onDragLeftStart(event: any): Promise<any>;
  /** @override */
  override _onMouseWheel(event: any): Promise<PlaceableObject> | undefined;
  /**
   * Actions to take when the darkness level of the Scene is changed
   * @param {number} darkness   The new darkness level
   * @param {number} prior      The prior darkness level
   * @internal
   */
  _onDarknessChange(darkness: number, prior: number): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  get background(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get illumination(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get channels(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get coloration(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get darknessLevel(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get globalLight(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get sources(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get version(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  activateAnimation(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  deactivateAnimation(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  animateDarkness(...args: any[]): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  initializeSources(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  refresh(options: any): any;
}
/**
 * The Notes Layer which contains Note canvas objects.
 * @category - Canvas
 */
declare class NotesLayer extends PlaceablesLayer {
  /**
   * The named core setting which tracks the toggled visibility state of map notes
   * @type {string}
   */
  static TOGGLE_SETTING: string;
  /**
   * Register game settings used by the NotesLayer
   */
  static registerSettings(): void;
  /**
   * Visually indicate in the Scene Controls that there are visible map notes present in the Scene.
   */
  hintMapNotes(): void;
  /**
   * Pan to a given note on the layer.
   * @param {Note} note                      The note to pan to.
   * @param {object} [options]               Options which modify the pan operation.
   * @param {number} [options.scale=1.5]     The resulting zoom level.
   * @param {number} [options.duration=250]  The speed of the pan animation in milliseconds.
   * @returns {Promise<void>}                A Promise which resolves once the pan animation has concluded.
   */
  panToNote(
    note: Function,
    {
      scale,
      duration,
    }?:
      | {
          scale?: number | undefined;
          duration?: number | undefined;
        }
      | undefined
  ): Promise<void>;
  /** @inheritdoc */
  _onClickLeft(event: any): Promise<any>;
  /**
   * Handle JournalEntry document drop data
   * @param {DragEvent} event   The drag drop event
   * @param {object} data       The dropped data transfer data
   * @protected
   */
  protected _onDropData(event: DragEvent, data: object): Promise<any>;
}
/**
 * This Canvas Layer provides a container for AmbientSound objects.
 * @category - Canvas
 */
declare class SoundsLayer extends PlaceablesLayer {
  /**
   * Track whether to actively preview ambient sounds with mouse cursor movements
   * @type {boolean}
   */
  livePreview: boolean;
  /**
   * A mapping of ambient audio sources which are active within the rendered Scene
   * @type {Collection<string,SoundSource>}
   */
  sources: Collection<string, SoundSource>;
  /**
   * Initialize all AmbientSound sources which are present on this layer
   */
  initializeSources(): void;
  /**
   * Update all AmbientSound effects in the layer by toggling their playback status.
   * Sync audio for the positions of tokens which are capable of hearing.
   * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
   */
  refresh(options?: object | undefined): number | undefined;
  /**
   * Preview ambient audio for a given mouse cursor position
   * @param {Point} position      The cursor position to preview
   */
  previewSound(position: Point): void;
  /**
   * Terminate playback of all ambient audio sources
   */
  stopAll(): void;
  /**
   * Sync the playing state and volume of all AmbientSound objects based on the position of listener points
   * @param {Point[]} listeners     Locations of listeners which have the capability to hear
   * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
   * @private
   */
  private _syncPositions;
  /**
   * Define the easing function used to map radial distance to volume.
   * Uses cosine easing which graduates from volume 1 at distance 0 to volume 0 at distance 1
   * @returns {number}            The target volume level
   * @private
   */
  private _getEasingVolume;
  /**
   * Actions to take when the darkness level of the Scene is changed
   * @param {number} darkness   The new darkness level
   * @param {number} prior      The prior darkness level
   * @internal
   */
  _onDarknessChange(darkness: number, prior: number): void;
  /**
   * Handle mouse cursor movements which may cause ambient audio previews to occur
   * @param {PIXI.InteractionEvent} event     The initiating mouse move interaction event
   */
  _onMouseMove(event: PIXI.InteractionEvent): void;
  /** @inheritdoc */
  _onDragLeftStart(event: any): Promise<any>;
  /** @inheritdoc */
  _onDragLeftDrop(event: any): Promise<void>;
  /**
   * Handle PlaylistSound document drop data.
   * @param {DragEvent} event  The drag drop event
   * @param {object} data      The dropped transfer data.
   */
  _onDropData(event: DragEvent, data: object): Promise<any>;
}
/**
 * This Canvas Layer provides a container for MeasuredTemplate objects.
 * @category - Canvas
 */
declare class TemplateLayer extends PlaceablesLayer {
  /**
   * Register game settings used by the TemplatesLayer
   */
  static registerSettings(): void;
  /** @inheritdoc */
  _onDragLeftStart(event: any): Promise<any>;
  /** @inheritdoc */
  _onMouseWheel(event: any): Promise<PlaceableObject> | undefined;
}
/**
 * A PlaceablesLayer designed for rendering the visual Scene for a specific vertical cross-section.
 * @category - Canvas
 */
declare class TilesLayer extends PlaceablesLayer {
  /**
   * A mapping of url to texture data
   * @type {Map<string,object>}
   */
  textureDataMap: Map<string, object>;
  /** @inheritdoc */
  get hud(): any;
  /**
   * An array of Tile objects which are rendered within the objects container
   * @type {Tile[]}
   */
  get tiles(): Function[];
  /**
   * Get an array of overhead Tile objects which are roofs
   * @returns {Tile[]}
   */
  get roofs(): Function[];
  /**
   * Determine whether to display roofs
   * @type {boolean}
   */
  get displayRoofs(): boolean;
  /**
   * A convenience reference to the tile occlusion mask on the primary canvas group.
   * @type {CachedContainer}
   */
  get depthMask(): CachedContainer;
  /**
   * Activate a sublayer of the tiles layer, which controls interactivity of placeables and release controlled objects.
   * @param {boolean} [foreground=false]  Which sublayer need to be activated? Foreground or background?
   * @internal
   */
  _activateSubLayer(foreground?: boolean | undefined): void;
  /** @inheritdoc */
  _onDragLeftDrop(event: any): void;
  /**
   * Handle drop events for Tile data on the Tiles Layer
   * @param {DragEvent} event     The concluding drag event
   * @param {object} data         The extracted Tile data
   * @private
   */
  private _onDropData;
  /**
   * Prepare the data object when a new Tile is dropped onto the canvas
   * @param {DragEvent} event     The concluding drag event
   * @param {object} data         The extracted Tile data
   * @returns {object}            The prepared data to create
   */
  _getDropData(event: DragEvent, data: object): object;
}
/**
 * The Tokens Container.
 * @category - Canvas
 */
declare class TokenLayer extends PlaceablesLayer {
  /**
   * The current index position in the tab cycle
   * @type {number|null}
   * @private
   */
  private _tabIndex;
  /**
   * Token objects on this layer utilize the TokenHUD
   */
  get hud(): any;
  /**
   * An Array of tokens which belong to actors which are owned
   * @type {Token[]}
   */
  get ownedTokens(): Function[];
  /**
   * Target all Token instances which fall within a coordinate rectangle.
   *
   * @param {object} rectangle                      The selection rectangle.
   * @param {number} rectangle.x                    The top-left x-coordinate of the selection rectangle
   * @param {number} rectangle.y                    The top-left y-coordinate of the selection rectangle
   * @param {number} rectangle.width                The width of the selection rectangle
   * @param {number} rectangle.height               The height of the selection rectangle
   * @param {object} [options]                      Additional options to configure targeting behaviour.
   * @param {boolean} [options.releaseOthers=true]  Whether or not to release other targeted tokens
   * @returns {number}                              The number of Token instances which were targeted.
   */
  targetObjects(
    {
      x,
      y,
      width,
      height,
    }: {
      x: number;
      y: number;
      width: number;
      height: number;
    },
    {
      releaseOthers,
    }?:
      | {
          releaseOthers?: boolean | undefined;
        }
      | undefined
  ): number;
  /**
   * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
   * Tokens are currently sorted in order of their TokenID
   *
   * @param {boolean} forwards  Which direction to cycle. A truthy value cycles forward, while a false value
   *                            cycles backwards.
   * @param {boolean} reset     Restart the cycle order back at the beginning?
   * @returns {Token|null}       The Token object which was cycled to, or null
   */
  cycleTokens(forwards: boolean, reset: boolean): Function | null;
  /**
   * Add or remove the set of currently controlled Tokens from the active combat encounter
   * @param {boolean} state         The desired combat state which determines if each Token is added (true) or
   *                                removed (false)
   * @param {Combat|null} combat    A Combat encounter from which to add or remove the Token
   * @param {Token|null} [token]    A specific Token which is the origin of the group toggle request
   * @return {Promise<Combatant[]>} The Combatants added or removed
   */
  toggleCombat(
    state?: boolean,
    combat?: Combat | null,
    { token }?: Function | null | undefined
  ): Promise<Function[]>;
  /**
   * Get the tab cycle order for tokens by sorting observable tokens based on their distance from top-left.
   * @returns {Token[]}
   * @private
   */
  private _getCycleOrder;
  /**
   * Immediately conclude the animation of any/all tokens
   */
  concludeAnimation(): void;
  /**
   * Animate targeting arrows on targeted tokens.
   * @private
   */
  private _animateTargets;
  _t: number | undefined;
  /**
   * Provide an array of Tokens which are eligible subjects for overhead tile occlusion.
   * By default, only tokens which are currently controlled or owned by a player are included as subjects.
   * @protected
   */
  protected _getOccludableTokens(): any;
  /**
   * Handle dropping of Actor data onto the Scene canvas
   * @private
   */
  private _onDropActorData;
  /** @inheritDoc */
  _onClickLeft(event: any): any;
}
/**
 * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.
 * @category - Canvas
 */
declare class WallsLayer extends PlaceablesLayer {
  /**
   * Given a point and the coordinates of a wall, determine which endpoint is closer to the point
   * @param {Point} point         The origin point of the new Wall placement
   * @param {Wall} wall           The existing Wall object being chained to
   * @returns {PointArray}        The [x,y] coordinates of the starting endpoint
   */
  static getClosestEndpoint(point: Point, wall: Function): PointArray;
  /**
   * Synthetic Wall instances which represent the outer boundaries of the game canvas.
   * @type {Wall[]}
   */
  outerBounds: Function[];
  /**
   * Synthetic Wall instances which represent the inner boundaries of the scene rectangle.
   * @type {Wall[]}
   */
  innerBounds: Function[];
  /**
   * A graphics layer used to display chained Wall selection
   * @type {PIXI.Graphics}
   */
  chain: any;
  /**
   * Track whether we are currently within a chained placement workflow
   * @type {boolean}
   */
  _chain: boolean;
  /**
   * Track whether the layer is currently toggled to snap at exact grid precision
   * @type {boolean}
   */
  _forceSnap: boolean;
  /**
   * Track the most recently created or updated wall data for use with the clone tool
   * @type {Object|null}
   * @private
   */
  private _cloneType;
  /**
   * Reference the last interacted wall endpoint for the purposes of chaining
   * @type {{point: PointArray}}
   * @private
   */
  private last;
  /**
   * An Array of Wall instances in the current Scene which act as Doors.
   * @type {Wall[]}
   */
  get doors(): Function[];
  /**
   * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.
   * Cache unique wall endpoints and identify interior walls using overhead roof tiles.
   */
  initialize(): void;
  /**
   * Initialization to identify all intersections between walls.
   * These intersections are cached and used later when computing point source polygons.
   */
  identifyWallIntersections(): void;
  /**
   * Identify walls which are treated as "interior" because they are contained fully within a roof tile.
   */
  identifyInteriorWalls(): void;
  /**
   * Test whether movement along a given Ray collides with a Wall.
   * @param {Ray} ray                             The attempted movement
   * @param {object} [options={}]                 Options which customize how collision is tested.
   *                                              These options are passed to PointSourcePolygon.testCollision
   */
  checkCollision(ray: Ray, options?: object | undefined): any;
  /**
   * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer
   */
  highlightControlledSegments(): void;
  /** @inheritdoc */
  releaseAll(options: any): number;
  /** @inheritdoc */
  pasteObjects(position: any, options: any): Promise<any>;
  /**
   * Pan the canvas view when the cursor position gets close to the edge of the frame
   * @param {MouseEvent} event    The originating mouse movement event
   * @param {number} x            The x-coordinate
   * @param {number} y            The y-coordinate
   * @private
   */
  private _panCanvasEdge;
  /**
   * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
   * Require snap-to-grid until a redesign of the wall chaining system can occur.
   * @param {Object} point          The initial candidate point
   * @param {boolean} [snap=true]   Whether to snap to grid
   * @return {number[]}             The endpoint coordinates [x,y]
   * @private
   */
  private _getWallEndpointCoordinates;
  /**
   * The Scene Controls tools provide several different types of prototypical Walls to choose from
   * This method helps to translate each tool into a default wall data configuration for that type
   * @param {string} tool     The active canvas tool
   * @private
   */
  private _getWallDataFromActiveTool;
  /** @inheritdoc */
  _onDragLeftStart(event: any): any;
  get boundaries(): Set<Function>;
  #private;
}
/**
 * @typedef {Map<number,PolygonVertex>} VertexMap
 */
/**
 * @typedef {Set<PolygonEdge>} EdgeSet
 */
/**
 * @typedef {PointSourcePolygonConfig} ClockwiseSweepPolygonConfig
 * @property {number} [density]  The desired density of padding rays, a number per PI
 * @property {number} [externalRadius]  A secondary radius used in the case of a limited angle
 * @property {number} [aMin]        The minimum angle of emission
 * @property {number} [aMax]        The maximum angle of emission
 * @property {boolean} [hasLimitedRadius] Does this polygon have a limited radius?
 * @property {boolean} [hasLimitedAngle]  Does this polygon have a limited angle?
 * @property {number} [radiusE]     A small epsilon used for avoiding floating point precision issues
 * @property {boolean} [useInnerBounds] Whether to use the inner or outer bounding rectangle
 */
/**
 * @typedef {Ray} PolygonRay
 * @property {CollisionResult} result
 */
/**
 * A PointSourcePolygon implementation that uses CCW (counter-clockwise) geometry orientation.
 * Sweep around the origin, accumulating collision points based on the set of active walls.
 * This algorithm was created with valuable contributions from https://github.com/caewok
 *
 * @extends PointSourcePolygon
 */
declare class ClockwiseSweepPolygon extends PointSourcePolygon {
  /**
   * @deprecated since v10
   * @ignore
   */
  static getRayCollisions(
    ray: any,
    config?: {}
  ): boolean | PolygonVertex | PolygonVertex[] | null;
  /**
   * A mapping of vertices which define potential collision points
   * @type {VertexMap}
   */
  vertices: VertexMap;
  /**
   * The set of edges which define potential boundaries of the polygon
   * @type {EdgeSet}
   */
  edges: EdgeSet;
  /** @inheritDoc */
  initialize(origin: any, config: any): void;
  points: any;
  /**
   * Translate walls and other obstacles into edges which limit visibility
   * @private
   */
  private _identifyEdges;
  /**
   * Get the super-set of walls which could potentially apply to this polygon.
   * Define a custom collision test used by the Quadtree to obtain candidate Walls.
   * @returns {Set<Wall>}
   * @protected
   */
  protected _getWalls(): Set<Function>;
  /**
   * Compute the aggregate bounding box which is the intersection of all boundary shapes.
   * Round and pad the resulting rectangle by 1 pixel to ensure it always contains the origin.
   * @returns {PIXI.Rectangle}
   * @protected
   */
  protected _defineBoundingBox(): PIXI.Rectangle;
  /**
   * Test whether a wall should be included in the computed polygon for a given origin and type
   * @param {Wall} wall         The Wall being considered
   * @param {PIXI.Rectangle} bounds   The overall bounding box
   * @returns {boolean}         Should the wall be included?
   * @protected
   */
  protected _testWallInclusion(wall: Function, bounds: PIXI.Rectangle): boolean;
  /**
   * Consolidate all vertices from identified edges and register them as part of the vertex mapping.
   * @private
   */
  private _identifyVertices;
  /**
   * Add additional vertices for intersections between edges.
   * @param {Map<string,PolygonEdge>} wallEdgeMap    A mapping of wall IDs to PolygonEdge instances
   * @private
   */
  private _identifyIntersections;
  /**
   * Truncate an edge which intersects with a boundary by replacing one of its vertices with the intersection point.
   * @param {PolygonEdge} edge      The edge which intersects with the boundary
   * @param {PolygonVertex} v       The vertex of the intersection point
   * @private
   */
  private _truncateBoundaryEdge;
  /**
   * Execute the sweep over wall vertices
   * @private
   */
  private _executeSweep;
  /**
   * Update active edges at a given vertex
   * Must delete first, in case the edge is in both sets.
   * @param {PolygonVertex} vertex   The current vertex
   * @param {EdgeSet} activeEdges    A set of currently active edges
   * @private
   */
  private _updateActiveEdges;
  /**
   * Determine the initial set of active edges as those which intersect with the initial ray
   * @returns {EdgeSet}             A set of initially active edges
   * @private
   */
  private _initializeActiveEdges;
  /**
   * Sort vertices clockwise from the initial ray (due west).
   * @returns {PolygonVertex[]}             The array of sorted vertices
   * @private
   */
  private _sortVertices;
  /**
   * Test whether a target vertex is behind some closer active edge.
   * If the vertex is to the left of the edge, is must be behind the edge relative to origin.
   * If the vertex is collinear with the edge, it should be considered "behind" and ignored.
   * We know edge.A is ccw to edge.B because of the logic in _identifyVertices.
   * @param {PolygonVertex} vertex      The target vertex
   * @param {EdgeSet} activeEdges       The set of active edges
   * @returns {{isBehind: boolean, wasLimited: boolean}} Is the target vertex behind some closer edge?
   * @private
   */
  private _isVertexBehindActiveEdges;
  /**
   * Determine the result for the sweep at a given vertex
   * @param {PolygonVertex} vertex      The target vertex
   * @param {EdgeSet} activeEdges       The set of active edges
   * @param {boolean} hasCollinear      Are there collinear vertices behind the target vertex?
   * @private
   */
  private _determineSweepResult;
  /**
   * Switch to a new active edge.
   * Moving from the origin, a collision that first blocks a side must be stored as a polygon point.
   * Subsequent collisions blocking that side are ignored. Once both sides are blocked, we are done.
   *
   * Collisions that limit a side will block if that side was previously limited.
   *
   * If neither side is blocked and the ray internally collides with a non-limited edge, n skip without adding polygon
   * endpoints. Sight is unaffected before this edge, and the internal collision can be ignored.
   * @private
   *
   * @param {CollisionResult} result    The pending collision result
   * @param {EdgeSet} activeEdges       The set of currently active edges
   */
  private _switchEdge;
  /**
   * Identify the collision points between an emitted Ray and a set of active edges.
   * @param {PolygonRay} ray            The candidate ray to test
   * @param {EdgeSet} internalEdges     The set of edges to check for collisions against the ray
   * @returns {PolygonVertex[]}         A sorted array of collision points
   * @private
   */
  private _getInternalEdgeCollisions;
  /**
   * Constrain polygon points by applying boundary shapes.
   * @private
   */
  private _constrainBoundaryShapes;
  /** @override */
  override _testCollision(ray: any, mode: any): any;
  /**
   * Visualize the polygon, displaying its computed area, rays, and collision points
   * @param {Ray} ray
   * @param {PolygonVertex[]} collisions
   * @private
   */
  private _visualizeCollision;
  #private;
}
type VertexMap = Map<number, PolygonVertex>;
type EdgeSet = Set<PolygonEdge>;
type ClockwiseSweepPolygonConfig = PointSourcePolygonConfig;
type PolygonRay = Ray;
/**
 * A singleton class dedicated to manage the color spaces associated with the scene and the canvas.
 * @category - Canvas
 */
declare class CanvasColorManager {
  /**
   * Fallback colors.
   * @enum {Color}
   */
  static "__#49@#fallbackColors": {
    darknessColor: number;
    daylightColor: number;
    brightestColor: number;
    backgroundColor: number;
    fogUnexplored: number;
    fogExplored: number;
  };
  /**
   * Colors exposed by the manager.
   * @enum {Color}
   */
  colors: {
    darkness: undefined;
    halfdark: undefined;
    background: undefined;
    dim: undefined;
    bright: undefined;
    ambientBrightest: undefined;
    ambientDaylight: undefined;
    ambientDarkness: undefined;
    sceneBackground: undefined;
    fogExplored: undefined;
    fogUnexplored: undefined;
  };
  /**
   * Weights used by the manager to compute colors.
   * @enum {number}
   */
  weights: {
    dark: undefined;
    halfdark: undefined;
    dim: undefined;
    bright: undefined;
  };
  /**
   * Returns the darkness penalty for the actual scene configuration.
   * @returns {number}
   */
  get darknessPenalty(): number;
  /**
   * Get the darkness level of this scene.
   * @returns {number}
   */
  get darknessLevel(): number;
  /**
   * Initialize color space pertaining to a specific scene.
   * @param {object} [colors={}]
   * @param {Color|number|string} [colors.backgroundColor]     The background canvas color
   * @param {Color|number|string} [colors.brightestColor]      The brightest ambient color
   * @param {Color|number|string} [colors.darknessColor]       The color of darkness
   * @param {number} [colors.darknessLevel]                    A preview darkness level
   * @param {Color|number|string} [colors.daylightColor]       The ambient daylight color
   * @param {number} [colors.fogExploredColor]                 The color applied to explored areas
   * @param {number} [colors.fogUnexploredColor]               The color applied to unexplored areas
   */
  initialize({
    backgroundColor,
    brightestColor,
    darknessColor,
    darknessLevel,
    daylightColor,
    fogExploredColor,
    fogUnexploredColor,
  }?:
    | {
        backgroundColor?: any | number | string;
        brightestColor?: any | number | string;
        darknessColor?: any | number | string;
        darknessLevel?: number | undefined;
        daylightColor?: any | number | string;
        fogExploredColor?: number | undefined;
        fogUnexploredColor?: number | undefined;
      }
    | undefined): void;
  #private;
}
/**
 * Colors exposed by the manager.
 */
type colors = any;
/**
 * Weights used by the manager to compute colors.
 */
type weights = number;
/**
 * A Detection Mode which can be associated with any kind of sense/vision/perception.
 * A token could have multiple detection modes.
 */
declare class DetectionMode {
  /** @inheritDoc */
  static defineSchema(): {
    id: any;
    label: any;
    tokenConfig: any;
    walls: any;
    type: any;
  };
  /**
   * Get the detection filter pertaining to this mode.
   * @returns {PIXI.Filter|undefined}
   */
  static getDetectionFilter(): PIXI.Filter | undefined;
  /**
   * An optional filter to apply on the target when it is detected with this mode.
   * @type {PIXI.Filter|undefined}
   */
  static _detectionFilter: PIXI.Filter | undefined;
  /**
   * The type of the detection mode. If its sight based, sound based, etc.
   * It is related to wall's WALL_RESTRICTION_TYPES
   * @see CONST.WALL_RESTRICTION_TYPES
   * @enum {number}
   */
  static DETECTION_TYPES: {
    SIGHT: number;
    SOUND: number;
    MOVE: number;
    OTHER: number;
  };
  /**
   * The identifier of the basic sight detection mode.
   * @type {string}
   */
  static BASIC_MODE_ID: string;
  /**
   * Test visibility of a target object or array of points for a specific vision source.
   * @param {VisionSource} visionSource           The vision source being tested
   * @param {TokenDetectionMode} mode             The detection mode configuration
   * @param {CanvasVisibilityTestConfig} config   The visibility test configuration
   * @returns {boolean}                           Is the test target visible?
   */
  testVisibility(
    visionSource: VisionSource,
    mode: TokenDetectionMode,
    {
      object,
      tests,
    }?: {
      /**
       * The target object
       */
      object: PlaceableObject;
      /**
       * An array of visibility tests
       */
      tests: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
      }[];
    }
  ): boolean;
  /**
   * Can this VisionSource theoretically detect a certain object based on its properties?
   * This check should not consider the relative positions of either object, only their state.
   * @param {VisionSource} visionSource   The vision source being tested
   * @param {PlaceableObject} target      The target object being tested
   * @returns {boolean}                   Can the target object theoretically be detected by this vision source?
   * @protected
   */
  protected _canDetect(
    visionSource: VisionSource,
    target: PlaceableObject
  ): boolean;
  /**
   * Evaluate a single test point to confirm whether it is visible.
   * Standard detection rules require that the test point be both within LOS and within range.
   * @param {VisionSource} visionSource           The vision source being tested
   * @param {TokenDetectionMode} mode             The detection mode configuration
   * @param {PlaceableObject} target              The target object being tested
   * @param {CanvasVisibilityTest} test           The test case being evaluated
   * @returns {boolean}
   * @protected
   */
  protected _testPoint(
    visionSource: VisionSource,
    mode: TokenDetectionMode,
    target: PlaceableObject,
    test: {
      point: PIXI.Point;
      los: Map<VisionSource, boolean>;
    }
  ): boolean;
  /**
   * Test whether the line-of-sight requirement for detection is satisfied.
   * Always true if the detection mode bypasses walls, otherwise the test point must be contained by the LOS polygon.
   * The result of is cached for the vision source so that later checks for other detection modes do not repeat it.
   * @param {VisionSource} visionSource       The vision source being tested
   * @param {TokenDetectionMode} mode         The detection mode configuration
   * @param {PlaceableObject} target          The target object being tested
   * @param {CanvasVisibilityTest} test       The test case being evaluated
   * @returns {boolean}                       Is the LOS requirement satisfied for this test?
   * @protected
   */
  protected _testLOS(
    visionSource: VisionSource,
    mode: TokenDetectionMode,
    target: PlaceableObject,
    test: {
      point: PIXI.Point;
      los: Map<VisionSource, boolean>;
    }
  ): boolean;
  /**
   * Verify that a target is in range of a source.
   * @param {VisionSource} visionSource           The vision source being tested
   * @param {TokenDetectionMode} mode             The detection mode configuration
   * @param {PlaceableObject} target              The target object being tested
   * @param {CanvasVisibilityTest} test           The test case being evaluated
   * @returns {boolean}                           Is the target within range?
   * @protected
   */
  protected _testRange(
    visionSource: VisionSource,
    mode: TokenDetectionMode,
    target: PlaceableObject,
    test: {
      point: PIXI.Point;
      los: Map<VisionSource, boolean>;
    }
  ): boolean;
}
/**
 * A special detection mode which models standard human vision.
 * This mode is the default case which is tested first when evaluating visibility of objects.
 * It is also a special case, in that it is the only detection mode which considers the area of distant light sources.
 */
declare class DetectionModeBasicSight extends DetectionMode {
  /** @override */
  override _testPoint(
    visionSource: any,
    mode: any,
    target: any,
    test: any
  ): boolean;
}
/**
 * Detection mode that see invisible creatures.
 * This detection mode allows the source to:
 * - See/Detect the invisible target as if visible.
 * - The "See" version needs sight and is affected by blindness
 */
declare class DetectionModeInvisibility extends DetectionMode {
  /** @override */
  override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * Detection mode that see creatures in contact with the ground.
 */
declare class DetectionModeTremor extends DetectionMode {
  /** @override */
  override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * Detection mode that see ALL creatures (no blockers).
 * If not constrained by walls, see everything within the range.
 */
declare class DetectionModeAll extends DetectionMode {
  /** @override */
  override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * The type of the detection mode. If its sight based, sound based, etc.
 * It is related to wall's WALL_RESTRICTION_TYPES
 */
type DETECTION_TYPES = number;
/**
 * A fog of war management class which is the singleton canvas.fog instance.
 * @category - Canvas
 */
declare class FogManager {
  /**
   * The maximum allowable fog of war texture size.
   * @type {number}
   */
  static "__#50@#MAXIMUM_FOW_TEXTURE_SIZE": number;
  /**
   * Define the number of positions that are explored before a set of fog updates are pushed to the server.
   * @type {number}
   */
  static COMMIT_THRESHOLD: number;
  /**
   * The FogExploration document which applies to this canvas view
   * @type {FogExploration|null}
   */
  exploration: FogExploration | null;
  /**
   * Vision containers for explored positions which have not yet been committed to the saved texture.
   * @type {PIXI.Container}
   */
  get pending(): PIXI.Container;
  /**
   * The container of previously revealed exploration.
   * @type {PIXI.Container}
   */
  get revealed(): PIXI.Container;
  /**
   * A sprite containing the saved fog exploration texture.
   * @type {PIXI.Sprite}
   */
  get sprite(): PIXI.Sprite;
  /**
   * The configured resolution used for the saved fog-of-war texture
   * @type {FogResolution}
   */
  get resolution(): {
    resolution: number;
    width: number;
    height: number;
    mipmap: number;
    scaleMode: number;
    multisample: number;
  };
  /**
   * Does the currently viewed Scene support Token field of vision?
   * @type {boolean}
   */
  get tokenVision(): boolean;
  /**
   * Does the currently viewed Scene support fog of war exploration?
   * @type {boolean}
   */
  get fogExploration(): boolean;
  /**
   * Initialize fog of war - resetting it when switching scenes or re-drawing the canvas
   * @returns {Promise<void>}
   */
  initialize(): Promise<void>;
  /**
   * Clear the fog and reinitialize properties (commit and save in non reset mode)
   * @returns {Promise<void>}
   */
  clear(): Promise<void>;
  /**
   * Once a new Fog of War location is explored, composite the explored container with the current staging sprite
   * Save that staging Sprite as the rendered fog exploration and swap it out for a fresh staging texture
   * Do all this asynchronously, so it doesn't block token movement animation since this takes some extra time
   */
  commit(): void;
  /**
   * Load existing fog of war data from local storage and populate the initial exploration sprite
   * @returns {Promise<(PIXI.Texture|void)>}
   */
  load(): Promise<PIXI.Texture | void>;
  /**
   * Dispatch a request to reset the fog of war exploration status for all users within this Scene.
   * Once the server has deleted existing FogExploration documents, the _onReset handler will re-draw the canvas.
   */
  reset(): Promise<void>;
  /**
   * Save Fog of War exploration data to a base64 string to the FogExploration document in the database.
   * Assumes that the fog exploration has already been rendered as fog.rendered.texture.
   */
  save(): Promise<void>;
  /**
   * Update the fog layer when a player token reaches a board position which was not previously explored
   * @param {VisionSource} source   The vision source for which the fog layer should update
   * @param {boolean} force         Force fog to be updated even if the location is already explored
   * @returns {boolean}             Whether the source position represents a new fog exploration point
   */
  update(source: VisionSource, force?: boolean): boolean;
  /**
   * @typedef {object} FogResolution
   * @property {number} resolution
   * @property {number} width
   * @property {number} height
   * @property {number} mipmap
   * @property {number} scaleMode
   * @property {number} multisample
   */
  /**
   * Choose an adaptive fog rendering resolution which downscales the saved fog textures for larger dimension Scenes.
   * It is important that the width and height of the fog texture is evenly divisible by the downscaling resolution.
   * @returns {FogResolution}
   * @private
   */
  private configureResolution;
  /**
   * If fog of war data is reset from the server, re-draw the canvas
   * @returns {Promise}
   * @internal
   */
  _handleReset(): Promise<any>;
  #private;
}
type FogResolution = {
  resolution: number;
  width: number;
  height: number;
  mipmap: number;
  scaleMode: number;
  multisample: number;
};
/**
 * A helper class which manages the refresh workflow for perception layers on the canvas.
 * This controls the logic which batches multiple requested updates to minimize the amount of work required.
 * A singleton instance is available as canvas#perception.
 * @see {Canvas#perception}
 */
declare class PerceptionManager {
  /**
   * The set of state flags which are supported by the Perception Manager.
   * When a refresh occurs, operations associated with each true flag are executed and the state is reset.
   * @enum {{propagate: string[], reset: string[]}}
   */
  static FLAGS: {
    initializeLighting: {
      propagate: string[];
      reset: never[];
    };
    refreshLighting: {
      propagate: string[];
      reset: never[];
    };
    refreshLightSources: {
      propagate: never[];
      reset: never[];
    };
    refreshVisionSources: {
      propagate: never[];
      reset: never[];
    };
    refreshPrimary: {
      propagate: never[];
      reset: never[];
    };
    initializeVision: {
      propagate: string[];
      reset: never[];
    };
    refreshVision: {
      propagate: string[];
      reset: never[];
    };
    initializeSounds: {
      propagate: string[];
      reset: never[];
    };
    refreshSounds: {
      propagate: never[];
      reset: never[];
    };
    refreshTiles: {
      propagate: string[];
      reset: never[];
    };
    soundFadeDuration: {
      propagate: never[];
      reset: never[];
    };
    forceUpdateFog: {
      propagate: never[];
      reset: never[];
    };
  };
  /**
   * A shim mapping which supports backwards compatibility for old-style (V9 and before) perception manager flags.
   * @enum {string}
   */
  static COMPATIBILITY_MAPPING: {
    "lighting.initialize": string;
    "lighting.refresh": string;
    "sight.initialize": string;
    "sight.refresh": string;
    "sight.forceUpdateFog": string;
    "sounds.initialize": string;
    "sounds.refresh": string;
    "sounds.fade": string;
    "foreground.refresh": string;
  };
  /**
   * @deprecated since v10
   * @ignore
   */
  static get DEFAULTS(): {
    initializeLighting: {
      propagate: string[];
      reset: never[];
    };
    refreshLighting: {
      propagate: string[];
      reset: never[];
    };
    refreshLightSources: {
      propagate: never[];
      reset: never[];
    };
    refreshVisionSources: {
      propagate: never[];
      reset: never[];
    };
    refreshPrimary: {
      propagate: never[];
      reset: never[];
    };
    initializeVision: {
      propagate: string[];
      reset: never[];
    };
    refreshVision: {
      propagate: string[];
      reset: never[];
    };
    initializeSounds: {
      propagate: string[];
      reset: never[];
    };
    refreshSounds: {
      propagate: never[];
      reset: never[];
    };
    refreshTiles: {
      propagate: string[];
      reset: never[];
    };
    soundFadeDuration: {
      propagate: never[];
      reset: never[];
    };
    forceUpdateFog: {
      propagate: never[];
      reset: never[];
    };
  };
  /**
   * Activate perception management by registering the update function to the Ticker.
   */
  activate(): void;
  /**
   * Deactivate perception management by un-registering the update function from the Ticker.
   */
  deactivate(): void;
  /**
   * Update perception manager flags which configure which behaviors occur on the next frame render.
   * @param {object} flags        Flag values (true) to assign where the keys belong to PerceptionManager.FLAGS
   * @param {boolean} [v2=false]  Opt-in to passing v2 flags, otherwise a backwards compatibility shim will be applied
   */
  update(flags: object, v2?: boolean | undefined): void;
  /**
   * A helper function to perform an immediate initialization plus incremental refresh.
   */
  initialize(): void;
  /**
   * A helper function to perform an incremental refresh only.
   */
  refresh(): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  cancel(): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  schedule(options?: {}): void;
  #private;
}
/**
 * The set of state flags which are supported by the Perception Manager.
 * When a refresh occurs, operations associated with each true flag are executed and the state is reset.
 */
type FLAGS = {
  propagate: string[];
  reset: string[];
};
/**
 * A shim mapping which supports backwards compatibility for old-style (V9 and before) perception manager flags.
 */
type COMPATIBILITY_MAPPING = string;
/**
 * A special subclass of DataField used to reference an AbstractBaseShader definition.
 */
declare class ShaderField {
  /** @inheritdoc */
  static get _defaults(): any;
  /** @override */
  override _cast(value: any): any;
}
/**
 * A Vision Mode which can be selected for use by a Token.
 * The selected Vision Mode alters the appearance of various aspects of the canvas while that Token is the POV.
 */
declare class VisionMode {
  /** @inheritDoc */
  static defineSchema(): {
    id: any;
    label: any;
    tokenConfig: any;
    canvas: any;
    lighting: any;
    vision: any;
  };
  /**
   * The lighting illumination levels which are supported.
   * @enum {number}
   */
  static LIGHTING_LEVELS: {
    DARKNESS: number;
    HALFDARK: number;
    UNLIT: number;
    DIM: number;
    BRIGHT: number;
    BRIGHTEST: number;
  };
  /**
   * Flags for how each lighting channel should be rendered for the currently active vision modes:
   * - Disabled: this lighting layer is not rendered, the shaders does not decide.
   * - Enabled: this lighting layer is rendered normally, and the shaders can choose if they should be rendered or not.
   * - Required: the lighting layer is rendered, the shaders does not decide.
   * @enum {number}
   */
  static LIGHTING_VISIBILITY: {
    DISABLED: number;
    ENABLED: number;
    REQUIRED: number;
  };
  /**
   * Construct a Vision Mode using provided configuration parameters and callback functions.
   * @param {object} data             Data which fulfills the model defined by the VisionMode schema.
   * @param {object} [options]        Additional options passed to the DataModel constructor.
   */
  constructor(data?: object, options?: object | undefined);
  /**
   * A flag for whether this vision source is animated
   * @type {boolean}
   */
  animated: boolean;
  /**
   * Special handling which is needed when this Vision Mode is activated for a VisionSource.
   * @param {VisionSource} source   Activate this VisionMode for a specific source
   */
  activate(source: VisionSource): void;
  /**
   * An animation function which runs every frame while this Vision Mode is active.
   * @param {number} dt         The deltaTime passed by the PIXI Ticker
   */
  animate(dt: number): void;
  /**
   * Special handling which is needed when this Vision Mode is deactivated for a VisionSource.
   * @param {VisionSource} source   Deactivate this VisionMode for a specific source
   */
  deactivate(source: VisionSource): void;
}
/**
 * The lighting illumination levels which are supported.
 */
type LIGHTING_LEVELS = number;
/**
 * Flags for how each lighting channel should be rendered for the currently active vision modes:
 * - Disabled: this lighting layer is not rendered, the shaders does not decide.
 * - Enabled: this lighting layer is rendered normally, and the shaders can choose if they should be rendered or not.
 * - Required: the lighting layer is rendered, the shaders does not decide.
 */
type LIGHTING_VISIBILITY = number;
/**
 * An Abstract Base Class which defines a Placeable Object which represents a Document placed on the Canvas
 * @extends {PIXI.Container}
 * @abstract
 * @interface
 *
 * @param {abstract.Document} document      The Document instance which is represented by this object
 */
declare class PlaceableObject {
  /**
   * Identify the official Document name for this PlaceableObject class
   * @type {string}
   */
  static embeddedName: string;
  constructor(document: any);
  /**
   * Retain a reference to the Scene within which this Placeable Object resides
   * @type {Scene}
   */
  scene: Scene;
  /**
   * A reference to the Scene embedded Document instance which this object represents
   * @type {abstract.Document}
   */
  document: abstract.Document;
  /**
   * Track the field of vision for the placeable object.
   * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
   * @type {{fov: PIXI.Circle, los: PointSourcePolygon}}
   */
  vision: {
    fov: PIXI.Circle;
    los: PointSourcePolygon;
  };
  /**
   * A control icon for interacting with the object
   * @type {ControlIcon}
   */
  controlIcon: ControlIcon;
  /**
   * A mouse interaction manager instance which handles mouse workflows related to this object.
   * @type {MouseInteractionManager}
   */
  mouseInteractionManager: MouseInteractionManager;
  cullable: boolean;
  /**
   * Passthrough certain drag operations on locked objects.
   * @type {boolean}
   * @protected
   */
  protected _dragPassthrough: boolean;
  /**
   * Know if a placeable is in the hover-in state.
   * @type {boolean}
   * @internal
   */
  _isHoverIn: boolean;
  /**
   * The mouse interaction state of this placeable.
   * @type {MouseInteractionManager.INTERACTION_STATES}
   */
  get interactionState(): {
    NONE: number;
    HOVER: number;
    CLICKED: number;
    DRAG: number;
    DROP: number;
  };
  /**
   * The bounding box for this PlaceableObject.
   * This is required if the layer uses a Quadtree, otherwise it is optional
   * @returns {Rectangle}
   */
  get bounds(): Rectangle;
  /**
   * The central coordinate pair of the placeable object based on it's own width and height
   * @type {PIXI.Point}
   */
  get center(): PIXI.Point;
  /**
   * The id of the corresponding Document which this PlaceableObject represents.
   * @type {string}
   */
  get id(): string;
  /**
   * A unique identifier which is used to uniquely identify elements on the canvas related to this object.
   * @type {string}
   */
  get objectId(): string;
  /**
   * The named identified for the source object associated with this PlaceableObject.
   * This differs from the objectId because the sourceId is the same for preview objects as for the original.
   * @type {string}
   */
  get sourceId(): string;
  /**
   * Is this placeable object a temporary preview?
   * @type {boolean}
   */
  get isPreview(): boolean;
  /**
   * The field-of-vision polygon for the object, if it has been computed
   * @type {PIXI.Circle}
   */
  get fov(): PIXI.Circle;
  /**
   * Provide a reference to the CanvasLayer which contains this PlaceableObject.
   * @type {PlaceablesLayer}
   */
  get layer(): PlaceablesLayer;
  /**
   * The line-of-sight polygon for the object, if it has been computed
   * @type {PointSourcePolygon|null}
   */
  get los(): PointSourcePolygon | null;
  /**
   * A Form Application which is used to configure the properties of this Placeable Object or the Document it
   * represents.
   * @type {FormApplication}
   */
  get sheet(): FormApplication;
  /**
   * An indicator for whether the object is currently controlled
   * @type {boolean}
   */
  get controlled(): boolean;
  set hover(arg: boolean);
  /**
   * An indicator for whether the object is currently a hover target
   * @type {boolean}
   */
  get hover(): boolean;
  /**
   * Test whether a user can perform a certain interaction regarding a Placeable Object
   * @param {User} user       The User performing the action
   * @param {string} action   The named action being attempted
   * @returns {boolean}       Does the User have rights to perform the action?
   */
  can(user: User, action: string): boolean;
  /**
   * Can the User access the HUD for this Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canHUD(user: User, event: object): boolean;
  /**
   * Does the User have permission to configure the Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canConfigure(user: User, event: object): boolean;
  /**
   * Does the User have permission to control the Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canControl(user: User, event: object): boolean;
  /**
   * Does the User have permission to view details of the Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canView(user: User, event: object): boolean;
  /**
   * Does the User have permission to create the underlying Document?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canCreate(user: User, event: object): boolean;
  /**
   * Does the User have permission to drag this Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canDrag(user: User, event: object): boolean;
  /**
   * Does the User have permission to hover on this Placeable Object?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canHover(user: User, event: object): boolean;
  /**
   * Does the User have permission to update the underlying Document?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canUpdate(user: User, event: object): boolean;
  /**
   * Does the User have permission to delete the underlying Document?
   * @param {User} user       The User performing the action.
   * @param {object} event    The event object.
   * @returns {boolean}       The returned status.
   * @protected
   */
  protected _canDelete(user: User, event: object): boolean;
  /**
   * Clear the display of the existing object.
   * @returns {PlaceableObject}    The cleared object
   */
  clear(): PlaceableObject;
  /**
   * Clone the placeable object, returning a new object with identical attributes.
   * The returned object is non-interactive, and has no assigned ID.
   * If you plan to use it permanently you should call the create method.
   * @returns {PlaceableObject}  A new object with identical data
   */
  clone(): PlaceableObject;
  /** @inheritdoc */
  destroy(options: any): any;
  /**
   * The inner _destroy method which may optionally be defined by each PlaceableObject subclass.
   * @param {object} [options]    Options passed to the initial destroy call
   * @protected
   */
  protected _destroy(options?: object | undefined): void;
  /**
   * Draw the placeable object into its parent container
   * @returns {Promise<PlaceableObject>}  The drawn object
   */
  draw(): Promise<PlaceableObject>;
  /**
   * The inner _draw method which must be defined by each PlaceableObject subclass.
   * @abstract
   * @protected
   */
  protected _draw(): Promise<void>;
  /**
   * Refresh the current display state of the Placeable Object
   * @param {object} [options]      Options which may modify the refresh workflow
   * @returns {PlaceableObject}     The refreshed object
   */
  refresh(options?: object | undefined): PlaceableObject;
  /**
   * The inner _refresh method which must be defined by each PlaceableObject subclass.
   * @param {object} options        Options which may modify the refresh workflow
   * @abstract
   * @protected
   */
  protected _refresh(options: object): void;
  /**
   * Register pending canvas operations which should occur after a new PlaceableObject of this type is created
   * @param {object} data
   * @param {object} options
   * @param {string} userId
   * @protected
   */
  protected _onCreate(data: object, options: object, userId: string): void;
  /**
   * Define additional steps taken when an existing placeable object of this type is updated with new data
   * @param {object} changed
   * @param {object} options
   * @param {string} userId
   * @protected
   */
  protected _onUpdate(changed: object, options: object, userId: string): void;
  zIndex: number | undefined;
  /**
   * Define additional steps taken when an existing placeable object of this type is deleted
   * @param {object} options
   * @param {string} userId
   * @protected
   */
  protected _onDelete(options: object, userId: string): void;
  /**
   * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
   * @param {Object} options                  Additional options which modify the control request
   * @param {boolean} options.releaseOthers   Release any other controlled objects first
   * @returns {boolean}                        A flag denoting whether control was successful
   */
  control(options?: { releaseOthers: boolean }): boolean;
  /**
   * Additional events which trigger once control of the object is established
   * @param {Object} options    Optional parameters which apply for specific implementations
   * @protected
   */
  protected _onControl(options: Object): void;
  /**
   * Release control over a PlaceableObject, removing it from the controlled set
   * @param {object} options          Options which modify the releasing workflow
   * @returns {boolean}               A Boolean flag confirming the object was released.
   */
  release(options?: object): boolean;
  /**
   * Additional events which trigger once control of the object is released
   * @param {object} options          Options which modify the releasing workflow
   * @protected
   */
  protected _onRelease(options: object): void;
  /**
   * Rotate the PlaceableObject to a certain angle of facing
   * @param {number} angle        The desired angle of rotation
   * @param {number} snap         Snap the angle of rotation to a certain target degree increment
   * @returns {Promise<PlaceableObject>} The rotated object
   */
  rotate(angle: number, snap: number): Promise<PlaceableObject>;
  /**
   * Determine a new angle of rotation for a PlaceableObject either from an explicit angle or from a delta offset.
   * @param {object} options    An object which defines the rotation update parameters
   * @param {number} [options.angle]    An explicit angle, either this or delta must be provided
   * @param {number} [options.delta=0]  A relative angle delta, either this or the angle must be provided
   * @param {number} [options.snap=0]   A precision (in degrees) to which the resulting angle should snap. Default is 0.
   * @returns {number}          The new rotation angle for the object
   */
  _updateRotation({
    angle,
    delta,
    snap,
  }?: {
    angle?: number | undefined;
    delta?: number | undefined;
    snap?: number | undefined;
  }): number;
  /**
   * Obtain a shifted position for the Placeable Object
   * @param {number} dx         The number of grid units to shift along the X-axis
   * @param {number} dy         The number of grid units to shift along the Y-axis
   * @returns {{x:number, y:number}} The shifted target coordinates
   */
  _getShiftedPosition(
    dx: number,
    dy: number
  ): {
    x: number;
    y: number;
  };
  /**
   * Activate interactivity for the Placeable Object
   */
  activateListeners(): void;
  /**
   * Create a standard MouseInteractionManager for the PlaceableObject
   * @protected
   */
  protected _createInteractionManager(): MouseInteractionManager;
  /**
   * Actions that should be taken for this Placeable Object when a mouseover event occurs
   * @see MouseInteractionManager#_handleMouseOver
   * @param {PIXI.InteractionEvent} event   The triggering canvas interaction event
   * @param {object} options                Options which customize event handling
   * @param {boolean} [options.hoverOutOthers=true] Trigger hover-out behavior on sibling objects
   */
  _onHoverIn(
    event: PIXI.InteractionEvent,
    {
      hoverOutOthers,
    }?: {
      hoverOutOthers?: boolean | undefined;
    }
  ): false | undefined;
  /**
   * Actions that should be taken for this Placeable Object when a mouseout event occurs
   * @see MouseInteractionManager#_handleMouseOut
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onHoverOut(event: PIXI.InteractionEvent): false | undefined;
  /**
   * Callback actions which occur on a single left-click event to assume control of the object
   * @see MouseInteractionManager#_handleClickLeft
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onClickLeft(event: PIXI.InteractionEvent): boolean | undefined;
  /**
   * Callback actions which occur on a double left-click event to activate
   * @see MouseInteractionManager#_handleClickLeft2
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onClickLeft2(event: PIXI.InteractionEvent): void;
  /**
   * Callback actions which occur on a single right-click event to configure properties of the object
   * @see MouseInteractionManager#_handleClickRight
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onClickRight(event: PIXI.InteractionEvent): void;
  /**
   * Callback actions which occur on a double right-click event to configure properties of the object
   * @see MouseInteractionManager#_handleClickRight2
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onClickRight2(event: PIXI.InteractionEvent): void;
  /**
   * Callback actions which occur when a mouse-drag action is first begun.
   * @see MouseInteractionManager#_handleDragStart
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onDragLeftStart(event: PIXI.InteractionEvent): any;
  /**
   * Begin a drag operation from the perspective of the preview clone.
   * Modify the appearance of both the clone (this) and the original (_original) object.
   * @protected
   */
  protected _onDragStart(): void;
  alpha: number | undefined;
  visible: boolean | undefined;
  /**
   * Conclude a drag operation from the perspective of the preview clone.
   * Modify the appearance of both the clone (this) and the original (_original) object.
   * @protected
   */
  protected _onDragEnd(): void;
  /**
   * Callback actions which occur on a mouse-move operation.
   * @see MouseInteractionManager#_handleDragMove
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   */
  _onDragLeftMove(event: PIXI.InteractionEvent): any;
  /**
   * Callback actions which occur on a mouse-move operation.
   * @see MouseInteractionManager#_handleDragDrop
   * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
   * @returns {Promise<*>}
   */
  _onDragLeftDrop(event: PIXI.InteractionEvent): Promise<any>;
  /**
   * Callback actions which occur on a mouse-move operation.
   * @see MouseInteractionManager#_handleDragCancel
   * @param {MouseEvent} event  The triggering mouse click event
   */
  _onDragLeftCancel(event: MouseEvent): any;
  /**
   * Callback action which occurs on a long press.
   * @see MouseInteractionManager#_handleLongPress
   * @param {PIXI.InteractionEvent} event   The triggering canvas interaction event
   * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
   * @protected
   */
  protected _onLongPress(event: PIXI.InteractionEvent, origin: PIXI.Point): any;
  #private;
}
/**
 * The Drawing object is an implementation of the PlaceableObject container.
 * Each Drawing is a placeable object in the DrawingsLayer.
 * @category - Canvas
 * @see {@link DrawingDocument}
 * @see {@link DrawingsLayer}
 */
declare class Drawing extends PlaceableObject {
  /**
   * The rate at which points are sampled (in milliseconds) during a freehand drawing workflow
   * @type {number}
   */
  static FREEHAND_SAMPLE_RATE: number;
  /**
   * A convenience reference to the possible shape types.
   * @enum {string}
   */
  static SHAPE_TYPES: any;
  /**
   * Adjust the location, dimensions, and points of the Drawing before committing the change
   * @param {object} data   The DrawingData pending update
   * @returns {object}      The adjusted data
   * @private
   */
  private static normalizeShape;
  /**
   * The border frame and resizing handles for the drawing.
   * @type {PIXI.Container}
   */
  frame: PIXI.Container;
  /**
   * A text label that may be displayed as part of the interface layer for the Drawing.
   * @type {PreciseText|null}
   */
  text: PreciseText | null;
  /**
   * The drawing shape which is rendered as a PIXI.Graphics subclass in the PrimaryCanvasGroup.
   * @type {DrawingShape}
   */
  shape: DrawingShape;
  /**
   * An internal timestamp for the previous freehand draw time, to limit sampling.
   * @type {number}
   * @private
   */
  private _drawTime;
  /**
   * An internal flag for the permanent points of the polygon.
   * @type {number[]}
   * @private
   */
  private _fixedPoints;
  /**
   * A Boolean flag for whether the Drawing utilizes a tiled texture background?
   * @type {boolean}
   */
  get isTiled(): boolean;
  /**
   * A Boolean flag for whether the Drawing is a Polygon type (either linear or freehand)?
   * @type {boolean}
   */
  get isPolygon(): boolean;
  /**
   * Does the Drawing have text that is displayed?
   * @type {boolean}
   */
  get hasText(): boolean;
  /**
   * The shape type that this Drawing represents. A value in Drawing.SHAPE_TYPES.
   * @see {@link Drawing.SHAPE_TYPES}
   * @type {string}
   */
  get type(): string;
  _pendingText: any;
  /** @inheritDoc */
  _destroy(options: any): void;
  texture: any;
  /**
   * Prepare the text style used to instantiate a PIXI.Text or PreciseText instance for this Drawing document.
   * @returns {PIXI.TextStyle}
   * @protected
   */
  protected _getTextStyle(): PIXI.TextStyle;
  /** @override */
  override _refresh(options: any): void;
  hitArea: any;
  buttonMode: boolean | undefined;
  /**
   * Add a new polygon point to the drawing, ensuring it differs from the last one
   * @param {Point} position            The drawing point to add
   * @param {object} [options]          Options which configure how the point is added
   * @param {boolean} [options.round=false]     Should the point be rounded to integer coordinates?
   * @param {boolean} [options.snap=false]      Should the point be snapped to grid precision?
   * @param {boolean} [options.temporary=false] Is this a temporary control point?
   * @internal
   */
  _addPoint(
    position: Point,
    {
      round,
      snap,
      temporary,
    }?:
      | {
          round?: boolean | undefined;
          snap?: boolean | undefined;
          temporary?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Remove the last fixed point from the polygon
   * @private
   */
  private _removePoint;
  /** @override */
  override _onControl(options: any): void;
  _onkeydown: ((event: KeyboardEvent) => any) | null | undefined;
  /** @override */
  override _onRelease(options: any): any;
  /** @override */
  override _onDelete(...args: any[]): void;
  /**
   * Handle text entry in an active text tool
   * @param {KeyboardEvent} event
   * @private
   */
  private _onDrawingTextKeydown;
  /** @override */
  override _onUpdate(changed: any, options: any, userId: any): void;
  /** @override */
  override _canControl(user: any, event: any): any;
  /** @override */
  override _canConfigure(user: any, event: any): boolean;
  /**
   * Handle mouse movement which modifies the dimensions of the drawn shape
   * @param {PIXI.InteractionEvent} event
   * @private
   */
  private _onMouseDraw;
  /** @override */
  override _onDragLeftStart(event: any): any;
  /** @override */
  override _onDragLeftMove(event: any): any;
  /** @override */
  override _onDragLeftDrop(event: any): Promise<any>;
  /** @override */
  override _onDragLeftCancel(event: any): any;
  /**
   * Handle mouse-over event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseover event
   * @private
   */
  private _onHandleHoverIn;
  /**
   * Handle mouse-out event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseout event
   * @private
   */
  private _onHandleHoverOut;
  _dragHandle: boolean | undefined;
  /**
   * When we start a drag event - create a preview copy of the Tile for re-positioning
   * @param {PIXI.InteractionEvent} event   The mousedown event
   * @private
   */
  private _onHandleMouseDown;
  _original: any;
  /**
   * Handle the beginning of a drag event on a resize handle
   * @param {PIXI.InteractionEvent} event   The mouse interaction event
   * @private
   */
  private _onHandleDragStart;
  /**
   * Handle mousemove while dragging a tile scale handler
   * @param {PIXI.InteractionEvent} event   The mouse interaction event
   * @private
   */
  private _onHandleDragMove;
  /**
   * Handle mouseup after dragging a tile scale handler
   * @param {PIXI.InteractionEvent} event   The mouseup event
   * @private
   */
  private _onHandleDragDrop;
  /**
   * Handle cancellation of a drag event for one of the resizing handles
   * @param {PointerEvent} event            The drag cancellation event
   * @private
   */
  private _onHandleDragCancel;
  /**
   * Apply a vectorized rescaling transformation for the drawing data
   * @param {Object} original     The original drawing data
   * @param {number} dx           The pixel distance dragged in the horizontal direction
   * @param {number} dy           The pixel distance dragged in the vertical direction
   * @private
   */
  private _rescaleDimensions;
  #private;
}
/**
 * A convenience reference to the possible shape types.
 */
type SHAPE_TYPES = string;
/**
 * An AmbientLight is an implementation of PlaceableObject which represents a dynamic light source within the Scene.
 * @category - Canvas
 * @see {@link AmbientLightDocument}
 * @see {@link LightingLayer}
 */
declare class AmbientLight extends PlaceableObject {
  /**
   * A reference to the PointSource object which defines this light source area of effect
   * @type {LightSource}
   */
  source: LightSource;
  /** @inheritdoc */
  get bounds(): PIXI.Rectangle;
  /**
   * A convenience accessor to the LightData configuration object
   * @returns {LightData}
   */
  get config(): LightData;
  /**
   * Test whether a specific AmbientLight source provides global illumination
   * @type {boolean}
   */
  get global(): boolean;
  /**
   * The maximum radius in pixels of the light field
   * @type {number}
   */
  get radius(): number;
  /**
   * Get the pixel radius of dim light emitted by this light source
   * @type {number}
   */
  get dimRadius(): number;
  /**
   * Get the pixel radius of bright light emitted by this light source
   * @type {number}
   */
  get brightRadius(): number;
  /**
   * Is this Ambient Light currently visible? By default, true only if the source actively emits light.
   * @type {boolean}
   */
  get isVisible(): boolean;
  /**
   * Does this Ambient Light actively emit light given its properties and the current darkness level of the Scene?
   * @type {boolean}
   */
  get emitsLight(): boolean;
  /** @override */
  override _destroy(options: any): void;
  field: any;
  /**
   * Draw the ControlIcon for the AmbientLight
   * @returns {ControlIcon}
   * @private
   */
  private _drawControlIcon;
  /** @override */
  override _refresh(options: any): void;
  /**
   * Refresh the display of the ControlIcon for this AmbientLight source
   */
  refreshControl(): void;
  /**
   * Update the LightSource associated with this AmbientLight object.
   * @param {object} [options={}]   Options which modify how the source is updated
   * @param {boolean} [options.defer]     Defer refreshing the LightingLayer to manually call that refresh later
   * @param {boolean} [options.deleted]   Indicate that this light source has been deleted
   */
  updateSource({
    defer,
    deleted,
  }?:
    | {
        defer?: boolean | undefined;
        deleted?: boolean | undefined;
      }
    | undefined): void;
  /** @inheritdoc */
  _onCreate(...args: any[]): void;
  /** @inheritdoc */
  _onUpdate(...args: any[]): void;
  /** @inheritdoc */
  _onDelete(...args: any[]): void;
  /** @inheritdoc */
  _canHUD(user: any, event: any): any;
  /** @inheritdoc */
  _canConfigure(user: any, event: any): boolean;
  /** @inheritdoc */
  _onClickRight(event: any): void;
  /** @inheritdoc */
  _onDragLeftMove(event: any): void;
  /** @inheritdoc */
  _onDragLeftCancel(event: any): void;
}
/**
 * A mixin which decorates a DisplayObject with additional properties expected for rendering in the PrimaryCanvasGroup.
 * @category - Mixins
 * @param {typeof PIXI.DisplayObject} DisplayObject   The parent DisplayObject class being mixed
 * @returns {typeof PrimaryCanvasObject}              A DisplayObject subclass mixed with PrimaryCanvasObject features
 */
declare function PrimaryCanvasObjectMixin(DisplayObject: any): any;
/**
 * A SpriteMesh which visualizes a Token object in the PrimaryCanvasGroup.
 */
declare class TokenMesh {
  /** @inheritDoc */
  refresh(attributes?: undefined): void;
  angle: any;
  alpha: any;
  tint: any;
}
/**
 * A SpriteMesh which visualizes a Tile object in the PrimaryCanvasGroup.
 */
declare class TileMesh {
  /** @inheritDoc */
  refresh(): void;
  width: any;
  height: any;
  alpha: any;
  tint: any;
  /** @inheritDoc */
  setPosition(): void;
  angle: any;
  zIndex: any;
  /**
   * Render the mesh for tile occlusion
   * @param {PIXI.Renderer} renderer
   */
  renderOcclusion(renderer: PIXI.Renderer): void;
  pluginName: string | null | undefined;
  blendMode: any;
  worldAlpha: any;
}
/**
 * A special case subclass of PIXI.TilingSprite which is used in cases where the tile texture needs to repeat.
 * This should eventually be refactored in favor of a more generalized TilingMesh.
 */
declare class TileSprite {
  constructor(...args: any[]);
  setShaderClass(): void;
  renderOcclusion(): void;
  set shader(arg: {});
  get shader(): {};
  readonly refresh: any;
  readonly setPosition: any;
}
/**
 * A special subclass of PIXI.Container used to represent a Drawing in the PrimaryCanvasGroup.
 */
declare class DrawingShape {
  /** @inheritDoc */
  refresh(): void;
  /** @inheritDoc */
  setPosition(): void;
  zIndex: any;
  angle: any;
  alpha: number | undefined;
  visible: any;
  #private;
}
/**
 * A Note is an implementation of PlaceableObject which represents an annotated location within the Scene.
 * Each Note links to a JournalEntry document and represents its location on the map.
 * @category - Canvas
 * @see {@link NoteDocument}
 * @see {@link NotesLayer}
 */
declare class Note extends PlaceableObject {
  /** @override */
  override get bounds(): PIXI.Rectangle;
  /**
   * The associated JournalEntry which is referenced by this Note
   * @type {JournalEntry}
   */
  get entry(): JournalEntry;
  /**
   * The specific JournalEntryPage within the associated JournalEntry referenced by this Note.
   */
  get page(): any;
  /**
   * The text label used to annotate this Note
   * @type {string}
   */
  get text(): string;
  /**
   * The Map Note icon size
   * @type {number}
   */
  get size(): number;
  /**
   * Determine whether the Note is visible to the current user based on their perspective of the Scene.
   * Visibility depends on permission to the underlying journal entry, as well as the perspective of controlled Tokens.
   * If Token Vision is required, the user must have a token with vision over the note to see it.
   * @type {boolean}
   */
  get isVisible(): boolean;
  tooltip: any;
  /**
   * Draw the ControlIcon for the Map Note
   * @returns {ControlIcon}
   * @protected
   */
  protected _drawControlIcon(): ControlIcon;
  /**
   * Draw the map note Tooltip as a Text object
   * @returns {PIXI.Text}
   * @protected
   */
  protected _drawTooltip(): PIXI.Text;
  /**
   * Define a PIXI TextStyle object which is used for the tooltip displayed for this Note
   * @returns {PIXI.TextStyle}
   * @protected
   */
  protected _getTextStyle(): PIXI.TextStyle;
  /** @override */
  override _refresh(options: any): void;
  /** @override */
  override _onUpdate(data: any): void;
  /** @override */
  override _canHover(user: any): boolean;
  /** @override */
  override _canView(user: any): any;
  /** @override */
  override _canConfigure(user: any): any;
  /** @inheritdoc */
  _onHoverIn(event: any, options: any): false | undefined;
  /** @inheritdoc */
  _onHoverOut(event: any): false | undefined;
  /** @inheritdoc */
  _onClickLeft2(event: any): Application | undefined;
}
/**
 * An AmbientSound is an implementation of PlaceableObject which represents a dynamic audio source within the Scene.
 * @category - Canvas
 * @see {@link AmbientSoundDocument}
 * @see {@link SoundsLayer}
 */
declare class AmbientSound extends PlaceableObject {
  /**
   * The Sound which manages playback for this AmbientSound effect
   * @type {Sound|null}
   */
  sound: Sound | null;
  /**
   * A SoundSource object which manages the area of effect for this ambient sound
   * @type {SoundSource}
   */
  source: SoundSource;
  /**
   * Create a Sound used to play this AmbientSound object
   * @returns {Sound|null}
   * @private
   */
  private _createSound;
  /**
   * Is this ambient sound is currently audible based on its hidden state and the darkness level of the Scene?
   * @type {boolean}
   */
  get isAudible(): boolean;
  /** @inheritdoc */
  get bounds(): PIXI.Rectangle;
  /**
   * A convenience accessor for the sound radius in pixels
   * @type {number}
   */
  get radius(): number;
  /**
   * Toggle playback of the sound depending on whether or not it is audible
   * @param {boolean} isAudible     Is the sound audible?
   * @param {number} volume         The target playback volume
   * @param {object} [options={}]   Additional options which affect sound synchronization
   * @param {number} [options.fade=250]  A duration in milliseconds to fade volume transition
   */
  sync(
    isAudible: boolean,
    volume: number,
    {
      fade,
    }?:
      | {
          fade?: number | undefined;
        }
      | undefined
  ): void;
  field: any;
  /** @override */
  override _destroy(options: any): void;
  /**
   * Draw the ControlIcon for the AmbientLight
   * @returns {ControlIcon}
   * @private
   */
  private _drawControlIcon;
  /** @inheritdoc */
  _refresh(options: any): void;
  /**
   * Refresh the display of the ControlIcon for this AmbientSound source
   */
  refreshControl(): void;
  /**
   * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
   * @param {object} [options={}]   Options which modify how the audio source is updated
   * @param {boolean} [options.defer]    Defer refreshing the SoundsLayer to manually call that refresh later.
   * @param {boolean} [options.deleted]  Indicate that this SoundSource has been deleted.
   */
  updateSource({
    defer,
    deleted,
  }?:
    | {
        defer?: boolean | undefined;
        deleted?: boolean | undefined;
      }
    | undefined): void;
  /** @inheritdoc */
  _onCreate(...args: any[]): void;
  /** @inheritdoc */
  _onUpdate(data: any, ...args: any[]): void;
  /** @inheritdoc */
  _onDelete(...args: any[]): void;
  /** @inheritdoc */
  _canHUD(user: any, event: any): any;
  /** @inheritdoc */
  _canConfigure(user: any, event: any): boolean;
  /** @inheritdoc */
  _onClickRight(event: any): void;
  /** @override */
  override _onDragLeftMove(event: any): void;
}
/**
 * A type of Placeable Object which highlights an area of the grid as covered by some area of effect.
 * @category - Canvas
 * @see {@link MeasuredTemplateDocument}
 * @see {@link TemplateLayer}
 */
declare class MeasuredTemplate extends PlaceableObject {
  /**
   * The geometry shape used for testing point intersection
   * @type {PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle}
   */
  shape:
    | PIXI.Circle
    | PIXI.Ellipse
    | PIXI.Polygon
    | PIXI.Rectangle
    | PIXI.RoundedRectangle;
  /**
   * The tiling texture used for this template, if any
   * @type {PIXI.Texture}
   */
  texture: PIXI.Texture;
  /**
   * The template graphics
   * @type {PIXI.Graphics}
   */
  template: any;
  /**
   * The measurement ruler label
   * @type {PreciseText}
   */
  ruler: PreciseText;
  /**
   * Internal property used to configure the control border thickness
   * @type {number}
   * @private
   */
  private _borderThickness;
  /** @inheritdoc */
  get bounds(): PIXI.Rectangle;
  /**
   * A convenience accessor for the border color as a numeric hex code
   * @returns {number}
   */
  get borderColor(): number;
  /**
   * A convenience accessor for the fill color as a numeric hex code
   * @returns {number}
   */
  get fillColor(): number;
  /**
   * A flag for whether the current User has full ownership over the MeasuredTemplate document.
   * @type {boolean}
   */
  get owner(): boolean;
  /**
   * Is this MeasuredTemplate currently visible on the Canvas?
   * @type {boolean}
   */
  get isVisible(): boolean;
  /**
   * A unique identifier which is used to uniquely identify related objects like a template effect or grid highlight.
   * @type {string}
   */
  get highlightId(): string;
  /** @override */
  override _destroy(options: any): void;
  /**
   * Draw the ControlIcon for the MeasuredTemplate
   * @returns {ControlIcon}
   * @private
   */
  private _drawControlIcon;
  /**
   * Draw the Text label used for the MeasuredTemplate
   * @returns {PreciseText}
   * @private
   */
  private _drawRulerText;
  /** @override */
  override _refresh(options: any): void;
  ray: Ray | undefined;
  /**
   * Refresh the display of the template outline and shape.
   * @protected
   */
  protected _refreshTemplate(): void;
  /**
   * Refresh the display of the ControlIcon for this MeasuredTemplate object.
   * @protected
   */
  protected _refreshControlIcon(): void;
  /**
   * Get a Circular area of effect given a radius of effect
   * @param {number} distance
   * @private
   */
  private _getCircleShape;
  /**
   * Get a Conical area of effect given a direction, angle, and distance
   * @param {number} direction
   * @param {number} angle
   * @param {number} distance
   * @private
   */
  private _getConeShape;
  /**
   * Get a Rectangular area of effect given a width and height
   * @param {number} direction
   * @param {number} distance
   * @private
   */
  private _getRectShape;
  /**
   * Get a rotated Rectangular area of effect given a width, height, and direction
   * @param {number} direction
   * @param {number} distance
   * @param {number} width
   * @private
   */
  private _getRayShape;
  /**
   * Update the displayed ruler tooltip text
   * @private
   */
  private _refreshRulerText;
  /**
   * Highlight the grid squares which should be shown under the area of effect
   */
  highlightGrid(): void;
  /**
   * Get the shape to highlight on a Scene which uses grid-less mode.
   * @returns {PIXI.Polygon|PIXI.Circle|PIXI.Rectangle}
   * @protected
   */
  protected _getGridHighlightShape():
    | PIXI.Polygon
    | PIXI.Circle
    | PIXI.Rectangle;
  /**
   * Get an array of points which define top-left grid spaces to highlight for square or hexagonal grids.
   * @returns {Point[]}
   * @protected
   */
  protected _getGridHighlightPositions(): Point[];
  /** @override */
  override rotate(angle: any, snap: any): Promise<any>;
  /** @override */
  override _canControl(user: any, event: any): any;
  /** @inheritdoc */
  _canHUD(user: any, event: any): boolean;
  /** @inheritdoc */
  _canConfigure(user: any, event: any): boolean;
  /** @override */
  override _canView(user: any, event: any): any;
  /** @inheritdoc */
  _onClickRight(event: any): void;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
}
/**
 * A Tile is an implementation of PlaceableObject which represents a static piece of artwork or prop within the Scene.
 * Tiles are drawn inside the {@link TilesLayer} container.
 * @category - Canvas
 *
 * @see {@link TileDocument}
 * @see {@link TilesLayer}
 */
declare class Tile extends PlaceableObject {
  /**
   * Roof types
   * @enum {number}
   */
  static ROOF_TYPES: {
    OCCLUSION: number;
    BACKGROUND: number;
    ILLUMINATION: number;
    COLORATION: number;
  };
  /**
   * Create a preview tile with a background texture instead of an image
   * @param {object} data     Initial data with which to create the preview Tile
   * @returns {PlaceableObject}
   */
  static createPreview(data: object): PlaceableObject;
  /**
   * The Tile border frame
   * @extends {PIXI.Container}
   * @property {PIXI.Graphics} border
   * @property {ResizeHandle} handle
   */
  frame: any;
  /**
   * The primary tile image texture
   * @type {PIXI.Texture}
   */
  texture: PIXI.Texture;
  /**
   * The Tile image sprite
   * @type {PIXI.Sprite}
   */
  tile: PIXI.Sprite;
  /**
   * A Tile background which is displayed if no valid image texture is present
   * @type {PIXI.Graphics}
   */
  bg: any;
  /**
   * Contains :
   * - the bounds of the tile data
   * - the cached mapping of non-transparent pixels (if roof)
   * - the filtered render texture (if roof)
   * @type {{minX: number, minY: number, maxX: number, maxY: number, pixels: Uint8Array, texture: PIXI.RenderTexture}}
   * @private
   */
  private _textureData;
  /**
   * A map of all linked sprite(s) to this tile
   * @type {Map<number,PIXI.Sprite>}
   * @private
   */
  private _linkedSprites;
  /**
   * A flag which tracks whether the overhead tile is currently in an occluded state
   * @type {boolean}
   */
  occluded: boolean;
  /**
   * A flag which tracks occluded state change for roof
   * @type {boolean}
   */
  _prevOccludedState: boolean;
  /**
   * A flag which tracks if the Tile is currently playing
   * @type {boolean}
   */
  playing: boolean;
  /**
   * Debounce assignment of the Tile occluded state to avoid cases like animated token movement which can rapidly
   * change Tile appearance.
   * Uses a 100ms debounce threshold.
   * @type {function(occluded: boolean): void}
   */
  debounceSetOcclusion: (arg0: occluded, arg1: boolean) => void;
  /**
   * Get the native aspect ratio of the base texture for the Tile sprite
   * @type {number}
   */
  get aspectRatio(): number;
  /** @override */
  override get bounds(): PIXI.Rectangle;
  /**
   * The HTML source element for the primary Tile texture
   * @type {HTMLImageElement|HTMLVideoElement}
   */
  get sourceElement(): HTMLVideoElement | HTMLImageElement;
  /**
   * Does this Tile depict an animated video texture?
   * @type {boolean}
   */
  get isVideo(): boolean;
  /**
   * Is this tile a roof?
   * @returns {boolean}
   */
  get isRoof(): boolean;
  /**
   * The effective volume at which this Tile should be playing, including the global ambient volume modifier
   * @type {number}
   */
  get volume(): number;
  mesh: any;
  /** @inheritdoc */
  _destroy(options: any): void;
  /** @override */
  override _refresh(options: any): void;
  hitArea: any;
  /**
   * Refresh the display of the Tile border
   * @param {PIXI.Rectangle} b      The bounds.
   * @private
   */
  private _refreshBorder;
  /**
   * Refresh the display of the Tile resizing handle.
   * @param {PIXI.Rectangle} b         The bounds.
   * @param {object} [options]
   * @param {number} [options.scaleX]
   * @param {number} [options.scaleY]
   * @protected
   */
  protected _refreshHandle(
    b: PIXI.Rectangle,
    {
      scaleX,
      scaleY,
    }?:
      | {
          scaleX?: number | undefined;
          scaleY?: number | undefined;
        }
      | undefined
  ): void;
  /**
   * Test whether a specific Token occludes this overhead tile.
   * Occlusion is tested against 9 points, the center, the four corners-, and the four cardinal directions
   * @param {Token} token       The Token to test
   * @param {object} [options]  Additional options that affect testing
   * @param {boolean} [options.corners=true]  Test corners of the hit-box in addition to the token center?
   * @returns {boolean}         Is the Token occluded by the Tile?
   */
  testOcclusion(
    token: Function,
    {
      corners,
    }?:
      | {
          corners?: boolean | undefined;
        }
      | undefined
  ): boolean;
  /**
   * Test whether the Tile pixel data contains a specific point in canvas space
   * @param {number} x
   * @param {number} y
   * @param {number} alphaThreshold     Value from which the pixel is taken into account, in the range [0, 1].
   * @returns {boolean}
   */
  containsPixel(x: number, y: number, alphaThreshold?: number): boolean;
  /**
   * Get alpha value at specific canvas coordinate.
   * @param {number} x
   * @param {number} y
   * @returns {number|null}    The alpha value (-1 if outside of the bounds) or null if no mesh or texture is present.
   */
  getPixelAlpha(x: number, y: number): number | null;
  /**
   * Process the tile texture :
   * Use the texture to create a cached mapping of pixel alpha for this Tile with real base texture size.
   * Cache the bounding box of non-transparent pixels for the un-rotated shape.
   * @returns {{minX: number, minY: number, maxX: number, maxY: number, pixels: Uint8Array|undefined}}
   * @private
   */
  private _createTextureData;
  /**
   * Compute the alpha-based bounding box for the tile, including an angle of rotation.
   * @returns {PIXI.Rectangle}
   * @private
   */
  private _getAlphaBounds;
  /** @override */
  override _onUpdate(
    data: any,
    options: {} | undefined,
    userId: any
  ): Promise<PlaceableObject> | undefined;
  /**
   * Update wall states and refresh lighting and vision when a tile becomes a roof, or when an existing roof tile's
   * state changes.
   * @private
   */
  private _refreshPerception;
  /** @inheritdoc */
  _canConfigure(user: any, event: any): boolean;
  /** @inheritdoc */
  _onHoverOut(event: any): false | undefined;
  /** @inheritdoc */
  _onClickLeft(event: any): boolean | undefined;
  /** @inheritdoc */
  _onClickLeft2(event: any): void;
  _dragHandle: boolean | undefined;
  /** @inheritdoc */
  _onDragLeftStart(event: any): any;
  /** @inheritdoc */
  _onDragLeftMove(event: any): any;
  /** @inheritdoc */
  _onDragLeftDrop(event: any): any;
  /** @inheritdoc */
  _onDragLeftCancel(event: any): any;
  /**
   * Handle mouse-over event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseover event
   * @protected
   */
  protected _onHandleHoverIn(event: PIXI.InteractionEvent): void;
  /**
   * Handle mouse-out event on a control handle
   * @param {PIXI.InteractionEvent} event   The mouseout event
   * @protected
   */
  protected _onHandleHoverOut(event: PIXI.InteractionEvent): void;
  /**
   * When we start a drag event - create a preview copy of the Tile for re-positioning
   * @param {PIXI.InteractionEvent} event   The mousedown event
   * @protected
   */
  protected _onHandleMouseDown(event: PIXI.InteractionEvent): void;
  _dragScaleX: number | undefined;
  _dragScaleY: number | undefined;
  /**
   * Handle the beginning of a drag event on a resize handle
   * @param {PIXI.InteractionEvent} event   The mousedown event
   * @protected
   */
  protected _onHandleDragStart(event: PIXI.InteractionEvent): void;
  /**
   * Handle mousemove while dragging a tile scale handler
   * @param {PIXI.InteractionEvent} event   The mousemove event
   * @protected
   */
  protected _onHandleDragMove(event: PIXI.InteractionEvent): void;
  /**
   * Handle mouseup after dragging a tile scale handler
   * @param {PIXI.InteractionEvent} event   The mouseup event
   * @protected
   */
  protected _onHandleDragDrop(event: PIXI.InteractionEvent): any;
  /**
   * Get resized Tile dimensions
   * @returns {Rectangle}
   * @private
   */
  private _getResizedDimensions;
  /**
   * Handle cancellation of a drag event for one of the resizing handles
   * @protected
   */
  protected _onHandleDragCancel(): void;
  #private;
}
/**
 * Roof types
 */
type ROOF_TYPES = number;
/**
 * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.
 * @category - Canvas
 * @see {TokenDocument}
 * @see {TokenLayer}
 */
declare class Token extends PlaceableObject {
  /**
   * A Graphics instance which renders the border frame for this Token inside the GridLayer.
   * @type {PIXI.Graphics}
   */
  border: any;
  /**
   * Track the set of User documents which are currently targeting this Token
   * @type {Set<User>}
   */
  targeted: Set<User>;
  /**
   * A reference to the SpriteMesh which displays this Token in the PrimaryCanvasGroup.
   * @type {TokenMesh}
   */
  mesh: TokenMesh;
  /**
   * A reference to the VisionSource object which defines this vision source area of effect
   * @type {VisionSource}
   */
  vision: VisionSource;
  /**
   * A reference to the LightSource object which defines this light source area of effect
   * @type {LightSource}
   */
  light: LightSource;
  /**
   * A reference to an animation that is currently in progress for this Token, if any
   * @type {Promise|null}
   * @internal
   */
  _animation: Promise<any> | null;
  /**
   * A convenient reference to the Actor object associated with the Token embedded document.
   * @returns {Actor|null}
   */
  get actor(): Actor | null;
  /**
   * A convenient reference for whether the current User has full control over the Token document.
   * @type {boolean}
   */
  get owner(): boolean;
  get isOwner(): any;
  /**
   * A boolean flag for whether the current game User has observer permission for the Token
   * @type {boolean}
   */
  get observer(): boolean;
  /**
   * Is the HUD display active for this token?
   * @returns {boolean}
   */
  get hasActiveHUD(): boolean;
  /**
   * Convenience access to the token's nameplate string
   * @type {string}
   */
  get name(): string;
  /** @override */
  override get bounds(): PIXI.Rectangle;
  /**
   * Defines the filter to use for detection.
   * @param {PIXI.Filter|null} filter
   */
  set detectionFilter(arg: any);
  /**
   * Translate the token's grid width into a pixel width based on the canvas size
   * @type {number}
   */
  get w(): number;
  /**
   * Translate the token's grid height into a pixel height based on the canvas size
   * @type {number}
   */
  get h(): number;
  /**
   * The Token's central position, adjusted in each direction by one or zero pixels to offset it relative to walls.
   * @type {Point}
   */
  getMovementAdjustedPoint(
    point: any,
    {
      offsetX,
      offsetY,
    }?: {
      offsetX: any;
      offsetY: any;
    }
  ): {
    x: any;
    y: any;
  };
  /**
   * The HTML source element for the primary Tile texture
   * @type {HTMLImageElement|HTMLVideoElement}
   */
  get sourceElement(): HTMLVideoElement | HTMLImageElement;
  /**
   * Does this Tile depict an animated video texture?
   * @type {boolean}
   */
  get isVideo(): boolean;
  /**
   * An indicator for whether or not this token is currently involved in the active combat encounter.
   * @type {boolean}
   */
  get inCombat(): boolean;
  /**
   * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
   * @type {Combatant|null}
   */
  get combatant(): Function | null;
  /**
   * An indicator for whether the Token is currently targeted by the active game User
   * @type {boolean}
   */
  get isTargeted(): boolean;
  /**
   * Return a reference to the detection modes array.
   * @type {[object]}
   */
  get detectionModes(): [object];
  /**
   * Determine whether the Token is visible to the calling user's perspective.
   * Hidden Tokens are only displayed to GM Users.
   * Non-hidden Tokens are always visible if Token Vision is not required.
   * Controlled tokens are always visible.
   * All Tokens are visible to a GM user if no Token is controlled.
   *
   * @see {CanvasVisibility#testVisibility}
   * @type {boolean}
   */
  get isVisible(): boolean;
  /**
   * The animation name used for Token movement
   * @type {string}
   */
  get animationName(): string;
  /**
   * Test whether the Token has sight (or blindness) at any radius
   * @type {boolean}
   */
  get hasSight(): boolean;
  /**
   * Does this Token actively emit light given its properties and the current darkness level of the Scene?
   * @type {boolean}
   */
  get emitsLight(): boolean;
  /**
   * Test whether the Token uses a limited angle of vision or light emission.
   * @type {boolean}
   */
  get hasLimitedSourceAngle(): boolean;
  /**
   * Translate the token's dim light distance in units into a radius in pixels.
   * @type {number}
   */
  get dimRadius(): number;
  /**
   * Translate the token's bright light distance in units into a radius in pixels.
   * @type {number}
   */
  get brightRadius(): number;
  /**
   * Translate the token's vision range in units into a radius in pixels.
   * @type {number}
   */
  get sightRange(): number;
  /**
   * Translate the token's maximum vision range that takes into account lights.
   * @type {number}
   */
  get optimalSightRange(): number;
  /**
   * Update the light and vision source objects associated with this Token.
   * @param {object} [options={}]       Options which configure how perception sources are updated
   * @param {boolean} [options.defer=false]         Defer refreshing the SightLayer to manually call that refresh later
   * @param {boolean} [options.deleted=false]       Indicate that this light source has been deleted
   */
  updateSource({
    defer,
    deleted,
  }?:
    | {
        defer?: boolean | undefined;
        deleted?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Update an emitted light source associated with this Token.
   * @param {object} [options={}]
   * @param {boolean} [options.defer]      Defer refreshing the LightingLayer to manually call that refresh later.
   * @param {boolean} [options.deleted]    Indicate that this light source has been deleted.
   */
  updateLightSource({
    defer,
    deleted,
  }?:
    | {
        defer?: boolean | undefined;
        deleted?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Update the VisionSource instance associated with this Token.
   * @param {object} [options]        Options which affect how the vision source is updated
   * @param {boolean} [options.defer]     Defer refreshing the LightingLayer to manually call that refresh later.
   * @param {boolean} [options.deleted]   Indicate that this vision source has been deleted.
   */
  updateVisionSource({
    defer,
    deleted,
  }?:
    | {
        defer?: boolean | undefined;
        deleted?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Test whether this Token is a viable vision source for the current User
   * @returns {boolean}
   * @private
   */
  private _isVisionSource;
  /** @override */
  override render(renderer: any): void;
  /** @inheritdoc */
  _destroy(options: any): void;
  texture: any;
  visible: any;
  bars: any;
  tooltip: any;
  effects: any;
  target: any;
  nameplate: any;
  hitArea: PIXI.Rectangle | undefined;
  buttonMode: boolean | undefined;
  /**
   * Apply initial sanitizations to the provided input data to ensure that a Token has valid required attributes.
   * Constrain the Token position to remain within the Canvas rectangle.
   * @private
   */
  private _cleanData;
  /**
   * Draw resource bars for the Token
   * @private
   */
  private _drawAttributeBars;
  /** @override */
  override _refresh(options: any): void;
  /**
   * Refresh display of elements of the Token HUD.
   * @param {object} options          Which components of the HUD to refresh?
   * @param {boolean} [options.bars]        Re-draw bars?
   * @param {boolean} [options.border]      Re-draw the border?
   * @param {boolean} [options.effects]     Re-draw effect icons?
   * @param {boolean} [options.elevation]   Re-draw elevation text
   * @param {boolean} [options.nameplate]   Re-draw the nameplate?
   */
  refreshHUD({
    bars,
    border,
    effects,
    elevation,
    nameplate,
  }?: {
    bars?: boolean | undefined;
    border?: boolean | undefined;
    effects?: boolean | undefined;
    elevation?: boolean | undefined;
    nameplate?: boolean | undefined;
  }): void;
  /**
   * Draw the Token border, taking into consideration the grid type and border color
   * @protected
   */
  protected _refreshBorder(): void;
  /**
   * Get the hex color that should be used to render the Token border
   * @param {object} [options]
   * @param {boolean} [options.hover]  Return a border color for this hover state, otherwise use the token's current
   *                                   state.
   * @returns {number|null}            The hex color used to depict the border color
   * @private
   */
  private _getBorderColor;
  /**
   * @typedef {object} ReticuleOptions
   * @property {number} [margin=0]        The amount of margin between the targeting arrows and the token's bounding
   *                                      box, expressed as a fraction of an arrow's size.
   * @property {number} [alpha=1]         The alpha value of the arrows.
   * @property {number} [size=0.15]       The size of the arrows as a proportion of grid size.
   * @property {number} [color=0xFF6400]  The color of the arrows.
   * @property {object} [border]          The arrows' border style configuration.
   * @property {number} [border.color=0]  The border color.
   * @property {number} [border.width=2]  The border width.
   */
  /**
   * Refresh the target indicators for the Token.
   * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.
   * @param {ReticuleOptions} [reticule]  Additional parameters to configure how the targeting reticule is drawn.
   * @protected
   */
  protected _refreshTarget(
    reticule?:
      | {
          /**
           * The amount of margin between the targeting arrows and the token's bounding
           *         box, expressed as a fraction of an arrow's size.
           */
          margin?: number | undefined;
          /**
           * The alpha value of the arrows.
           */
          alpha?: number | undefined;
          /**
           * The size of the arrows as a proportion of grid size.
           */
          size?: number | undefined;
          /**
           * The color of the arrows.
           */
          color?: number | undefined;
          /**
           * The arrows' border style configuration.
           */
          border?:
            | {
                /**
                 * The border color.
                 */
                color?: number | undefined;
                /**
                 * The border width.
                 */
                width?: number | undefined;
              }
            | undefined;
        }
      | undefined
  ): void;
  /**
   * Draw the targeting arrows around this token.
   * @param {ReticuleOptions} [reticule]  Additional parameters to configure how the targeting reticule is drawn.
   * @protected
   */
  protected _drawTarget({
    margin: m,
    alpha,
    size,
    color,
    border: { width, color: lineColor },
  }?:
    | {
        /**
         * The amount of margin between the targeting arrows and the token's bounding
         *         box, expressed as a fraction of an arrow's size.
         */
        margin?: number | undefined;
        /**
         * The alpha value of the arrows.
         */
        alpha?: number | undefined;
        /**
         * The size of the arrows as a proportion of grid size.
         */
        size?: number | undefined;
        /**
         * The color of the arrows.
         */
        color?: number | undefined;
        /**
         * The arrows' border style configuration.
         */
        border?:
          | {
              /**
               * The border color.
               */
              color?: number | undefined;
              /**
               * The border width.
               */
              width?: number | undefined;
            }
          | undefined;
      }
    | undefined): void;
  /**
   * Refresh the display of Token attribute bars, rendering its latest resource data
   * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.
   */
  drawBars(): false | undefined;
  /**
   * Draw a single resource bar, given provided data
   * @param {number} number       The Bar number
   * @param {PIXI.Graphics} bar   The Bar container
   * @param {Object} data         Resource data for this bar
   * @protected
   */
  protected _drawBar(number: number, bar: any, data: Object): void;
  /**
   * Draw the token's nameplate as a text object
   * @returns {PIXI.Text}  The Text object for the Token nameplate
   */
  _drawNameplate(): PIXI.Text;
  /**
   * Draw a text tooltip for the token which can be used to display Elevation or a resource value
   * @returns {PreciseText}     The text object used to render the tooltip
   * @private
   */
  private _drawTooltip;
  /**
   * Return the text which should be displayed in a token's tooltip field
   * @returns {string}
   * @private
   */
  private _getTooltipText;
  _getTextStyle(): any;
  /**
   * Draw the active effects and overlay effect icons which are present upon the Token
   */
  drawEffects(): Promise<void>;
  /**
   * Refresh the display of status effects, adjusting their position for the token width and height.
   * @protected
   */
  protected _refreshEffects(): void;
  /**
   * Draw a status effect icon
   * @param {string} src
   * @param {number|null} tint
   * @returns {Promise<PIXI.Sprite|undefined>}
   * @protected
   */
  protected _drawEffect(
    src: string,
    tint: number | null
  ): Promise<PIXI.Sprite | undefined>;
  /**
   * Draw the overlay effect icon
   * @param {string} src
   * @param {number|null} tint
   * @returns {Promise<PIXI.Sprite>}
   * @protected
   */
  protected _drawOverlay(
    src: string,
    tint: number | null
  ): Promise<PIXI.Sprite>;
  /**
   * Helper method to determine whether a token attribute is viewable under a certain mode
   * @param {number} mode   The mode from CONST.TOKEN_DISPLAY_MODES
   * @returns {boolean}      Is the attribute viewable?
   * @private
   */
  private _canViewMode;
  /**
   * Get the display attributes of the TokenDocument which are used to inform refresh.
   * @returns {object}
   */
  getDisplayAttributes(): object;
  /**
   * Animate changes to the appearance of the Token.
   * Animations are performed over differences between the TokenDocument and the current Token and TokenMesh appearance.
   * @param {object} updateData                     A record of the differential data which changed, for reference only
   * @param {CanvasAnimationOptions} [options]      Options which configure the animation behavior
   * @param {number} [options.movementSpeed]        A desired token movement speed in grid spaces per second
   * @param {TokenAttributesSnapshot} [options.a0]  The animation starting attributes if different from those cached.
   * @returns {Promise<void>}                       A promise which resolves once the animation is complete
   */
  animate(
    updateData: object,
    {
      name,
      duration,
      easing,
      movementSpeed,
      ontick,
      a0,
    }?: CanvasAnimationOptions | undefined
  ): Promise<void>;
  /**
   * Terminate animation of this particular Token.
   */
  stopAnimation(): void;
  /**
   * Check for collision when attempting a move to a new position
   * @param {Point} destination           The central destination point of the attempted movement
   * @param {object} [options={}]         Additional options forwarded to WallsLayer#checkCollision
   * @returns {boolean|object[]|object}   The result of the WallsLayer#checkCollision test
   */
  checkCollision(
    destination: Point,
    { origin, type, mode }?: object | undefined
  ): boolean | object[] | object;
  /**
   * Get the center-point coordinate for a given grid position
   * @param {number} x    The grid x-coordinate that represents the top-left of the Token
   * @param {number} y    The grid y-coordinate that represents the top-left of the Token
   * @returns {Object}     The coordinate pair which represents the Token's center at position (x, y)
   */
  getCenter(x: number, y: number): Object;
  /**
   * Update the tracked position and movement velocity of the Token
   * @param {object} [options]              Options provided as part of a Token update
   * @param {boolean} [options.recenter]    Automatically re-center the canvas if the Token has moved off-screen
   */
  updatePosition({
    recenter,
  }?:
    | {
        recenter?: boolean | undefined;
      }
    | undefined): void;
  /**
   * Set this Token as an active target for the current game User.
   * Note: If the context is set with groupSelection:true, you need to manually broadcast the activity for other users.
   * @param {boolean} targeted                        Is the Token now targeted?
   * @param {object} [context={}]                     Additional context options
   * @param {User|null} [context.user=null]           Assign the token as a target for a specific User
   * @param {boolean} [context.releaseOthers=true]    Release other active targets for the same player?
   * @param {boolean} [context.groupSelection=false]  Is this target being set as part of a group selection workflow?
   */
  setTarget(
    targeted?: boolean,
    {
      user,
      releaseOthers,
      groupSelection,
    }?:
      | {
          user?: User | null | undefined;
          releaseOthers?: boolean | undefined;
          groupSelection?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Add or remove the currently controlled Tokens from the active combat encounter
   * @param {Combat} [combat]    A specific combat encounter to which this Token should be added
   * @returns {Promise<Token>} The Token which initiated the toggle
   */
  toggleCombat(combat?: Combat | undefined): Promise<Function>;
  /**
   * Toggle an active effect by its texture path.
   * Copy the existing Array in order to ensure the update method detects the data as changed.
   *
   * @param {string|object} effect  The texture file-path of the effect icon to toggle on the Token.
   * @param {object} [options]      Additional optional arguments which configure how the effect is handled.
   * @param {boolean} [options.active]    Force a certain active state for the effect
   * @param {boolean} [options.overlay]   Whether to set the effect as the overlay effect?
   * @returns {Promise<boolean>}   Was the texture applied (true) or removed (false)
   */
  toggleEffect(
    effect: string | object,
    {
      active,
      overlay,
    }?:
      | {
          active?: boolean | undefined;
          overlay?: boolean | undefined;
        }
      | undefined
  ): Promise<boolean>;
  /**
   * A helper function to toggle the overlay status icon on the Token
   * @param {string} texture
   * @param {object} root0
   * @param {boolean} root0.active
   * @returns {Promise<*>}
   * @private
   */
  private _toggleOverlayEffect;
  /**
   * Toggle the visibility state of any Tokens in the currently selected set
   * @returns {Promise<TokenDocument[]>}     A Promise which resolves to the updated Token documents
   */
  toggleVisibility(): Promise<TokenDocument[]>;
  /**
   * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.
   * This function adds additional padding to the light radius equal to half the token width.
   * This causes light to be measured from the outer token edge, rather than from the center-point.
   * @param {number} units  The radius in grid units
   * @returns {number}       The radius in canvas units
   */
  getLightRadius(units: number): number;
  /** @override */
  override _getShiftedPosition(
    dx: any,
    dy: any
  ): {
    x: any;
    y: any;
  };
  /** @override */
  override _onCreate(options: any, userId: any): void;
  /** @override */
  override _onUpdate(data: any, options: any, userId: any): void;
  /**
   * Control updates to the appearance of the Token and its linked TokenMesh when a data update occurs.
   * @returns {Promise<void>}
   * @private
   */
  private _onUpdateAppearance;
  /** @override */
  override _onDelete(options: any, userId: any): void;
  /**
   * Handle changes to Token behavior when a significant status effect is applied
   * @param {string} statusId       The status effect ID being applied, from CONFIG.specialStatusEffects
   * @param {boolean} active        Is the special status effect now active?
   * @internal
   */
  _onApplyStatusEffect(statusId: string, active: boolean): void;
  /** @inheritdoc */
  _onControl({
    releaseOthers,
    pan,
  }?: {
    releaseOthers?: boolean | undefined;
    pan?: boolean | undefined;
  }): void;
  /** @inheritdoc */
  _onRelease(options: any): void;
  /** @override */
  override _canControl(user: any, event: any): any;
  /** @override */
  override _canHUD(user: any, event: any): any;
  /** @override */
  override _canConfigure(user: any, event: any): boolean;
  /** @override */
  override _canHover(user: any, event: any): boolean;
  /** @override */
  override _canView(user: any, event: any): any;
  /** @override */
  override _canDrag(user: any, event: any): any;
  /** @override */
  override _onHoverIn(event: any, options: any): false | undefined;
  /** @override */
  override _onHoverOut(event: any): false | undefined;
  /** @override */
  override _onClickLeft(event: any): void;
  /** @override */
  override _onClickLeft2(event: any): void;
  /** @override */
  override _onClickRight2(event: any): void;
  /** @override */
  override _onDragLeftDrop(event: any): any;
  /** @override */
  override _onDragLeftMove(event: any): void;
  /** @inheritdoc */
  _onDragLeftCancel(event: any): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get hasLimitedVisionAngle(): boolean;
  /**
   * @deprecated since v10
   * @ignore
   */
  getSightOrigin(): {
    x: any;
    y: any;
  };
  /**
   * @deprecated since v10
   * @ignore
   */
  get icon(): TokenMesh;
  /**
   * @deprecated since v10
   * @ignore
   */
  setPosition(
    x: any,
    y: any,
    {
      animate,
      movementSpeed,
      recenter,
    }?: {
      animate?: boolean | undefined;
      movementSpeed: any;
      recenter?: boolean | undefined;
    }
  ): Promise<void>;
  /**
   * @deprecated since v10
   * @ignore
   */
  animateMovement(
    ray: any,
    {
      movementSpeed,
    }?: {
      movementSpeed?: number | undefined;
    }
  ): Promise<void>;
  #private;
}
/**
 * A "secret" global to help debug attributes of the currently controlled Token.
 * This is only for debugging, and may be removed in the future, so it's not safe to use.
 * @type {Token}
 * @ignore
 */
declare let _token: Function;
type TokenPosition = Point;
type ReticuleOptions = {
  /**
   * The amount of margin between the targeting arrows and the token's bounding
   *         box, expressed as a fraction of an arrow's size.
   */
  margin?: number | undefined;
  /**
   * The alpha value of the arrows.
   */
  alpha?: number | undefined;
  /**
   * The size of the arrows as a proportion of grid size.
   */
  size?: number | undefined;
  /**
   * The color of the arrows.
   */
  color?: number | undefined;
  /**
   * The arrows' border style configuration.
   */
  border?:
    | {
        /**
         * The border color.
         */
        color?: number | undefined;
        /**
         * The border width.
         */
        width?: number | undefined;
      }
    | undefined;
};
type TokenAttributesSnapshot = {
  x: number;
  y: number;
  width: number;
  height: number;
  alpha: number;
  rotation: number;
  texture: TextureData;
};
/**
 * A Wall is an implementation of PlaceableObject which represents a physical or visual barrier within the Scene.
 * Walls are used to restrict Token movement or visibility as well as to define the areas of effect for ambient lights
 * and sounds.
 * @category - Canvas
 * @see {@link WallDocument}
 * @see {@link WallsLayer}
 */
declare class Wall extends PlaceableObject {
  /**
   * An reference the Door Control icon associated with this Wall, if any
   * @type {DoorControl|null}
   * @private
   */
  private doorControl;
  /**
   * A reference to an overhead Tile that is a roof, interior to which this wall is contained
   * @type {Tile}
   */
  roof: Function;
  /**
   * A set which tracks other Wall instances that this Wall intersects with (excluding shared endpoints)
   * @type {Map<Wall,LineIntersection>}
   */
  intersectsWith: Map<Function, LineIntersection>;
  /**
   * A convenience reference to the coordinates Array for the Wall endpoints, [x0,y0,x1,y1].
   * @type {number[]}
   */
  get coords(): number[];
  /**
   * The endpoints of the wall expressed as {@link PolygonVertex} instances.
   * @type {{a: PolygonVertex, b: PolygonVertex}}
   */
  get vertices(): {
    a: PolygonVertex;
    b: PolygonVertex;
  };
  /**
   * The initial endpoint of the Wall.
   * @type {PolygonVertex}
   */
  get A(): PolygonVertex;
  /**
   * The second endpoint of the Wall.
   * @type {PolygonVertex}
   */
  get B(): PolygonVertex;
  /**
   * A set of vertex sort keys which identify this Wall's endpoints.
   * @type {Set<number>}
   */
  get wallKeys(): Set<number>;
  /** @inheritdoc */
  get bounds(): PIXI.Rectangle;
  /**
   * A boolean for whether this wall contains a door
   * @type {boolean}
   */
  get isDoor(): boolean;
  /**
   * A boolean for whether the wall contains an open door
   * @returns {boolean}
   */
  get isOpen(): boolean;
  /**
   * Is this Wall interior to a non-occluded roof Tile?
   * @type {boolean}
   */
  get hasActiveRoof(): boolean;
  /**
   * Return the coordinates [x,y] at the midpoint of the wall segment
   * @returns {Array<number>}
   */
  get midpoint(): number[];
  /**
   * Get the direction of effect for a directional Wall
   * @type {number|null}
   */
  get direction(): number | null;
  /**
   * This helper converts the wall segment to a Ray
   * @returns {Ray}    The wall in Ray representation
   */
  toRay(): Ray;
  directionIcon: any;
  line: any;
  endpoints: any;
  /**
   * Draw a control icon that is used to manipulate the door's open/closed state
   * @returns {DoorControl}
   */
  createDoorControl(): DoorControl;
  /**
   * Clear the door control if it exists.
   */
  clearDoorControl(): void;
  /**
   * Determine the orientation of this wall with respect to a reference point
   * @param {Point} point       Some reference point, relative to which orientation is determined
   * @returns {number}          An orientation in CONST.WALL_DIRECTIONS which indicates whether the Point is left,
   *                            right, or collinear (both) with the Wall
   */
  orientPoint(point: Point): number;
  /**
   * Draw a directional prompt icon for one-way walls to illustrate their direction of effect.
   * @returns {PIXI.Sprite|null}   The drawn icon
   * @private
   */
  private _drawDirection;
  /** @override */
  override _refresh(options: any): void;
  /**
   * Compute an approximate Polygon which encloses the line segment providing a specific hitArea for the line
   * @param {number[]} coords     The original wall coordinates
   * @param {number} pad          The amount of padding to apply
   * @returns {PIXI.Polygon}      A constructed Polygon for the line
   * @private
   */
  private _getWallHitPolygon;
  /**
   * Given the properties of the wall - decide upon a color to render the wall for display on the WallsLayer
   * @private
   */
  private _getWallColor;
  /** @inheritdoc */
  _onControl({ chain }?: { chain?: boolean | undefined }): void;
  /** @inheritdoc */
  _onRelease(options: any): void;
  /** @override */
  override _destroy(options: any): void;
  /**
   * Test whether the Wall direction lies between two provided angles
   * This test is used for collision and vision checks against one-directional walls
   * @param {number} lower    The lower-bound limiting angle in radians
   * @param {number} upper    The upper-bound limiting angle in radians
   * @returns {boolean}
   */
  isDirectionBetweenAngles(lower: number, upper: number): boolean;
  /**
   * A simple test for whether a Ray can intersect a directional wall
   * @param {Ray} ray     The ray to test
   * @returns {boolean}    Can an intersection occur?
   */
  canRayIntersect(ray: Ray): boolean;
  /**
   * Get an Array of Wall objects which are linked by a common coordinate
   * @returns {Object}    An object reporting ids and endpoints of the linked segments
   */
  getLinkedSegments(): Object;
  /**
   * Determine whether this wall is beneath a roof tile, and is considered "interior", or not.
   * Tiles which are hidden do not count as roofs for the purposes of defining interior walls.
   */
  identifyInteriorState(): void;
  /**
   * Update any intersections with this wall.
   */
  updateIntersections(): void;
  /**
   * Record the intersection points between this wall and another, if any.
   * @param {Wall} other  The other wall.
   */
  _identifyIntersectionsWith(other: Function): void;
  /**
   * Remove this wall's intersections.
   * @private
   */
  private _removeIntersections;
  /** @inheritdoc */
  _onCreate(...args: any[]): void;
  /** @inheritdoc */
  _onUpdate(data: any, ...args: any[]): void;
  /** @inheritdoc */
  _onDelete(...args: any[]): void;
  /**
   * Callback actions when a wall that contains a door is moved or its state is changed
   * @param {boolean} doorChange   Update vision and sound restrictions
   * @private
   */
  private _onModifyWall;
  /** @inheritdoc */
  _canControl(user: any, event: any): boolean;
  /** @inheritdoc */
  _onHoverIn(event: any, options: any): false | undefined;
  /** @inheritdoc */
  _onHoverOut(event: any): false | undefined;
  /**
   * Handle mouse-hover events on the line segment itself, pulling the Wall to the front of the container stack
   * @param {object} event
   * @private
   */
  private _onMouseOverLine;
  /** @inheritdoc */
  _onClickLeft(event: any): boolean | undefined;
  /** @inheritdoc */
  _onClickLeft2(event: any): void;
  /** @inheritdoc */
  _onClickRight2(event: any): void;
  /** @inheritdoc */
  _onDragLeftStart(event: any): any;
  /** @inheritdoc */
  _onDragLeftMove(event: any): void;
  /** @inheritdoc */
  _onDragLeftDrop(event: any): Promise<any>;
  #private;
}
/**
 * A helper class used by the Sight Layer to represent a source of vision or illumination.
 * @param {PlaceableObject} object      The object responsible for the PointSource
 * @abstract
 */
declare class PointSource {
  /**
   * The type of source represented by this data structure.
   * Each subclass must implement this attribute.
   * @type {string}
   */
  static sourceType: string;
  /**
   * The offset in pixels applied to create soft edges.
   * @type {number}
   */
  static EDGE_OFFSET: number;
  constructor(object: any);
  /**
   * The PlaceableObject which is the origin of this PointSource.
   * @type {PlaceableObject}
   */
  object: PlaceableObject;
  /**
   * A flag for whether this source is currently rendered or not.
   * @type {boolean}
   */
  active: boolean;
  /**
   * @typedef {Object} PointSourceAnimationConfiguration
   * @property {string} [label]                                   The human-readable (localized) label for the animation
   * @property {Function} [animation]                             The animation function that runs every frame
   * @property {AdaptiveIlluminationShader} [illuminationShader]  A custom illumination shader used by this animation
   * @property {AdaptiveColorationShader} [colorationShader]      A custom coloration shader used by this animation
   * @property {AdaptiveBackgroundShader} [backgroundShader]      A custom background shader used by this animation
   * @property {number} [seed]                                    The animation seed
   * @property {number} [time]                                    The animation time
   */
  /**
   * The animation configuration applied to this source
   * @type {PointSourceAnimationConfiguration}
   */
  animation: {
    /**
     * The human-readable (localized) label for the animation
     */
    label?: string | undefined;
    /**
     * The animation function that runs every frame
     */
    animation?: Function | undefined;
    /**
     * A custom illumination shader used by this animation
     */
    illuminationShader?: AdaptiveIlluminationShader | undefined;
    /**
     * A custom coloration shader used by this animation
     */
    colorationShader?: AdaptiveColorationShader | undefined;
    /**
     * A custom background shader used by this animation
     */
    backgroundShader?: AdaptiveBackgroundShader | undefined;
    /**
     * The animation seed
     */
    seed?: number | undefined;
    /**
     * The animation time
     */
    time?: number | undefined;
  };
  /**
   * The object of data which configures how this source is rendered
   * @type {object}
   */
  data: object;
  /**
   * The maximum radius of emission for this source
   * @type {number}
   */
  radius: number;
  /**
   * The restricted line-of-sight polygon that is generated by the origin and radius of this source.
   * @type {PointSourcePolygon}
   */
  los: PointSourcePolygon;
  /**
   * PIXI Geometry generated to draw meshes.
   * @type {PIXI.Geometry|null}
   * @private
   */
  private _sourceGeometry;
  /**
   * A Graphics object with pre-computed geometry used for masking based on line-of-sight.
   * @type {PIXI.Graphics}
   */
  losMask: any;
  /**
   * Additional information which controls whether certain behaviors of the source must be enforced
   * @type {Object<string,boolean|number>}
   * @protected
   */
  protected _flags: {
    [x: string]: boolean | number;
  };
  /**
   * To track meshes initialization
   * @type {boolean}
   * @protected
   */
  protected _meshesInit: boolean;
  /**
   * The x-coordinate of the point source origin.
   * @type {number}
   */
  get x(): number;
  /**
   * The y-coordinate of the point source origin.
   * @type {number}
   */
  get y(): number;
  /**
   * The type of source represented by this data structure.
   * @type {string}
   */
  get sourceType(): string;
  /**
   * The elevation of the object bound to this base source, if any.
   * Returns the canvas primary background elevation otherwise.
   * @type {number}
   */
  get elevation(): number;
  /**
   * If the source is animated or not.
   * @type {boolean}
   */
  get isAnimated(): boolean;
  /**
   * A point is contained with the area of the source if it is within both the FOV circle and the LOS polygon.
   * @param {Point} point   The point to test
   * @returns {boolean}     Is the point contained
   */
  containsPoint(point: Point): boolean;
  /**
   * Steps that must be performed when the base source is destroyed.
   */
  destroy(): void;
  /** @ignore */
  initialize(data?: {}): void;
  /**
   * Refresh the state and uniforms of the BaseSource
   * @abstract
   */
  refreshSource(): void;
  /**
   * Create or update the source geometry with a polygon shape
   * Triangulate the form and create buffers
   * @param {PIXI.Polygon} polygon   The pixi polygon
   * @protected
   */
  protected _updateLosGeometry(polygon: PIXI.Polygon): void;
  /**
   * Configure the parameters of the polygon that is generated for this source.
   * @returns {PointSourcePolygonConfig}
   * @abstract
   * @protected
   */
  protected _getPolygonConfiguration(): PointSourcePolygonConfig;
  /**
   * Create the LOS polygon for this Light Source instance using provided parameters.
   * @returns {PointSourcePolygon|PIXI.Polygon}
   * @abstract
   * @protected
   */
  protected _createPolygon(): PointSourcePolygon | PIXI.Polygon;
  /**
   * Create or update the source geometry and create meshes if necessary
   * @param {PIXI.Polygon} polygon    A pixi polygon
   * @protected
   */
  protected _initializeMeshes(polygon: PIXI.Polygon): void;
  /**
   * Create a new Mesh for this source using a provided shader class
   * @param {Function} shaderCls  The subclass of AdaptiveLightingShader being used for this Mesh
   * @returns {PIXI.Mesh}         The created Mesh
   * @protected
   */
  protected _createMesh(shaderCls: Function): PIXI.Mesh;
  /**
   * Create all meshes needed with this PointSource
   * @abstract
   */
  _createMeshes(): void;
  /**
   * Update the position and size of the mesh each time it is drawn.
   * @param {PIXI.Mesh} mesh      The Mesh being updated
   * @returns {PIXI.Mesh}         The updated Mesh
   * @protected
   */
  protected _updateMesh(mesh: PIXI.Mesh): PIXI.Mesh;
  /**
   * Animate the BaseSource, if an animation is enabled and if it currently has rendered containers.
   * @param {number} dt         Delta time.
   */
  animate(dt: number): any;
  /**
   * @deprecated since v10, will be removed in v11.
   * @ignore
   */
  getPowerOf2Size(): any;
  /**
   * @deprecated since v10
   * @ignore
   */
  get limited(): boolean;
}
type PointSourceAnimationConfiguration = {
  /**
   * The human-readable (localized) label for the animation
   */
  label?: string | undefined;
  /**
   * The animation function that runs every frame
   */
  animation?: Function | undefined;
  /**
   * A custom illumination shader used by this animation
   */
  illuminationShader?: AdaptiveIlluminationShader | undefined;
  /**
   * A custom coloration shader used by this animation
   */
  colorationShader?: AdaptiveColorationShader | undefined;
  /**
   * A custom background shader used by this animation
   */
  backgroundShader?: AdaptiveBackgroundShader | undefined;
  /**
   * The animation seed
   */
  seed?: number | undefined;
  /**
   * The animation time
   */
  time?: number | undefined;
};
/**
 * @typedef {Object}                      LightSourceData
 * @see {@link foundry.data.LightData}
 * @property {number} x                   The x-coordinate of the source location
 * @property {number} y                   The y-coordinate of the source location
 * @property {number} z                   An optional z-index sorting for the source
 * @property {number} rotation            The angle of rotation for this point source
 * @property {number} alpha               An opacity for the emitted light, if any
 * @property {object} animation           An animation configuration for the source
 * @property {number} angle               The angle of emission for this point source
 * @property {number} bright              The allowed radius of bright vision or illumination
 * @property {number} color               A tint color for the emitted light, if any
 * @property {number} coloration          The coloration technique applied in the shader
 * @property {number} contrast            The amount of contrast this light applies to the background texture
 * @property {object} darkness            A darkness range (min and max) for which the source should be active
 * @property {number} dim                 The allowed radius of dim vision or illumination
 * @property {number} attenuation         Strength of the attenuation between bright, dim, and dark
 * @property {number} luminosity          The luminosity applied in the shader
 * @property {number} saturation          The amount of color saturation this light applies to the background texture
 * @property {number} shadows             The depth of shadows this light applies to the background texture
 * @property {boolean} walls              Whether or not the source is constrained by walls
 * @property {boolean} vision             Whether or not this source provides a source of vision
 * @property {number} seed                An integer seed to synchronize (or de-synchronize) animations
 */
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of light sources.
 * @extends {PointSource}
 * @param {AmbientLight|Token} object     The light-emitting object that generates this light source
 */
declare class LightSource extends PointSource {
  /**
   * Keys in the LightSourceData structure which, when modified, change the appearance of the light
   * @type {string[]}
   * @private
   */
  private static _appearanceKeys;
  /**
   * The object type for a Light Source.
   * This is a Scene in the case of a global light source
   * This is an AmbientLight placeable object when the source is provided by an AmbientLightDocument
   * This is a Token placeable object when the source is provided by a TokenDocument
   * @type {Scene|AmbientLight|Token}
   */
  object: Function | Scene;
  /**
   * The light or darkness container for this source
   * @type {PIXI.Mesh|null}
   */
  background: PIXI.Mesh | null;
  /**
   * The light or darkness container for this source
   * @type {PIXI.Mesh|null}
   */
  illumination: PIXI.Mesh | null;
  /**
   * This visible color container for this source
   * @type {PIXI.Mesh|null}
   */
  coloration: PIXI.Mesh | null;
  /**
   * The computed polygon which expresses the area of effect of this light source
   * @type {PointSourcePolygon|PIXI.Polygon}
   */
  los: PointSourcePolygon | PIXI.Polygon;
  /**
   * The object of data which configures how the source is rendered
   * @type {LightSourceData}
   */
  data: LightSourceData;
  /**
   * Internal flag for whether this is a darkness source
   * @type {boolean}
   */
  isDarkness: boolean;
  /**
   * To know if a light source is a preview or not. False by default.
   * @type {boolean}
   */
  preview: boolean;
  /**
   * The ratio of dim:bright as part of the source radius
   * @type {number}
   */
  ratio: number;
  /**
   * Track which uniforms need to be reset
   * @type {{background: boolean, illumination: boolean, coloration: boolean}}
   * @private
   */
  private _resetUniforms;
  /**
   * To track if a source is temporarily shutdown to avoid glitches
   * @type {{illumination: boolean}}
   * @private
   */
  private _shutdown;
  /**
   * To know if a light source is completely disabled.
   * @type {boolean}
   */
  get disabled(): boolean;
  /**
   * Initialize the source with provided object data.
   * @param {object} data             Initial data provided to the point source.
   * @returns {LightSource}           A reference to the initialized source.
   */
  initialize(data?: object): LightSource;
  animation: any;
  colorRGB: any;
  /** @override */
  override _getPolygonConfiguration(): {
    type: string;
    angle: any;
    density: number;
    radius: number;
    rotation: any;
    source: LightSource;
  };
  /**
   * Initialize the PointSource with new input data
   * @param {object} data             Initial data provided to the light source
   * @returns {object}                The changes compared to the prior data
   * @protected
   */
  protected _initializeData(data: object): object;
  /**
   * Record internal status flags which modify how the light source is rendered
   * @protected
   */
  protected _initializeFlags(): void;
  /**
   * Initialize the shaders used for this source, swapping to a different shader if the animation has changed.
   * @private
   */
  private _initializeShaders;
  /**
   * Initialize the blend mode and vertical sorting of this source relative to others in the container.
   * @private
   */
  private _initializeBlending;
  /**
   * Update the visible state of the component channels of this LightSource.
   * @returns {boolean}     Is any channel of this light source active?
   */
  updateVisibility(): boolean;
  /**
   * Test whether this light source is currently suppressed?
   * @returns {boolean}
   * @private
   */
  private _isSuppressed;
  /**
   * Render the containers used to represent this light source within the LightingLayer
   * @returns {{background: PIXI.Mesh, light: PIXI.Mesh, color: PIXI.Mesh}}
   */
  drawMeshes(): {
    background: PIXI.Mesh;
    light: PIXI.Mesh;
    color: PIXI.Mesh;
  };
  /**
   * Create a Mesh for the background component of this source which will be added to CanvasBackgroundEffects.
   * @returns {PIXI.Mesh|null}          The background mesh for this LightSource, or null
   */
  drawBackground(): PIXI.Mesh | null;
  /**
   * Create a Mesh for the illumination component of this source which will be added to CanvasIlluminationEffects.
   * @returns {PIXI.Mesh|null}          The illumination mesh for this LightSource, or null
   */
  drawLight(): PIXI.Mesh | null;
  /**
   * Create a Mesh for the coloration component of this source which will be added to CanvasColorationEffects.
   * @returns {PIXI.Mesh|null}          The coloration mesh for this LightSource, or null
   */
  drawColor(): PIXI.Mesh | null;
  /**
   * Update all layer uniforms.
   * @protected
   */
  protected _updateUniforms(): void;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateColorationUniforms;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateIlluminationUniforms;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateBackgroundUniforms;
  /**
   * Update shader uniforms shared by all shader types
   * @param {AdaptiveLightingShader} shader        The shader being updated
   * @private
   */
  private _updateCommonUniforms;
  /**
   * Map luminosity value to exposure value
   * luminosity[-1  , 0  [ => Darkness => map to exposure ]   0, 1]
   * luminosity[ 0  , 0.5[ => Light    => map to exposure [-0.5, 0[
   * luminosity[ 0.5, 1  ] => Light    => map to exposure [   0, 1]
   * @param {number} lum        The luminosity value
   * @returns {number}           The exposure value
   * @private
   */
  private _mapLuminosity;
  /**
   * An animation with flickering ratio and light intensity
   * @param {number} dt                       Delta time
   * @param {object} [options={}]             Additional options which modify the flame animation
   * @param {number} [options.speed=5]        The animation speed, from 1 to 10
   * @param {number} [options.intensity=5]    The animation intensity, from 1 to 10
   * @param {boolean} [options.reverse=false] Reverse the animation direction
   */
  animateTorch(
    dt: number,
    {
      speed,
      intensity,
      reverse,
    }?:
      | {
          speed?: number | undefined;
          intensity?: number | undefined;
          reverse?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * An animation with flickering ratio and light intensity
   * @param {number} dt                                 Delta time
   * @param {object} [options={}]                       Additional options which modify the flame animation
   * @param {number} [options.speed=5]                  The animation speed, from 1 to 10
   * @param {number} [options.intensity=5]              The animation intensity, from 1 to 10
   * @param {number} [options.amplification=1]          Noise amplification (>1) or dampening (<1)
   * @param {boolean} [options.reverse=false]           Reverse the animation direction
   */
  animateFlickering(
    dt: number,
    {
      speed,
      intensity,
      reverse,
      amplification,
    }?:
      | {
          speed?: number | undefined;
          intensity?: number | undefined;
          amplification?: number | undefined;
          reverse?: boolean | undefined;
        }
      | undefined
  ): void;
  _noise: SmoothNoise | undefined;
  /**
   * A basic "pulse" animation which expands and contracts.
   * @param {number} dt                           Delta time
   * @param {object} [options={}]                 Additional options which modify the pulse animation
   * @param {number} [options.speed=5]              The animation speed, from 1 to 10
   * @param {number} [options.intensity=5]          The animation intensity, from 1 to 10
   * @param {boolean} [options.reverse=false]       Reverse the animation direction
   */
  animatePulse(
    dt: number,
    {
      speed,
      intensity,
      reverse,
    }?:
      | {
          speed?: number | undefined;
          intensity?: number | undefined;
          reverse?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Emanate waves of light from the source origin point
   * @param {number} dt                         Delta time
   * @param {object} [options={}]               Additional options which modify the animation
   * @param {number} [options.speed=5]            The animation speed, from 1 to 10
   * @param {number} [options.intensity=5]        The animation intensity, from 1 to 10
   * @param {boolean} [options.reverse=false]     Reverse the animation direction
   */
  animateTime(
    dt: number,
    {
      speed,
      intensity,
      reverse,
    }?:
      | {
          speed?: number | undefined;
          intensity?: number | undefined;
          reverse?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Test whether this LightSource provides visibility to see a certain target object.
   * @param {object} config               The visibility test configuration
   * @param {CanvasVisibilityTest[]} config.tests  The sequence of tests to perform
   * @param {PlaceableObject} config.object        The target object being tested
   * @returns {boolean}                   Is the target object visible to this source?
   */
  testVisibility({
    tests,
    object,
  }?: {
    tests: {
      point: PIXI.Point;
      los: Map<VisionSource, boolean>;
    }[];
    object: PlaceableObject;
  }): boolean;
  /**
   * Can this LightSource theoretically detect a certain object based on its properties?
   * This check should not consider the relative positions of either object, only their state.
   * @param {PlaceableObject} target      The target object being tested
   * @returns {boolean}                   Can the target object theoretically be detected by this vision source?
   */
  _canDetectObject(target: PlaceableObject): boolean;
  #private;
}
/**
 * A specialized subclass of the LightSource which is used to render global light source linked to the scene.
 * @see LightSource
 * @extends {LightSource}
 * @param {Scene} object     The linked scene.
 */
declare class GlobalLightSource extends LightSource {
  /** @override */
  override _createPolygon(): any;
}
type LightSourceData = Object;
/**
 * A subclass of PointSource which is used when computing the polygonal area where movement is possible.
 * @param {Token} object                The Token object which is attempting to move.
 */
declare class MovementSource extends PointSource {}
/**
 * @typedef {Object}                      SoundSourceData
 * @property {number} x                   The x-coordinate of the source location
 * @property {number} y                   The y-coordinate of the source location
 * @property {number} radius              The radius of the sound effect
 * @property {boolean} walls              Whether or not the source is constrained by walls
 */
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of sound sources.
 * @extends {PointSource}
 * @param {AmbientSound} object            The AmbientSound object that generates this sound source
 */
declare class SoundSource extends PointSource {
  /**
   * The object of data which configures how the source is rendered
   * @type {SoundSourceData}
   */
  data: SoundSourceData;
  /**
   * Initialize the source with provided object data.
   * @param {object} data             Initial data provided to the point source
   * @returns {SoundSource}           A reference to the initialized source
   */
  initialize(data?: object): SoundSource;
  /** @override */
  override _getPolygonConfiguration(): {
    type: string;
    radius: number;
    density: number;
    source: SoundSource;
  };
  /**
   * Process new input data provided to the SoundSource.
   * @param {object} data             Initial data provided to the sound source
   * @private
   */
  private _initializeData;
}
type SoundSourceData = {
  /**
   * The x-coordinate of the source location
   */
  x: number;
  /**
   * The y-coordinate of the source location
   */
  y: number;
  /**
   * The radius of the sound effect
   */
  radius: number;
  /**
   * Whether or not the source is constrained by walls
   */
  walls: boolean;
};
/**
 * @typedef {Object}                      VisionSourceData
 * @property {number} x                   The x-coordinate of the source location
 * @property {number} y                   The y-coordinate of the source location
 * @property {number} z                   An optional z-index sorting for the source
 * @property {number} rotation            The angle of rotation for this point source
 * @property {number} angle               The angle of emission for this point source
 * @property {number} bright              The allowed radius of bright vision or illumination
 * @property {number} radius              The allowed radius of vision
 * @property {number} externalRadius      A secondary radius used for limited angles
 * @property {boolean} isPreview          Is this vision source a temporary preview?
 */
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of vision sources.
 * @extends {PointSource}
 * @param {Token} object                  The Token object that generates this vision source
 */
declare class VisionSource extends PointSource {
  /**
   * Keys in the VisionSourceData structure which, when modified, change the appearance of the source
   * @type {string[]}
   * @private
   */
  private static _appearanceKeys;
  /**
   * The current background mesh for this source
   * @type {PIXI.Mesh|null}
   */
  background: PIXI.Mesh | null;
  /**
   * The current vision illumination mesh for this source
   * @type {PIXI.Mesh|null}
   */
  illumination: PIXI.Mesh | null;
  /**
   * The current vision coloration mesh for this source
   * @type {PIXI.Mesh|null}
   */
  coloration: PIXI.Mesh | null;
  /**
   * The vision mode linked to this VisionSource
   * @type {VisionMode|null}
   */
  visionMode: VisionMode | null;
  /**
   * The object of data which configures how the source is rendered
   * @type {VisionSourceData}
   */
  data: VisionSourceData;
  /**
   * The constrained LOS polygon that is generated by the origin and radius of this source.
   * @type {PointSourcePolygon}
   */
  fov: PointSourcePolygon;
  /**
   * Track which uniforms need to be reset
   * @type {{background: boolean, illumination: boolean, coloration: boolean}}
   * @private
   */
  private _resetUniforms;
  /**
   * To track if a source is temporarily shutdown to avoid glitches
   * @type {{background: boolean, illumination: boolean, coloration: boolean}}
   * @private
   */
  private _shutdown;
  /**
   * Is this VisionSource a temporary preview which should not produce fog exploration?
   * @returns {boolean}
   */
  get isPreview(): boolean;
  /**
   * Initialize the source with provided object data.
   * @param {object} data             Initial data provided to the point source.
   * @returns {VisionSource}          A reference to the initialized source.
   */
  initialize(data?: object): VisionSource;
  colorRGB: any;
  /**
   * Responsible for assigning the Vision Mode and handling exceptions based on vision special status.
   * @protected
   */
  protected _initializeVisionMode(): void;
  /**
   * If this vision source background is rendered into the lighting container.
   * @returns {number}
   */
  get preferred(): number;
  /** @override */
  override _getPolygonConfiguration(): {
    source: VisionSource;
    type: string;
    angle: number;
    rotation: number;
    externalRadius: number;
  };
  /**
   * Create a restricted FOV polygon by limiting the radius of the unrestricted LOS polygon.
   * @returns {PointSourcePolygon}
   * @protected
   */
  protected _createRestrictedPolygon(): PointSourcePolygon;
  /**
   * Initialize the shaders used for this source, swapping to a different shader if the vision effect has changed.
   * @private
   */
  private _initializeShaders;
  /**
   * Initialize the blend mode and vertical sorting of this source relative to others in the container.
   * @private
   */
  private _initializeBlending;
  /**
   * Process new input data provided to the LightSource.
   * @param {object} data             Initial data provided to the vision source
   * @returns {object}                The changes compared to the prior data
   * @private
   */
  private _initializeData;
  /**
   * Render the containers used to represent this light source within the LightingLayer.
   * @returns {Object<PIXI.Mesh>}
   */
  drawMeshes(): any;
  /**
   * Draw the background mesh which provide special vision.
   * @returns {PIXI.Mesh|null}         The rendered light container.
   */
  drawBackground(): PIXI.Mesh | null;
  /**
   * Draw the illumination mesh which provide vision.
   * @returns {PIXI.Mesh|null}         The rendered light container.
   */
  drawVision(): PIXI.Mesh | null;
  /**
   * Draw and return a container used to depict the visible color tint of the light source on the LightingLayer
   * @returns {PIXI.Mesh|null}          An updated color container for the source
   */
  drawColor(): PIXI.Mesh | null;
  /**
   * Update all layer uniforms.
   * @protected
   */
  protected _updateUniforms(): void;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateColorationUniforms;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateIlluminationUniforms;
  /**
   * Update shader uniforms by providing data from this PointSource
   * @private
   */
  private _updateBackgroundUniforms;
  /**
   * Update shader uniforms shared by all shader types
   * @param {AdaptiveVisionShader} shader        The shader being updated
   * @private
   */
  private _updateCommonUniforms;
  /**
   * Generic time animation with Vision Sources.
   * @param {number} dt            Delta time.
   */
  animateTime(dt: number): void;
}
type VisionSourceData = {
  /**
   * The x-coordinate of the source location
   */
  x: number;
  /**
   * The y-coordinate of the source location
   */
  y: number;
  /**
   * An optional z-index sorting for the source
   */
  z: number;
  /**
   * The angle of rotation for this point source
   */
  rotation: number;
  /**
   * The angle of emission for this point source
   */
  angle: number;
  /**
   * The allowed radius of bright vision or illumination
   */
  bright: number;
  /**
   * The allowed radius of vision
   */
  radius: number;
  /**
   * A secondary radius used for limited angles
   */
  externalRadius: number;
  /**
   * Is this vision source a temporary preview?
   */
  isPreview: boolean;
};
/**
 * A mixin which decorates a PIXI.Filter or PIXI.Shader with common properties.
 * @category - Mixins
 * @param {typeof PIXI.Shader} ShaderClass   The parent ShaderClass class being mixed.
 * @returns {typeof BaseShaderMixin}         A Shader/Filter subclass mixed with BaseShaderMixin features.
 */
declare function BaseShaderMixin(ShaderClass: any): typeof BaseShaderMixin;
/**
 * A mixin wich decorates a shader or filter and construct a fragment shader according to a choosen channel.
 * @category - Mixins
 * @param {typeof PIXI.Shader|PIXI.Filter} ShaderClass The parent ShaderClass class being mixed.
 * @returns {typeof AdaptiveFragmentChannelMixin}      A Shader/Filter subclass mixed with AdaptiveFragmentChannelMixin.
 */
declare function AdaptiveFragmentChannelMixin(
  ShaderClass: typeof PIXI.Shader | PIXI.Filter
): typeof AdaptiveFragmentChannelMixin;
/**
 * This class defines an interface which all shaders utilize
 * @extends {PIXI.Shader}
 * @property {object} uniforms      The current uniforms of the Shader
 * @interface
 */
declare class AbstractBaseShader {
  /**
   * The raw vertex shader used by this class.
   * A subclass of AbstractBaseShader must implement the vertexShader static field.
   * @type {string}
   */
  static vertexShader: string;
  /**
   * The raw fragment shader used by this class.
   * A subclass of AbstractBaseShader must implement the fragmentShader static field.
   * @type {string}
   */
  static fragmentShader: string;
  /**
   * The default uniform values for the shader.
   * A subclass of AbstractBaseShader must implement the defaultUniforms static field.
   * @type {object}
   */
  static defaultUniforms: object;
  /**
   * A factory method for creating the shader using its defined default values
   * @param {object} defaultUniforms
   * @returns {AbstractBaseShader}
   */
  static create(defaultUniforms: object): AbstractBaseShader;
  constructor(program: any, uniforms: any);
  /**
   * The initial default values of shader uniforms
   * @type {object}
   */
  _defaults: object;
  /**
   * Reset the shader uniforms back to their provided default values
   * @private
   */
  private reset;
}
/**
 * An abstract filter which provides a framework for reusable definition
 * @extends {PIXI.Filter}
 */
declare class AbstractBaseFilter {
  /**
   * The default uniforms used by the filter
   * @type {object}
   */
  static defaultUniforms: object;
  /**
   * The fragment shader which renders this filter.
   * @type {string}
   */
  static fragmentShader: string;
  /**
   * The vertex shader which renders this filter.
   * @type {string}
   */
  static vertexShader: string;
  /**
   * A factory method for creating the filter using its defined default values.
   * @param {object} [uniforms]     Initial uniform values which override filter defaults
   * @returns {AbstractBaseFilter}      The constructed AbstractFilter instance.
   */
  static create(uniforms?: object | undefined): AbstractBaseFilter;
  set resolution(arg: number);
  /**
   * Always target the resolution of the render texture or renderer
   * @type {number}
   */
  get resolution(): number;
  set multisample(arg: PIXI.MSAA_QUALITY);
  /**
   * Always target the MSAA level of the render texture or renderer
   * @type {PIXI.MSAA_QUALITY}
   */
  get multisample(): PIXI.MSAA_QUALITY;
}
/**
 * A batch renderer with a customizable data transfer function to packed geometries.
 * @extends PIXI.AbstractBatchRenderer
 */
declare class BatchRenderer {
  /**
   * Verify if a PIXI plugin exists. Check by name.
   * @param {string} name       The name of the pixi plugin to check.
   * @returns {boolean}         True if the plugin exists, false otherwise.
   */
  static hasPlugin(name: string): boolean;
  /**
   * The PackInterleavedGeometry function provided by the sampler.
   * @type {Function}
   * @protected
   */
  protected _packInterleavedGeometry: Function;
  /**
   * The preRender function provided by the sampler and that is called just before a flush.
   * @type {Function}
   * @protected
   */
  protected _preRenderBatch: Function;
  /**
   * Get the uniforms bound to this abstract batch renderer.
   * @returns {object|undefined}
   */
  get uniforms(): object | undefined;
  /**
   * The number of reserved texture units that the shader generator should not use (maximum 4).
   * @param {number} val
   * @protected
   */
  set reservedTextureUnits(arg: number);
  /**
   * Number of reserved texture units reserved by the batch shader that cannot be used by the batch renderer.
   * @returns {number}
   */
  get reservedTextureUnits(): number;
  /**
   * This override allows to allocate a given number of texture units reserved for a custom batched shader.
   * These reserved texture units won't be used to batch textures for PIXI.Sprite or SpriteMesh.
   * @override
   */
  override contextChange(): void;
  MAX_TEXTURES: any;
  _shader: any;
  /** @override */
  override start(): void;
  /** @override */
  override packInterleavedGeometry(
    element: any,
    attributeBuffer: any,
    indexBuffer: any,
    aIndex: any,
    iIndex: any
  ): void;
  #private;
}
/**
 * A batch shader generator that could handle extra uniforms during initialization.
 */
declare class BatchShaderGenerator {
  constructor(vertexSrc: any, fragTemplate: any, batchDefaultUniforms: any);
  /**
   * Extra uniforms that could be handled by a custom batch shader.
   * @type {Function|undefined}
   */
  _batchDefaultUniforms: Function | undefined;
  /** @override */
  override generateShader(maxTextures: any): any;
}
declare namespace BLEND_MODES {
  const MAX_COLOR: number[];
  const MIN_COLOR: number[];
  const MIN_ALL: number[];
}
/**
 * Apply a vertical or horizontal gaussian blur going inward by using alpha as the penetrating channel.
 * @param {boolean} horizontal      If the pass is horizontal (true) or vertical (false).
 * @param {number} [strength=8]     Strength of the blur (distance of sampling).
 * @param {number} [quality=4]      Number of passes to generate the blur. More passes = Higher quality = Lower Perf.
 * @param {number} [resolution=PIXI.settings.FILTER_RESOLUTION]  Resolution of the filter.
 * @param {number} [kernelSize=5]   Number of kernels to use. More kernels = Higher quality = Lower Perf.
 */
declare class AlphaBlurFilterPass {
  /**
   * The kernels containing the gaussian constants.
   * @type {Object<number, number[]>}
   */
  static GAUSSIAN_VALUES: {
    [x: number]: number[];
  };
  /**
   * The fragment template generator
   * @param {number} kernelSize   The number of kernels to use.
   * @returns {string}            The generated fragment shader.
   */
  static fragTemplate(kernelSize: number): string;
  /**
   * The vertex template generator
   * @param {number} kernelSize   The number of kernels to use.
   * @param {boolean} horizontal  If the vertex should handle horizontal or vertical pass.
   * @returns {string}            The generated vertex shader.
   */
  static vertTemplate(kernelSize: number, horizontal: boolean): string;
  /**
   * Generating the dynamic part of the blur in the fragment
   * @param {number} kernelSize   The number of kernels to use.
   * @returns {string}            The dynamic blur part.
   */
  static generateBlurFragSource(kernelSize: number): string;
  /**
   * Generating the dynamic part of the blur in the vertex
   * @param {number} kernelSize   The number of kernels to use.
   * @param {boolean} horizontal  If the vertex should handle horizontal or vertical pass.
   * @returns {string}            The dynamic blur part.
   */
  static generateBlurVertSource(
    kernelSize: number,
    horizontal: boolean
  ): string;
  constructor(
    horizontal: any,
    strength?: number,
    quality?: number,
    resolution?: any,
    kernelSize?: number
  );
  /**
   * If the pass is horizontal (true) or vertical (false).
   * @type {boolean}
   */
  horizontal: boolean;
  /**
   * Strength of the blur (distance of sampling).
   * @type {number}
   */
  strength: number;
  /**
   * The number of passes to generate the blur.
   * @type {number}
   */
  passes: number;
  resolution: any;
  set quality(arg: number);
  /**
   * The quality of the filter is defined by its number of passes.
   * @returns {number}
   */
  get quality(): number;
  set blur(arg: number);
  /**
   * The strength of the blur filter in pixels.
   * @returns {number}
   */
  get blur(): number;
  padding: number | undefined;
  /** @override */
  override apply(
    filterManager: any,
    input: any,
    output: any,
    clearMode: any
  ): any;
}
/**
 * Apply a gaussian blur going inward by using alpha as the penetrating channel.
 * @param {number} [strength=8]     Strength of the blur (distance of sampling).
 * @param {number} [quality=4]      Number of passes to generate the blur. More passes = Higher quality = Lower Perf.
 * @param {number} [resolution=PIXI.settings.FILTER_RESOLUTION]  Resolution of the filter.
 * @param {number} [kernelSize=5]   Number of kernels to use. More kernels = Higher quality = Lower Perf.
 */
declare class AlphaBlurFilter {
  constructor(
    strength?: number,
    quality?: number,
    resolution?: any,
    kernelSize?: number
  );
  blurXFilter: AlphaBlurFilterPass;
  blurYFilter: AlphaBlurFilterPass;
  resolution: any;
  _repeatEdgePixels: boolean;
  set quality(arg: number);
  /**
   * The quality of blur defines the number of passes used by subsidiary filters.
   * @type {number}
   */
  get quality(): number;
  set blur(arg: number);
  /**
   * The amount of blur is forwarded to the X and Y filters.
   * @type {number}
   */
  get blur(): number;
  /** @override */
  override apply(
    filterManager: any,
    input: any,
    output: any,
    clearMode: any
  ): void;
  /**
   * Update the filter padding according to the blur strength value (0 if _repeatEdgePixels is active)
   */
  updatePadding(): void;
  padding: number | undefined;
  set repeatEdgePixels(arg: boolean);
  /**
   * Whether to repeat edge pixels, adding padding to the filter area.
   * @type {boolean}
   */
  get repeatEdgePixels(): boolean;
  set blurX(arg: number);
  /**
   * Provided for completeness with PIXI.filters.BlurFilter
   * @type {number}
   */
  get blurX(): number;
  set blurY(arg: number);
  /**
   * Provided for completeness with PIXI.filters.BlurFilter
   * @type {number}
   */
  get blurY(): number;
  set blendMode(arg: number);
  /**
   * Provided for completeness with PIXI.filters.BlurFilter
   * @type {number}
   */
  get blendMode(): number;
}
/**
 * This class defines an interface for masked custom filters
 * @interface
 */
declare class AbstractBaseMaskFilter extends AbstractBaseFilter {
  /** @override */
  override apply(
    filterManager: any,
    input: any,
    output: any,
    clear: any,
    currentState: any
  ): void;
}
/**
 * A filter used to control channels intensity using an externally provided mask texture.
 * The mask channel used must be provided at filter creation.
 */
declare class InverseOcclusionMaskFilter {
  /** @override */
  static override adaptiveFragmentShader(channel: any): string;
  /** @override */
  static override defaultUniforms: {
    uMaskSampler: number;
    alphaOcclusion: number;
    alpha: number;
    depthElevation: number;
  };
}
/**
 * A filter used to apply a reverse mask on the target display object.
 * The caller must choose a channel to use (alpha is a good candidate).
 */
declare class ReverseMaskFilter {
  /** @override */
  static override adaptiveFragmentShader(channel: any): string;
  /** @override */
  static override defaultUniforms: {
    uMaskSampler: number;
  };
}
/**
 * A minimalist filter (just used for blending)
 */
declare class VoidFilter extends AbstractBaseFilter {}
/**
 * This filter handles masking and post-processing for visual effects.
 */
declare class VisualEffectsMaskingFilter extends AbstractBaseMaskFilter {
  /** @override */
  static override create({
    filterMode,
    postProcessModes,
    ...uniforms
  }?: {
    filterMode: any;
    postProcessModes: any;
  }): VisualEffectsMaskingFilter;
  /**
   * Masking modes.
   * @enum {number}
   */
  static FILTER_MODES: {
    BACKGROUND: string;
    ILLUMINATION: string;
    COLORATION: string;
  };
  /** @override */
  static override defaultUniforms: {
    replacementColor: number[];
    tint: number[];
    screenDimensions: number[];
    enableVisionMasking: boolean;
    uRoofSampler: number;
    uVisionSampler: number;
    exposure: number;
    contrast: number;
    saturation: number;
  };
  /**
   * Filter post-process techniques.
   * @enum {{id: string, glsl: string}}
   */
  static POST_PROCESS_TECHNIQUES: {
    EXPOSURE: {
      id: string;
      glsl: string;
    };
    CONTRAST: {
      id: string;
      glsl: string;
    };
    SATURATION: {
      id: string;
      glsl: string;
    };
    TINT: {
      id: string;
      glsl: string;
    };
  };
  /**
   * Assign the replacement color according to the filter mode.
   * @param {number} filterMode    Filter mode.
   * @returns {string}             The replacement color.
   */
  static replacementColor(filterMode: number): string;
  /**
   * Memory allocations and headers for the VisualEffectsMaskingFilter
   * @param {number} filterMode          Filter mode.
   * @returns {string}                   The filter header according to the filter mode.
   */
  static fragmentHeader(filterMode: number): string;
  /**
   * The fragment core code.
   * @type {string}
   */
  static fragmentCore: string;
  /**
   * Construct filter post-processing code according to provided value.
   * @param {string[]} postProcessModes  Post-process modes to construct techniques.
   * @returns {string}                   The constructed shader code for post-process techniques.
   */
  static fragmentPostProcess(postProcessModes?: string[]): string;
  /**
   * Specify the fragment shader to use according to mode
   * @param {number} filterMode
   * @param {string[]} postProcessModes
   * @returns {string}
   * @override
   */
  static override fragmentShader(
    filterMode?: number,
    postProcessModes?: string[]
  ): string;
  constructor(vertex: any, fragment: any, uniforms: any, filterMode: any);
  /**
   * The filter mode.
   * @type {string}
   */
  filterMode: string;
  /**
   * Update the filter shader with new post-process modes.
   * @param {string[]} [postProcessModes=[]]   New modes to apply.
   * @param {object} [uniforms={}]             Uniforms value to update.
   */
  updatePostprocessModes(
    postProcessModes?: string[] | undefined,
    uniforms?: object | undefined
  ): void;
  program: any;
  /**
   * Remove all post-processing modes and reset some key uniforms.
   */
  reset(): void;
  #private;
}
/**
 * Apply visibility coloration according to the baseLine color.
 * Uses very lightweight gaussian vertical and horizontal blur filter passes.
 * @extends {AbstractBaseFilter}
 */
declare class VisibilityFilter extends AbstractBaseFilter {
  /** @override */
  static override defaultUniforms: {
    exploredColor: number[];
    unexploredColor: number[];
    screenDimensions: number[];
    visionTexture: number;
    primaryTexture: number;
    fogTexture: number;
    fogOverlayMatrix: any;
    hasFogTexture: boolean;
  };
  constructor(...args: any[]);
  /**
   * Set the blur strength
   * @param {number} value    blur strength
   */
  set blur(arg: number);
  get blur(): number;
  /** @override */
  override apply(filterManager: any, input: any, output: any, clear: any): void;
  /**
   * Calculate the fog overlay sprite matrix.
   * @param {PIXI.FilterManager} filterManager
   */
  calculateMatrix(filterManager: PIXI.FilterManager): void;
  #private;
}
/**
 * A filter which forces all non-transparent pixels to a specific color and transparency.
 * @extends {AbstractBaseFilter}
 */
declare class ForceColorFilter extends AbstractBaseFilter {
  static defaultUniforms: {
    color: number[];
    alpha: number;
  };
}
/**
 * This filter turns pixels with an alpha channel < alphaThreshold in transparent pixels
 * Then, optionally, it can turn the result in the chosen color (default: pure white).
 * The alpha [threshold,1] is re-mapped to [0,1] with an hermite interpolation slope to prevent pixelation.
 * @extends {PIXI.Filter}
 */
declare class RoofMaskFilter {
  static defaultUniforms: {
    alphaThreshold: number;
    turnToColor: boolean;
    color: number[];
  };
  static fragmentShader: string;
}
/**
 * A filter which implements an inner or outer glow around the source texture.
 * Inspired from https://github.com/pixijs/filters/tree/main/filters/glow
 * @license MIT
 */
declare class GlowOverlayFilter extends AbstractBaseFilter {
  /** @inheritdoc */
  static defaultUniforms: {
    distance: number;
    glowColor: number[];
    quality: number;
    time: number;
  };
  /** @inheritdoc */
  static createFragmentShader(quality: any, distance: any): string;
  /** @inheritdoc */
  static create(uniforms?: {}): GlowOverlayFilter;
  /** @override */
  override padding: number;
  /**
   * The inner strength of the glow.
   * @type {number}
   */
  innerStrength: number;
  /**
   * The outer strength of the glow.
   * @type {number}
   */
  outerStrength: number;
  /** @override */
  override apply(filterManager: any, input: any, output: any, clear: any): void;
}
/**
 * A filter which implements an outline.
 * Inspired from https://github.com/pixijs/filters/tree/main/filters/outline
 * @license MIT
 */
declare class OutlineOverlayFilter extends AbstractBaseFilter {
  /** @inheritdoc */
  static defaultUniforms: {
    outlineColor: number[];
    thickness: number[];
    alphaThreshold: number;
    knockout: boolean;
    wave: boolean;
  };
  /** @inheritdoc */
  static createFragmentShader(): string;
  /**
   * Quality of the outline according to performance mode.
   * @returns {number}
   */
  static get "__#61@#quality"(): number;
  /** @inheritdoc */
  static create(uniforms?: {}): OutlineOverlayFilter;
  /** @override */
  override padding: number;
  /** @override */
  override autoFit: boolean;
  /**
   * If the filter is animated or not.
   * @type {boolean}
   */
  animate: boolean;
  set thickness(arg: number);
  /**
   * The thickness of the outline.
   * @type {number}
   */
  get thickness(): number;
  /** @override */
  override apply(filterManager: any, input: any, output: any, clear: any): void;
  #private;
}
/**
 * Masking modes.
 */
type FILTER_MODES = number;
/**
 * Filter post-process techniques.
 */
type POST_PROCESS_TECHNIQUES = {
  id: string;
  glsl: string;
};
/**
 * @typedef {Object} ShaderTechnique
 * @property {number} id                      The numeric identifier of the technique
 * @property {string} label                   The localization string that labels the technique
 * @property {string|undefined} coloration    The coloration shader fragment when the technique is used
 * @property {string|undefined} illumination  The illumination shader fragment when the technique is used
 * @property {string|undefined} background    The background shader fragment when the technique is used
 */
/**
 * This class defines an interface which all adaptive lighting shaders extend.
 * @extends {AbstractBaseShader}
 * @interface
 */
declare class AdaptiveLightingShader extends AbstractBaseShader {
  /**
   * Construct adaptive shader according to shader type
   * @param {string} shaderType  shader type to construct : coloration, illumination, background, etc.
   * @returns {string}           the constructed shader adaptive block
   */
  static getShaderTechniques(shaderType: string): string;
  /**
   * The coloration technique coloration shader fragment
   * @type {string}
   */
  static get COLORATION_TECHNIQUES(): string;
  /**
   * The coloration technique illumination shader fragment
   * @type {string}
   */
  static get ILLUMINATION_TECHNIQUES(): string;
  /**
   * The coloration technique background shader fragment
   * @type {string}
   */
  static get BACKGROUND_TECHNIQUES(): string;
  /**
   * The adjustments made into fragment shaders
   * @type {string}
   */
  static get ADJUSTMENTS(): string;
  /**
   * Contrast adjustment
   * @type {string}
   */
  static CONTRAST: string;
  /**
   * Saturation adjustment
   * @type {string}
   */
  static SATURATION: string;
  /**
   * Exposure adjustment
   * @type {string}
   */
  static EXPOSURE: string;
  /**
   * Switch between an inner and outer color, by comparing distance from center to ratio
   * Apply a strong gradient between the two areas if attenuation uniform is set to true
   * @type {string}
   */
  static SWITCH_COLOR: string;
  /**
   * Shadow adjustment
   * @type {string}
   */
  static SHADOW: string;
  /**
   * Transition between bright and dim colors, if requested
   * @type {string}
   */
  static TRANSITION: string;
  /**
   * Incorporate falloff if a attenuation uniform is requested
   * @type {string}
   */
  static FALLOFF: string;
  /**
   * Initialize fragment with common properties
   * @type {string}
   */
  static FRAGMENT_BEGIN: string;
  /**
   * Shader final
   * @type {string}
   */
  static FRAGMENT_END: string;
  /**
   * A mapping of available shader techniques
   * @type {Object<string, ShaderTechnique>}
   */
  static SHADER_TECHNIQUES: {
    [x: string]: ShaderTechnique;
  };
  /**
   * Determine the correct penalty to apply for a given darkness level and luminosity
   * @param {number} darknessLevel      The current darkness level on [0,1]
   * @param {number} luminosity         The light source luminosity on [-1,1]
   * @returns {number}                  The amount of penalty to apply on [0,1]
   */
  getDarknessPenalty(darknessLevel: number, luminosity: number): number;
}
/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveBackgroundShader
  extends AdaptiveLightingShader
  implements AdaptiveLightingShader
{
  /**
   * Memory allocations for the Adaptive Background Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: any;
    contrast: any;
    shadows: any;
    saturation: any;
    intensity: any;
    attenuation: any;
    exposure: number;
    ratio: number;
    darkness: boolean;
    color: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
  /**
   * Flag whether the background shader is currently required.
   * Check vision modes requirements first, then
   * if key uniforms are at their default values, we don't need to render the background container.
   * @type {boolean}
   */
  get isRequired(): boolean;
}
/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveIlluminationShader
  extends AdaptiveLightingShader
  implements AdaptiveLightingShader
{
  /**
   * Memory allocations for the Adaptive Illumination Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: any;
    shadows: any;
    saturation: any;
    intensity: any;
    attenuation: any;
    contrast: any;
    exposure: number;
    ratio: number;
    darkness: boolean;
    darknessLevel: number;
    color: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    primaryTexture: number;
    framebufferTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
  /**
   * Flag whether the illumination shader is currently required.
   * @type {boolean}
   */
  get isRequired(): boolean;
}
/**
 * The default coloration shader used by standard rendering and animations.
 * A fragment shader which creates a light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveColorationShader
  extends AdaptiveLightingShader
  implements AdaptiveLightingShader
{
  /**
   * Memory allocations for the Adaptive Coloration Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: any;
    shadows: any;
    saturation: any;
    colorationAlpha: number;
    intensity: any;
    attenuation: any;
    ratio: number;
    color: number[];
    time: number;
    darkness: boolean;
    hasColor: boolean;
    screenDimensions: number[];
    useSampler: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
  /**
   * Flag whether the coloration shader is currently required.
   * @type {boolean}
   */
  get isRequired(): boolean;
}
/**
 * Allow coloring of illumination
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class TorchIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Torch animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class TorchColorationShader extends AdaptiveColorationShader {
  /** @inheritdoc */
  static defaultUniforms: {
    ratio: number;
    brightnessPulse: number;
    technique: any;
    shadows: any;
    saturation: any;
    colorationAlpha: number;
    intensity: any;
    attenuation: any;
    color: number[];
    time: number;
    darkness: boolean;
    hasColor: boolean;
    screenDimensions: number[];
    useSampler: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * Pulse animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class PulseIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Pulse animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class PulseColorationShader extends AdaptiveColorationShader {
  /** @inheritdoc */
  static defaultUniforms: {
    pulse: number;
    technique: any;
    shadows: any;
    saturation: any;
    colorationAlpha: number;
    intensity: any;
    attenuation: any;
    ratio: number;
    color: number[];
    time: number;
    darkness: boolean;
    hasColor: boolean;
    screenDimensions: number[];
    useSampler: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * Energy field animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class EnergyFieldColorationShader extends AdaptiveColorationShader {}
/**
 * Chroma animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class ChromaColorationShader extends AdaptiveColorationShader {}
/**
 * Wave animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class WaveIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Wave animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class WaveColorationShader extends AdaptiveColorationShader {}
/**
 * Bewitching Wave animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class BewitchingWaveIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Bewitching Wave animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class BewitchingWaveColorationShader extends AdaptiveColorationShader {}
/**
 * Fog animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class FogColorationShader extends AdaptiveColorationShader {}
/**
 * Sunburst animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class SunburstIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Sunburst animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class SunburstColorationShader extends AdaptiveColorationShader {}
/**
 * Light dome animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class LightDomeColorationShader extends AdaptiveColorationShader {}
/**
 * Emanation animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class EmanationColorationShader extends AdaptiveColorationShader {}
/**
 * Ghost light animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class GhostLightIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Ghost light animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class GhostLightColorationShader extends AdaptiveColorationShader {}
/**
 * Hexagonal dome animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class HexaDomeColorationShader extends AdaptiveColorationShader {}
/**
 * Roling mass illumination shader - intended primarily for darkness
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class RoilingIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Black Hole animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class BlackHoleIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Vortex animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class VortexColorationShader extends AdaptiveColorationShader {}
/**
 * Vortex animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class VortexIlluminationShader extends AdaptiveColorationShader {}
/**
 * Swirling rainbow animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class SwirlingRainbowColorationShader extends AdaptiveColorationShader {}
/**
 * Radial rainbow animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class RadialRainbowColorationShader extends AdaptiveColorationShader {}
/**
 * Fairy light animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class FairyLightColorationShader extends AdaptiveColorationShader {}
/**
 * Fairy light animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class FairyLightIlluminationShader extends AdaptiveIlluminationShader {}
/**
 * Alternative torch illumination shader
 * @extends {AdaptiveIlluminationShader}
 */
declare class FlameIlluminationShader extends AdaptiveIlluminationShader {
  /** @inheritdoc */
  static defaultUniforms: {
    brightnessPulse: number;
    technique: any;
    shadows: any;
    saturation: any;
    intensity: any;
    attenuation: any;
    contrast: any;
    exposure: number;
    ratio: number;
    darkness: boolean;
    darknessLevel: number;
    color: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    primaryTexture: number;
    framebufferTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * Alternative torch coloration shader
 * @extends {AdaptiveColorationShader}
 */
declare class FlameColorationShader extends AdaptiveColorationShader {
  /** @inheritdoc */
  static defaultUniforms: {
    brightnessPulse: number;
    technique: any;
    shadows: any;
    saturation: any;
    colorationAlpha: number;
    intensity: any;
    attenuation: any;
    ratio: number;
    color: number[];
    time: number;
    darkness: boolean;
    hasColor: boolean;
    screenDimensions: number[];
    useSampler: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * A futuristic Force Grid animation.
 * @extends {AdaptiveColorationShader}
 */
declare class ForceGridColorationShader extends AdaptiveColorationShader {}
/**
 * A disco like star light.
 * @extends {AdaptiveColorationShader}
 */
declare class StarLightColorationShader extends AdaptiveColorationShader {}
/**
 * A patch of smoke
 * @extends {AdaptiveColorationShader}
 */
declare class SmokePatchColorationShader extends AdaptiveColorationShader {}
/**
 * A patch of smoke
 * @extends {AdaptiveIlluminationShader}
 */
declare class SmokePatchIlluminationShader extends AdaptiveIlluminationShader {}
type ShaderTechnique = {
  /**
   * The numeric identifier of the technique
   */
  id: number;
  /**
   * The localization string that labels the technique
   */
  label: string;
  /**
   * The coloration shader fragment when the technique is used
   */
  coloration: string | undefined;
  /**
   * The illumination shader fragment when the technique is used
   */
  illumination: string | undefined;
  /**
   * The background shader fragment when the technique is used
   */
  background: string | undefined;
};
/**
 * A simple shader to emulate a PIXI.Sprite with a PIXI.SpriteMesh
 */
declare class BaseSamplerShader extends AbstractBaseShader {
  /**
   * The named batch sampler plugin that is used by this shader, or null if no batching is used.
   * @type {string}
   */
  static classPluginName: string;
  /**
   * Contrast adjustment
   * @type {string}
   */
  static CONTRAST: string;
  /**
   * Saturation adjustment
   * @type {string}
   */
  static SATURATION: string;
  /**
   * Exposure adjustment.
   * @type {string}
   */
  static EXPOSURE: string;
  /**
   * The adjustments made into fragment shaders.
   * @type {string}
   */
  static get ADJUSTMENTS(): string;
  /**
   * Batch default vertex
   * @type {string}
   */
  static batchVertexShader: string;
  /**
   * Batch default fragment
   * @type {string}
   */
  static batchFragmentShader: string;
  /** @inheritdoc */
  static defaultUniforms: {
    tintAlpha: number[];
    sampler: number;
  };
  /**
   * Batch geometry associated with this sampler.
   * @type {typeof PIXI.BatchGeometry}
   */
  static batchGeometry: any;
  /**
   * The size of a vertice with all its packed attributes.
   * @type {number}
   */
  static batchVertexSize: number;
  /**
   * Pack interleaved geometry custom function.
   * @type {Function|undefined}
   * @protected
   */
  protected static _packInterleavedGeometry: Function | undefined;
  /**
   * A prerender function happening just before the batch renderer is flushed.
   * @type {Function}
   * @protected
   */
  protected static _preRenderBatch(): void;
  /**
   * A function that returns default uniforms associated with the batched version of this sampler.
   * @abstract
   * @type {Function|undefined}
   */
  static batchDefaultUniforms: Function | undefined;
  /**
   * The number of reserved texture units for this shader that cannot be used by the batch renderer.
   * @type {number}
   */
  static reservedTextureUnits: number;
  /**
   * Initialize the batch geometry with custom properties.
   * @abstract
   */
  static initializeBatchGeometry(): void;
  /**
   * The batch renderer to use.
   * @type {typeof BatchRenderer}
   */
  static batchRendererClass: typeof BatchRenderer;
  /**
   * The batch generator to use.
   * @type {typeof BatchShaderGenerator}
   */
  static batchShaderGeneratorClass: typeof BatchShaderGenerator;
  /**
   * Create a batch plugin for this sampler class.
   * @returns {typeof BatchPlugin}            The batch plugin class linked to this sampler class.
   */
  static createPlugin(): any;
  /**
   * Register the plugin for this sampler.
   */
  static registerPlugin(): void;
  constructor(...args: any[]);
  /**
   * The plugin name associated for this instance.
   * @type {string}
   */
  pluginName: string;
  set enabled(arg: boolean);
  /**
   * Activate or deactivate this sampler. If set to false, the batch rendering is redirected to "batch".
   * Otherwise, the batch rendering is directed toward the instance pluginName (might be null)
   * @type {boolean}
   */
  get enabled(): boolean;
  /**
   * Perform operations which are required before binding the Shader to the Renderer.
   * @param {SpriteMesh} mesh      The mesh linked to this shader.
   * @internal
   */
  _preRender(mesh: SpriteMesh): void;
  #private;
}
/**
 * A color adjustment shader.
 */
declare class ColorAdjustmentsSamplerShader extends BaseSamplerShader {
  /** @override */
  static override classPluginName: null;
  /** @inheritdoc */
  static defaultUniforms: {
    tintAlpha: number[];
    tint: number[];
    contrast: number;
    saturation: number;
    exposure: number;
    sampler: number;
    linkedToDarknessLevel: boolean;
    darknessLevel: number;
  };
  set linkedToDarknessLevel(arg: any);
  get linkedToDarknessLevel(): any;
  set darknessLevel(arg: any);
  get darknessLevel(): any;
  set contrast(arg: any);
  get contrast(): any;
  set exposure(arg: any);
  get exposure(): any;
  set saturation(arg: any);
  get saturation(): any;
}
/**
 * A light amplification shader.
 */
declare class AmplificationSamplerShader extends ColorAdjustmentsSamplerShader {
  /** @inheritdoc */
  static defaultUniforms: {
    tintAlpha: number[];
    tint: number[];
    brightness: number;
    darknessLevel: number;
    enable: boolean;
  };
  set darknessLevel(arg: number);
  /**
   * Level of natural brightness (opposed to darkness level).
   * @type {number}
   */
  get darknessLevel(): number;
  set brightness(arg: number);
  /**
   * Brightness controls the luminosity.
   * @type {number}
   */
  get brightness(): number;
  set colorTint(arg: number[]);
  /**
   * Tint color applied to Light Amplification.
   * @type {number[]}       Light Amplification tint (default: [0.48, 1.0, 0.48]).
   */
  get colorTint(): number[];
}
/**
 * A color adjustment shader.
 */
declare class TokenInvisibilitySamplerShader extends BaseSamplerShader {
  /** @override */
  static override classPluginName: null;
  /** @inheritdoc */
  static defaultUniforms: {
    tintAlpha: number[];
    sampler: number;
    color: number[];
    alpha: number;
  };
}
/**
 * A monochromatic shader.
 */
declare class MonochromaticSamplerShader extends BaseSamplerShader {}
/**
 * A shader used to control channels intensity using an externally provided mask texture.
 */
declare class InverseOcclusionSamplerShader extends BaseSamplerShader {
  /** @override */
  static override classPluginName: null;
  /** @inheritdoc */
  static defaultUniforms: {
    roof: boolean;
    vision: boolean;
    tintAlpha: number[];
    depthElevation: number;
    sampler: number;
    maskSampler: number;
    alpha: number;
    alphaOcclusion: number;
    screenDimensions: number[];
  };
  /** @override */
  override _preRender(mesh: any): void;
}
/**
 * An occlusion shader to reveal certain area with elevation comparisons.
 * This shader is also working as a batched plugin.
 */
declare class OcclusionSamplerShader extends BaseSamplerShader {
  /** @override */
  static override batchDefaultUniforms(maxTex: any): {
    screenDimensions: number[];
    _occlusionTexture: any;
  };
  /** @override */
  static override _preRenderBatch(batchRenderer: any): void;
  /** @override */
  static override _packInterleavedGeometry(
    element: any,
    attributeBuffer: any,
    indexBuffer: any,
    aIndex: any,
    iIndex: any
  ): void;
  /** @inheritdoc */
  static defaultUniforms: {
    tintAlpha: number[];
    sampler: number;
    occlusionTexture: number;
    occlusionMode: number;
    screenDimensions: number[];
  };
  /** @override */
  override _preRender(mesh: any): void;
}
/**
 * A simple shader which purpose is to make the original texture red channel the alpha channel,
 * and still keeping channel informations. Used in cunjunction with the AlphaBlurFilterPass.
 */
declare class FogSamplerShader extends BaseSamplerShader {
  /** @override */
  static override classPluginName: null;
}
/**
 * This class defines an interface which all adaptive vision shaders extend.
 * @extends {AdaptiveLightingShader}
 * @interface
 */
declare class AdaptiveVisionShader extends AdaptiveLightingShader {}
/**
 * The default background shader used for vision sources
 * @implements {AdaptiveVisionShader}
 */
declare class BackgroundVisionShader
  extends AdaptiveVisionShader
  implements AdaptiveVisionShader
{
  /**
   * Memory allocations for the Adaptive Background Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: number;
    saturation: number;
    contrast: number;
    attenuation: number;
    exposure: number;
    darknessLevel: number;
    colorVision: number[];
    colorTint: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    linkedToDarknessLevel: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
  /**
   * Flag whether the background shader is currently required.
   * If key uniforms are at their default values, we don't need to render the background container.
   * @type {boolean}
   */
  get isRequired(): boolean;
}
/**
 * The default illumination shader used for vision sources
 * @implements {AdaptiveVisionShader}
 */
declare class IlluminationVisionShader
  extends AdaptiveVisionShader
  implements AdaptiveVisionShader
{
  /**
   * Transition between bright and dim colors, if requested
   * @type {string}
   */
  static VISION_COLOR: string;
  /**
   * Memory allocations for the Adaptive Illumination Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: any;
    attenuation: number;
    exposure: number;
    saturation: number;
    darknessLevel: number;
    colorVision: number[];
    colorTint: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    linkedToDarknessLevel: boolean;
    primaryTexture: number;
    framebufferTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * The default coloration shader used for vision sources.
 * @implements {AdaptiveLightingShader}
 */
declare class ColorationVisionShader
  extends AdaptiveVisionShader
  implements AdaptiveLightingShader
{
  /**
   * Memory allocations for the Adaptive Coloration Shader
   * @type {string}
   */
  static SHADER_HEADER: string;
  /** @inheritdoc */
  static defaultUniforms: {
    technique: number;
    saturation: number;
    attenuation: number;
    colorEffect: number[];
    time: number;
    screenDimensions: number[];
    useSampler: boolean;
    primaryTexture: number;
    linkedToDarknessLevel: boolean;
    depthTexture: number;
    depthElevation: number;
  };
  /**
   * Flag whether the coloration shader is currently required.
   * If key uniforms are at their default values, we don't need to render the coloration container.
   * @type {boolean}
   */
  get isRequired(): boolean;
}
/**
 * Shader specialized in wave like senses (tremorsenses)
 * @implements {BackgroundVisionShader}
 */
declare class WaveBackgroundVisionShader
  extends BackgroundVisionShader
  implements BackgroundVisionShader {}
/**
 * The wave vision shader, used to create waves emanations (ex: tremorsense)
 * @implements {ColorationVisionShader}
 */
declare class WaveColorationVisionShader
  extends ColorationVisionShader
  implements ColorationVisionShader {}
/**
 * Shader specialized in light amplification
 * @implements {BackgroundVisionShader}
 */
declare class AmplificationBackgroundVisionShader
  extends BackgroundVisionShader
  implements BackgroundVisionShader
{
  /** @inheritdoc */
  static defaultUniforms: {
    colorTint: number[];
    brightness: number;
    technique: number;
    saturation: number;
    contrast: number;
    attenuation: number;
    exposure: number;
    darknessLevel: number;
    colorVision: number[];
    colorBackground: number[];
    screenDimensions: number[];
    time: number;
    useSampler: boolean;
    linkedToDarknessLevel: boolean;
    primaryTexture: number;
    depthTexture: number;
    depthElevation: number;
  };
}
/**
 * Provide the necessary methods to get a snapshot of the framebuffer into a render texture.
 * Class meant to be used as a singleton.
 * Created with the precious advices of dev7355608.
 */
declare class FramebufferSnapshot {
  /**
   * Create a render texture, provide a render method and an optional clear color.
   * @returns {PIXI.RenderTexture}              A reference to the created render texture.
   */
  static "__#63@#createRenderTexture"(): PIXI.RenderTexture;
  /**
   * The RenderTexture that is the render destination for the framebuffer snapshot.
   * @type {PIXI.RenderTexture}
   */
  framebufferTexture: PIXI.RenderTexture;
  /**
   * Get the framebuffer texture snapshot.
   * @param {PIXI.Renderer} renderer    The renderer for this context.
   * @returns {PIXI.RenderTexture}      The framebuffer snapshot.
   */
  getFramebufferTexture(renderer: PIXI.Renderer): PIXI.RenderTexture;
  #private;
}
/**
 * A smooth noise generator for one-dimensional values.
 * @param {object} options                        Configuration options for the noise process.
 * @param {number} [options.amplitude=1]          The generated noise will be on the range [0, amplitude].
 * @param {number} [options.scale=1]              An adjustment factor for the input x values which place them on an
 *                                                appropriate range.
 * @param {number} [options.maxReferences=256]    The number of pre-generated random numbers to generate.
 */
declare class SmoothNoise {
  constructor({
    amplitude,
    scale,
    maxReferences,
  }?: {
    amplitude?: number | undefined;
    scale?: number | undefined;
    maxReferences?: number | undefined;
  });
  set amplitude(arg: number[]);
  /**
   * Amplitude of the generated noise output
   * The noise output is multiplied by this value
   * @type {number[]}
   */
  get amplitude(): number[];
  set scale(arg: number[]);
  /**
   * Scale factor of the random indices
   * @type {number[]}
   */
  get scale(): number[];
  _amplitude: any;
  _scale: any;
  /**
   * Generate the noise value corresponding to a provided numeric x value.
   * @param {number} x      Any finite number
   * @return {number}       The corresponding smoothed noise value
   */
  generate(x: number): number;
}
/**
 * A form application for managing core server configuration options.
 * @extends FormApplication
 * @see config.ApplicationConfiguration
 */
declare class ApplicationConfigurationForm extends FormApplication {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * An ApplicationConfiguration instance which is used for validation and processing of form changes.
   * @type {config.ApplicationConfiguration}
   */
  config: config.ApplicationConfiguration;
  /** @override */
  override getData(options?: {}): {
    config: any;
    cssClass: any;
    cssId: any;
    languages: any;
    fields: any;
    worlds: any[];
  };
  /** @override */
  override _onSubmit(event: any, options?: {}): Promise<any>;
}
/**
 * The End User License Agreement
 * Display the license agreement and prompt the user to agree before moving forwards
 * @type {Application}
 */
declare class EULA extends Application {
  /**
   * A reference to the setup URL used under the current route prefix, if any
   * @return {string}
   */
  get licenseURL(): string;
  /** @override */
  override getData(): Promise<{
    html: any;
  }>;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Handle refusal of the EULA by checking the decline button
   * @param {MouseEvent} event    The originating click event
   */
  _onDecline(event: MouseEvent): void;
  /**
   * Validate form submission before sending it onwards to the server
   * @param {Event} event       The originating form submission event
   */
  _onSubmit(event: Event): number | undefined;
}
/**
 * A special class of Dialog which allows for the installation of Packages.
 */
declare class InstallPackage extends Application {
  /** @override */
  static override get defaultOptions(): any;
  /**
   * Organize package data and cache it to the application
   * @param {string} type   The type of packages being retrieved
   * @returns {object[]}     The retrieved or cached packages
   */
  static getTaggedPackages(type: string): object[];
  constructor(data: any, options: any);
  data: any;
  /**
   * The instance of the setup form to which this is linked
   * @type {SetupConfigurationForm}
   */
  setup: SetupConfigurationForm;
  /**
   * The category being filtered for
   * @type {string}
   */
  _category: string;
  /**
   * The visibility being filtered for
   * @type {string}
   */
  _visibility: string;
  /**
   * The list of installable packages
   * @type {ClientPackage[]}
   */
  packages: ClientPackage[];
  /**
   * The list of Tags available
   * @type {Array<object>}
   */
  tags: Array<object>;
  /**
   * Have we initialized the filter to a special value?
   * @type {boolean}
   * @private
   */
  private _initializedFilter;
  /** @inheritDoc */
  render(...args: any[]): Application;
  /** @inheritDoc */
  getData(options?: {}): Promise<object>;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Handle left-click events to filter to a certain module category
   * @param {MouseEvent} event
   * @private
   */
  private _onClickCategoryFilter;
  /**
   * Handle left-click events to filter to a certain visibility state
   * @param {MouseEvent} event
   * @private
   */
  private _onClickVisibilityFilter;
  /**
   * Handle a left-click event on the package title
   * @param {MouseEvent} event
   * @private
   */
  private _onClickPackageTitle;
  /**
   * Handle a left-click event on the package "Install" button
   * @param {MouseEvent} event
   * @private
   */
  private _onClickPackageInstall;
  /** @override */
  override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
}
/**
 * The Join Game setup application
 * @extends {FormApplication}
 */
declare class JoinGameForm extends FormApplication {
  /** @override */
  static override get defaultOptions(): any;
  constructor(object: any, options: any);
  /** @inheritdoc */
  getData(options?: {}): {
    isAdmin: any;
    users: any;
    world: World;
    passwordString: any;
    usersCurrent: any;
    usersMax: any;
  };
  /**
   * Toggle the submission mode of the form to alter what pressing the "ENTER" key will do
   * @param {string} mode
   * @private
   */
  private _setMode;
  /** @inheritdoc */
  _onSubmit(event: any, options: any): Promise<void>;
  /**
   * Handle requests to shut down the currently active world
   * @param {MouseEvent} event    The originating click event
   * @returns {Promise<void>}
   * @private
   */
  private _onShutdown;
  /**
   * Submit join view POST requests to the server for handling.
   * @param {object} formData                         The processed form data
   * @param {EventTarget|HTMLButtonElement} button    The triggering button element
   * @returns {Promise<void>}
   * @private
   */
  private _post;
}
/**
 * The Setup Authentication Form
 * @extends {Application}
 */
declare class SetupAuthenticationForm extends Application {
  /** @inheritdoc */
  static get defaultOptions(): any;
}
/**
 * The Setup screen configuration form application.
 * @alias ui.setup
 */
declare class SetupConfigurationForm extends Application {
  /** @override */
  static override get defaultOptions(): any;
  /**
   * Track the button elements which represent updates for different named packages
   * @type {HTMLElement|null}
   * @private
   */
  private _progressButton;
  /**
   * Keeps track of which packages were updated to enable displaying their state on redraw
   * @type {Set<string>}
   * @private
   */
  private _updatedPackages;
  /**
   * The name of the currently active tab.
   * @type {string}
   */
  get activeTab(): string;
  /** @override */
  override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  /** @inheritdoc */
  _onChangeTab(event: any, tabs: any, active: any): void;
  /** @override */
  override getData(options?: {}): {
    coreVersion: string;
    release: config.ReleaseData;
    coreVersionHint: string;
    noSystems: boolean;
    systems: any;
    modules: any;
    worlds: any;
    languages: any;
    options: {};
    adminPassword: any;
    updateChannels: any;
    updateChannelHints: any;
    coreUpdate: string | boolean;
    canReachInternet: any;
    couldReachWebsite: any;
    slowResponse: any;
    updateButtonEnabled: any;
  };
  /** @inheritdoc */
  _render(force: any, options: any): Promise<void>;
  /** @override */
  override activateListeners(html: any): void;
  /**
   * Post the setup configuration form
   * @param {object} requestData    An object of data which should be included with the POST request
   * @param {object} requestOptions An object of options passed to the fetchWithTimeout method
   * @returns {Promise<object>}     A Promise resolving to the returned response data
   * @throws                        An error if the request was not successful
   * @internal
   */
  _post(requestData: object, requestOptions?: object): Promise<object>;
  /**
   * Reload the setup view by re-acquiring setup data and re-rendering the form
   * @private
   */
  private reload;
  /**
   * Refresh this application UI by re-rendering it and other related applications.
   */
  refresh(): void;
  /**
   * Generic button handler for the setup form which submits a POST request including any dataset on the button itself
   * @param {MouseEvent} event    The originating mouse click event
   * @returns {Promise}
   * @private
   */
  private _onActionButton;
  /**
   * Begin creation of a new World using the config form
   * @param {MouseEvent} event    The originating mouse click event
   * @private
   */
  private _onWorldConfig;
  /**
   * When changing the software update channel, reset the state of the update button and "Force Update" checkbox.
   * Clear results from a prior check to ensure that users don't accidentally perform an update for some other channel.
   * @param {Event} event     The select change event
   */
  _onChangeChannel(event: Event): Promise<void>;
  /**
   * Handle uninstall button clicks to remove existing packages
   * @param {Event} event
   * @private
   */
  private _onUninstallPackage;
  /**
   * Handle button clicks to update the core VTT software
   * @param {Event} event
   * @private
   */
  private _onCoreUpdate;
  /**
   * Update the display of an installation progress bar for a particular progress packet
   * @param {object} data   The progress update data
   */
  updateProgressBar(data: object): void;
  /**
   * Update installation progress for a particular button which triggered the action
   * @param {object} data   The progress update data
   */
  updateProgressButton(data: object): void;
  #private;
}
type PackageCheckResult = {
  /**
   * The Package Type
   */
  type: string;
  /**
   * The Package Id
   */
  id: string;
  /**
   * The update button for the Package
   */
  button: HTMLElement;
  /**
   * The State of the check, from [ "error", "sidegrade", "trackChange", "warning", "update", "current", "unknown" ]
   */
  state: string;
  /**
   * An error to display, if any
   */
  error?: string | undefined;
  /**
   * A warning to display, if any
   */
  warning?: string | undefined;
  /**
   * : string, version: string} [trackChange]     The suggested track change, if any
   */
  "": manifest;
  /**
   * The manifest of the Update, if any
   */
  manifest?: string | undefined;
};
/**
 * The client side Updater application
 * This displays the progress of patching/update progress for the VTT
 * @type {Application}
 */
declare class UpdateNotes extends Application {
  /** @override */
  static override get defaultOptions(): any;
  /**
   * Update the button at the footer of the Update Notes application to reflect the current status of the workflow.
   * @param {object} progressData       Data supplied by SetupConfig#_onCoreUpdate
   */
  static updateButton(progressData: object): void;
  constructor(target: any, options: any);
  target: any;
  candidateReleaseData: any;
  /** @override */
  override getData(options?: {}): Promise<{
    notes: any;
  }>;
  /** @override */
  override activateListeners(html: any): void;
}
/**
 * The User Management setup application.
 * @param {Users} object                      The {@link Users} object being configured.
 * @param {FormApplicationOptions} [options]  Application configuration options.
 */
declare class UserManagement extends FormApplication {
  /** @inheritdoc */
  static get defaultOptions(): any;
  /**
   * The template path used to render a single user entry in the configuration view
   * @type {string}
   */
  static USER_TEMPLATE: string;
  /**
   * Get a mapping of role IDs to labels that should be displayed
   * @private
   */
  private static _getRoleLabels;
  /**
   * Handle new user creation event
   * @param {PointerEvent} event      The originating click event
   * @private
   */
  private static _onAction;
  /**
   * When the user enters some characters into a password field, present them with the "show" label that allows them
   * to see the text they have entered.
   * @param {KeyboardEvent} event     The initiating keydown event
   * @private
   */
  private static _onPasswordKeydown;
  /**
   * Reveal the password that is being configured so the user can verify they have typed it correctly.
   * @param {PointerEvent} event        The initiating mouse click event
   * @private
   */
  private static _onShowPassword;
  /**
   * Handle creating a new User record in the form
   * @private
   */
  private static _onUserCreate;
  /**
   * Handle user deletion event
   * @param {PointerEvent} event      The originating click event
   * @private
   */
  private static _onUserDelete;
  /** @inheritdoc */
  _render(...args: any[]): Promise<void>;
  /** @inheritdoc */
  getData(options?: {}): {
    user: any;
    users: any;
    roles: any;
    options: object;
    userTemplate: any;
    passwordString: any;
  };
  /** @inheritdoc */
  _updateObject(event: any, formData: any): Promise<any>;
}
/**
 * A library of package management commands which are used by various interfaces around the software.
 * @extends {Game}
 */
declare class Setup extends Game {
  /**
   * A reference to the setup URL used under the current route prefix, if any
   * @type {string}
   */
  static get setupURL(): string;
  /** @override */
  static override getData(socket: any, view: any): Promise<any>;
  /**
   * Log server-provided package warnings so that they are discoverable on the client-side.
   * @param {object} packageWarnings         An object of package warnings and errors by package ID.
   * @param {object} [options]               Additional options to configure logging behaviour.
   * @param {boolean} [options.notify=true]  Whether to create UI notifications in addition to logging.
   */
  static "__#64@#logPackageWarnings"(
    packageWarnings: object,
    {
      notify,
    }?:
      | {
          notify?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Check with the server whether a package of a certain type may be installed or updated.
   * @param {object} options    Options which affect how the check is performed
   * @param {string} options.type       The package type to check
   * @param {string} options.id         The package id to check
   * @param {string} [options.manifest] The manifest URL to check
   * @param {number} [options.timeout]  A timeout in milliseconds after which the check will fail
   * @returns {Promise<PackageManifestData>} The resulting manifest if an update is available
   */
  static checkPackage({
    type,
    id,
    manifest,
    timeout,
  }?: {
    type: string;
    id: string;
    manifest?: string | undefined;
    timeout?: number | undefined;
  }): Promise<PackageManifestData>;
  /**
   * Prepares the cache of available and owned packages
   * @param {object} options          Options which configure how the cache is warmed
   * @param {string} options.type     The type of package being cached
   * @returns {Promise<void>}
   */
  static warmPackages({ type }?: { type: string }): Promise<void>;
  /**
   * Get a Map of available packages of a given type which may be installed
   * @param {string} type
   * @returns {Promise<Map<string, ClientPackage>>}
   */
  static getPackages({ type }?: string): Promise<Map<string, ClientPackage>>;
  /**
   * Install a Package
   * @param {object} options        Options which affect how the package is installed
   * @param {string} options.type          The type of package being installed, in ["module", "system", "world"]
   * @param {string} options.id            The package id
   * @param {string} options.manifest      The package manifest URL
   * @param {Function} onProgress  A function that will receive progress updates during the installation process
   * @returns {Promise<foundry.packages.BasePackage>}    A Promise which resolves to the installed package
   */
  static installPackage(
    {
      type,
      id,
      manifest,
    }:
      | {
          type: string;
          id: string;
          manifest: string;
        }
      | undefined,
    onProgress: Function
  ): Promise<foundry.packages.BasePackage>;
  /**
   * Install a set of dependency modules which are required by an installed package
   * @param {ClientPackage} pkg   The package which was installed that requested dependencies
   * @returns {Promise<void>}
   */
  static installDependencies(pkg: ClientPackage): Promise<void>;
  /**
   * @typedef {Object} PackageDependencyCheck
   * @property {string} id                The package id
   * @property {string} type              The package type
   * @property {string} manifest          The package manifest URL
   * @property {boolean} installNeeded    Whether the package is already installed
   * @property {boolean} canInstall       Whether the package can be installed
   * @property {string} message           An error message to display to the user
   * @property {string} url               The URL to the package
   * @property {string} version           The package version
   */
  /**
   * Checks a dependency to see if it needs to be installed
   * @param {RelatedPackage} relatedPackage                                   The dependency
   * @param {Map<string, PackageDependencyCheck>} dependencyChecks            The current map of dependencies to install
   * @returns {Promise<void>}
   * @private
   */
  private static "__#64@#checkDependency";
  /**
   * Uninstall a single Package by name and type.
   * @param {object} options            Options which configure how package uninstallation is handled
   * @param {string} options.type       The type of package being installed, in ["module", "system", "world"]
   * @param {string} options.id         The canonical package id
   * @returns {Promise<object>}         A Promise which resolves to the uninstalled package manifest
   */
  static uninstallPackage({
    type,
    id,
  }?: {
    type: string;
    id: string;
  }): Promise<object>;
  /**
   * Activate socket listeners related to the Setup view.
   */
  static _activateSocketListeners(): void;
  /**
   * A list of functions to call on progress events.
   * @type {Function[]}
   */
  static _progressListeners: Function[];
  /**
   * Handle a progress event from the server.
   * @param {object} data  The progress update data.
   * @private
   */
  private static _onProgress;
  /**
   * Add a function to be called on a progress event.
   * @param {Function} listener
   */
  static _addProgressListener(listener: Function): void;
  /**
   * Stop sending progress events to a given function.
   * @param {Function} listener
   */
  static _removeProgressListener(listener: Function): void;
  /**
   * A helper method to submit a POST request to setup configuration with a certain body, returning the JSON response
   * @param {object} body             The request body to submit
   * @param {number} [timeout=30000]  The time, in milliseconds, to wait before aborting the request
   * @returns {Promise<object>}       The response body
   * @private
   */
  private static post;
  /** @override */
  override setupPackages(data: any): void;
  worlds: any;
  systems: any;
  /** @override */
  override _initializeView(): Promise<void>;
  /**
   * The application view which displays the End User License Agreement (EULA).
   * @private
   */
  private _licenseView;
  /**
   * The application view which displays the admin authentication application.
   * @private
   */
  private _authView;
  /**
   * The application view which displays the application Setup and Configuration.
   * @private
   */
  private _setupView;
  /**
   * The application view which displays the User Configuration.
   * @private
   */
  private _playersView;
  users: Users | undefined;
  /**
   * The application view which displays the Game join and authentication screen.
   * @private
   */
  private _joinView;
}
declare namespace Setup {
  export namespace CACHE_STATES {
    const COLD: number;
    const WARMING: number;
    const WARMED: number;
  }
  /**
   * An enum that indicates a state the Cache is in
   */
  type CACHE_STATES = number;
  export const cache: {
    world: World[];
    system: System[];
    module: Module[];
  };
}
type PackageDependencyCheck = {
  /**
   * The package id
   */
  id: string;
  /**
   * The package type
   */
  type: string;
  /**
   * The package manifest URL
   */
  manifest: string;
  /**
   * Whether the package is already installed
   */
  installNeeded: boolean;
  /**
   * Whether the package can be installed
   */
  canInstall: boolean;
  /**
   * An error message to display to the user
   */
  message: string;
  /**
   * The URL to the package
   */
  url: string;
  /**
   * The package version
   */
  version: string;
};
/**
 * A tour for demonstrating an aspect of Canvas functionality.
 * Automatically activates a certain canvas layer or tool depending on the needs of the step.
 */
declare class CanvasTour extends Tour {
  /** @override */
  override start(): Promise<void>;
  #private;
}
/**
 * A Tour subclass that handles controlling the UI state of the Setup screen
 */
declare class SetupTour extends Tour {
  /**
   * Stores a currently open Application for future steps
   * @type {Application}
   */
  focusedApp: Application;
  /**
   * Handle Step setup for the Installing a System Tour
   * @returns {Promise<void>}
   * @private
   */
  private _installingASystem;
  /**
   * Handle Step setup for the Creating a World Tour
   * @returns {Promise<void>}
   * @private
   */
  private _creatingAWorld;
}
/**
 * A Tour subclass for the Sidebar Tour
 */
declare class SidebarTour extends Tour {
  /** @override */
  override start(): Promise<void>;
  _updateSidebarTab(): Promise<void>;
}
/**
 * @typedef {object} ContextMenuEntry
 * @property {string} name               The context menu label. Can be localized.
 * @property {string} icon               A string containing an HTML icon element for the menu item
 * @property {function(jQuery)} callback The function to call when the menu item is clicked. Receives the HTML element
 *                                       of the entry that this context menu is for.
 * @property {function(jQuery):boolean} [condition] A function to call to determine if this item appears in the menu.
 *                                                  Receives the HTML element of the entry that this context menu is
 *                                                  for.
 */
/**
 * @callback ContextMenuCallback
 * @param {HTMLElement} target  The element that the context menu has been triggered for.
 */
/**
 * Display a right-click activated Context Menu which provides a dropdown menu of options
 * A ContextMenu is constructed by designating a parent HTML container and a target selector
 * An Array of menuItems defines the entries of the menu which is displayed
 */
declare class ContextMenu {
  /**
   * Create a ContextMenu for this Application and dispatch hooks.
   * @param {Application} app                           The Application this ContextMenu belongs to.
   * @param {jQuery} html                               The Application's rendered HTML.
   * @param {string} selector                           The target CSS selector which activates the menu.
   * @param {ContextMenuEntry[]} menuItems              The array of menu items being rendered.
   * @param {object} [options]                          Additional options to configure context menu initialization.
   * @param {string} [options.hookName="EntryContext"]  The name of the hook to call.
   * @returns {ContextMenu}
   */
  static create(
    app: Application,
    html: jQuery,
    selector: string,
    menuItems: ContextMenuEntry[],
    {
      hookName,
      ...options
    }?:
      | {
          hookName?: string | undefined;
        }
      | undefined
  ): ContextMenu;
  /**
   * Global listeners which apply once only to the document.
   */
  static eventListeners(): void;
  /**
   * @param {HTMLElement|jQuery} element                The containing HTML element within which the menu is positioned
   * @param {string} selector                           A CSS selector which activates the context menu.
   * @param {ContextMenuEntry[]} menuItems              An Array of entries to display in the menu
   * @param {object} [options]                          Additional options to configure the context menu.
   * @param {string} [options.eventName="contextmenu"]  Optionally override the triggering event which can spawn the
   *                                                    menu
   * @param {ContextMenuCallback} [options.onOpen]      A function to call when the context menu is opened.
   * @param {ContextMenuCallback} [options.onClose]     A function to call when the context menu is closed.
   */
  constructor(
    element: HTMLElement | jQuery,
    selector: string,
    menuItems: ContextMenuEntry[],
    {
      eventName,
      onOpen,
      onClose,
    }?:
      | {
          eventName?: string | undefined;
          onOpen?: ContextMenuCallback | undefined;
          onClose?: ContextMenuCallback | undefined;
        }
      | undefined
  );
  /**
   * The target HTMLElement being selected
   * @type {HTMLElement}
   */
  element: HTMLElement;
  /**
   * The target CSS selector which activates the menu
   * @type {string}
   */
  selector: string;
  /**
   * An interaction event name which activates the menu
   * @type {string}
   */
  eventName: string;
  /**
   * The array of menu items being rendered
   * @type {ContextMenuEntry[]}
   */
  menuItems: ContextMenuEntry[];
  /**
   * A function to call when the context menu is opened.
   * @type {Function}
   */
  onOpen: Function;
  /**
   * A function to call when the context menu is closed.
   * @type {Function}
   */
  onClose: Function;
  /**
   * Track which direction the menu is expanded in
   * @type {boolean}
   */
  _expandUp: boolean;
  /**
   * A convenience accessor to the context menu HTML object
   * @returns {*|jQuery.fn.init|jQuery|HTMLElement}
   */
  get menu(): any;
  /**
   * Attach a ContextMenu instance to an HTML selector
   */
  bind(): void;
  /**
   * Closes the menu and removes it from the DOM.
   * @param {object} [options]                Options to configure the closing behavior.
   * @param {boolean} [options.animate=true]  Animate the context menu closing.
   * @returns {Promise<void>}
   */
  close({
    animate,
  }?:
    | {
        animate?: boolean | undefined;
      }
    | undefined): Promise<void>;
  _close(): void;
  _animateOpen(menu: any): Promise<any>;
  _animateClose(menu: any): Promise<any>;
  /**
   * Render the Context Menu by iterating over the menuItems it contains.
   * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition.
   * Attach a click handler to each item which is rendered.
   * @param {jQuery} target     The target element to which the context menu is attached
   */
  render(target: jQuery): Promise<any> | undefined;
  /**
   * Set the position of the context menu, taking into consideration whether the menu should expand upward or downward
   * @private
   */
  private _setPosition;
  /**
   * Local listeners which apply to each ContextMenu instance which is created.
   * @param {jQuery} html
   */
  activateListeners(html: jQuery): void;
  #private;
}
type ContextMenuEntry = {
  /**
   * The context menu label. Can be localized.
   */
  name: string;
  /**
   * A string containing an HTML icon element for the menu item
   */
  icon: string;
  /**
   * The function to call when the menu item is clicked. Receives the HTML element
   * of the entry that this context menu is for.
   */
  callback: (arg0: jQuery) => any;
  /**
   * A function to call to determine if this item appears in the menu.
   *  Receives the HTML element of the entry that this context menu is
   *  for.
   */
  condition?: ((arg0: jQuery) => boolean) | undefined;
};
type ContextMenuCallback = (target: HTMLElement) => any;
/**
 * @typedef {ApplicationOptions} DialogOptions
 * @property {boolean} [jQuery=true]  Whether to provide jQuery objects to callback functions (if true) or plain
 *                                    HTMLElement instances (if false). This is currently true by default but in the
 *                                    future will become false by default.
 */
/**
 * @typedef {Object} DialogButton
 * @property {string} icon                  A Font Awesome icon for the button
 * @property {string} label                 The label for the button
 * @property {boolean} disabled             Whether the button is disabled
 * @property {function(jQuery)} [callback]  A callback function that fires when the button is clicked
 */
/**
 * @typedef {object} DialogData
 * @property {string} title                 The window title displayed in the dialog header
 * @property {string} content               HTML content for the dialog form
 * @property {Object<DialogButton>} buttons The buttons which are displayed as action choices for the dialog
 * @property {string} [default]             The name of the default button which should be triggered on Enter keypress
 * @property {function(jQuery)} [render]    A callback function invoked when the dialog is rendered
 * @property {function(jQuery)} [close]     Common callback operations to perform when the dialog is closed
 */
/**
 * Create a dialog window displaying a title, a message, and a set of buttons which trigger callback functions.
 * @param {DialogData} data          An object of dialog data which configures how the modal window is rendered
 * @param {DialogOptions} [options]  Dialog rendering options, see {@link Application}.
 *
 * @example Constructing a custom dialog instance
 * ```js
 * let d = new Dialog({
 *  title: "Test Dialog",
 *  content: "<p>You must choose either Option 1, or Option 2</p>",
 *  buttons: {
 *   one: {
 *    icon: '<i class="fas fa-check"></i>',
 *    label: "Option One",
 *    callback: () => console.log("Chose One")
 *   },
 *   two: {
 *    icon: '<i class="fas fa-times"></i>',
 *    label: "Option Two",
 *    callback: () => console.log("Chose Two")
 *   }
 *  },
 *  default: "two",
 *  render: html => console.log("Register interactivity in the rendered dialog"),
 *  close: html => console.log("This always is logged no matter which option is chosen")
 * });
 * d.render(true);
 * ```
 */
declare class Dialog extends Application {
  /**
   * A helper factory method to create simple confirmation dialog windows which consist of simple yes/no prompts.
   * If you require more flexibility, a custom Dialog instance is preferred.
   *
   * @param {DialogData} config                   Confirmation dialog configuration
   * @param {Function} [config.yes]               Callback function upon yes
   * @param {Function} [config.no]                Callback function upon no
   * @param {boolean} [config.defaultYes=true]    Make "yes" the default choice?
   * @param {boolean} [config.rejectClose=false]  Reject the Promise if the Dialog is closed without making a choice.
   * @param {DialogOptions} [config.options={}]   Additional rendering options passed to the Dialog
   *
   * @returns {Promise<any>}                      A promise which resolves once the user makes a choice or closes the
   *                                              window.
   *
   * @example Prompt the user with a yes or no question
   * ```js
   * let d = Dialog.confirm({
   *  title: "A Yes or No Question",
   *  content: "<p>Choose wisely.</p>",
   *  yes: () => console.log("You chose ... wisely"),
   *  no: () => console.log("You chose ... poorly"),
   *  defaultYes: false
   * });
   * ```
   */
  static confirm({
    title,
    content,
    yes,
    no,
    render,
    defaultYes,
    rejectClose,
    options,
  }?: DialogData): Promise<any>;
  /**
   * A helper factory method to display a basic "prompt" style Dialog with a single button
   * @param {DialogData} config                  Dialog configuration options
   * @param {Function} [config.callback]         A callback function to fire when the button is clicked
   * @param {boolean} [config.rejectClose=true]  Reject the promise if the dialog is closed without confirming the
   *                                             choice, otherwise resolve as null
   * @param {DialogOptions} [config.options]     Additional dialog options
   * @returns {Promise<any>}                     The returned value from the provided callback function, if any
   */
  static prompt({
    title,
    content,
    label,
    callback,
    render,
    rejectClose,
    options,
  }?: DialogData): Promise<any>;
  /**
   * Wrap the Dialog with an enclosing Promise which resolves or rejects when the client makes a choice.
   * @param {DialogData} [data]        Data passed to the Dialog constructor.
   * @param {DialogOptions} [options]  Options passed to the Dialog constructor.
   * @param {object} [renderOptions]   Options passed to the Dialog render call.
   * @returns {Promise<any>}           A Promise that resolves to the chosen result.
   */
  static wait(
    data?: DialogData | undefined,
    options?: ApplicationOptions | undefined,
    renderOptions?: object | undefined
  ): Promise<any>;
  constructor(data: any, options: any);
  data: any;
  /** @inheritdoc */
  get title(): any;
  /** @inheritdoc */
  getData(options?: {}): {
    content: any;
    buttons: {};
  };
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Handle a left-mouse click on one of the dialog choice buttons
   * @param {MouseEvent} event    The left-mouse click event
   * @private
   */
  private _onClickButton;
  /**
   * Handle a keydown event while the dialog is active
   * @param {KeyboardEvent} event   The keydown event
   * @private
   */
  private _onKeyDown;
  /**
   * Submit the Dialog by selecting one of its buttons
   * @param {Object} button         The configuration of the chosen button
   * @param {PointerEvent} event    The originating click event
   * @private
   */
  private submit;
  /** @inheritdoc */
  close(options?: {}): Promise<void>;
  #private;
}
type DialogOptions = ApplicationOptions;
type DialogButton = {
  /**
   * A Font Awesome icon for the button
   */
  icon: string;
  /**
   * The label for the button
   */
  label: string;
  /**
   * Whether the button is disabled
   */
  disabled: boolean;
  /**
   * A callback function that fires when the button is clicked
   */
  callback?: ((arg0: jQuery) => any) | undefined;
};
type DialogData = {
  /**
   * The window title displayed in the dialog header
   */
  title: string;
  /**
   * HTML content for the dialog form
   */
  content: string;
  /**
   * The buttons which are displayed as action choices for the dialog
   */
  buttons: any;
  /**
   * The name of the default button which should be triggered on Enter keypress
   */
  default?: string | undefined;
  /**
   * A callback function invoked when the dialog is rendered
   */
  render?: ((arg0: jQuery) => any) | undefined;
  /**
   * Common callback operations to perform when the dialog is closed
   */
  close?: ((arg0: jQuery) => any) | undefined;
};
/**
 * @typedef {object} DragDropConfiguration
 * @property {string} dragSelector     The CSS selector used to target draggable elements.
 * @property {string} dropSelector     The CSS selector used to target viable drop targets.
 * @property {Object<string,Function>} permissions    An object of permission test functions for each action
 * @property {Object<string,Function>} callbacks      An object of callback functions for each action
 */
/**
 * A controller class for managing drag and drop workflows within an Application instance.
 * The controller manages the following actions: dragstart, dragover, drop
 * @see {@link Application}
 *
 * @param {DragDropConfiguration}
 * @example Activate drag-and-drop handling for a certain set of elements
 * ```js
 * const dragDrop = new DragDrop({
 *   dragSelector: ".item",
 *   dropSelector: ".items",
 *   permissions: { dragstart: this._canDragStart.bind(this), drop: this._canDragDrop.bind(this) },
 *   callbacks: { dragstart: this._onDragStart.bind(this), drop: this._onDragDrop.bind(this) }
 * });
 * dragDrop.bind(html);
 * ```
 */
declare class DragDrop {
  static createDragImage(img: any, width: any, height: any): HTMLElement;
  constructor({
    dragSelector,
    dropSelector,
    permissions,
    callbacks,
  }?: {
    dragSelector: any;
    dropSelector: any;
    permissions?: {} | undefined;
    callbacks?: {} | undefined;
  });
  /**
   * The HTML selector which identifies draggable elements
   * @type {string}
   */
  dragSelector: string;
  /**
   * The HTML selector which identifies drop targets
   * @type {string}
   */
  dropSelector: string;
  /**
   * A set of permission checking functions for each action of the Drag and Drop workflow
   * @type {Object}
   */
  permissions: Object;
  /**
   * A set of callback functions for each action of the Drag and Drop workflow
   * @type {Object}
   */
  callbacks: Object;
  /**
   * Bind the DragDrop controller to an HTML application
   * @param {HTMLElement} html    The HTML element to which the handler is bound
   */
  bind(html: HTMLElement): DragDrop;
  /**
   * Execute a callback function associated with a certain action in the workflow
   * @param {DragEvent} event   The drag event being handled
   * @param {string} action     The action being attempted
   */
  callback(event: DragEvent, action: string): any;
  /**
   * Test whether the current user has permission to perform a step of the workflow
   * @param {string} action     The action being attempted
   * @param {string} selector   The selector being targeted
   * @return {boolean}          Can the action be performed?
   */
  can(action: string, selector: string): boolean;
  /**
   * Handle the start of a drag workflow
   * @param {DragEvent} event   The drag event being handled
   * @private
   */
  private _handleDragStart;
  /**
   * Handle a dragged element over a droppable target
   * @param {DragEvent} event   The drag event being handled
   * @private
   */
  private _handleDragOver;
  /**
   * Handle a dragged element dropped on a droppable target
   * @param {DragEvent} event   The drag event being handled
   * @private
   */
  private _handleDrop;
}
type DragDropConfiguration = {
  /**
   * The CSS selector used to target draggable elements.
   */
  dragSelector: string;
  /**
   * The CSS selector used to target viable drop targets.
   */
  dropSelector: string;
  /**
   * An object of permission test functions for each action
   */
  permissions: {
    [x: string]: Function;
  };
  /**
   * An object of callback functions for each action
   */
  callbacks: {
    [x: string]: Function;
  };
};
/**
 * A UI utility to make an element draggable.
 * @param {Application} app             The Application that is being made draggable.
 * @param {jQuery} element              A JQuery reference to the Application's outer-most element.
 * @param {HTMLElement|boolean} handle  The element that acts as a drag handle. Supply false to disable dragging.
 * @param {boolean|object} resizable    Is the application resizable? Supply an object to configure resizing behaviour
 *                                      or true to have it automatically configured.
 * @param {string} [resizable.selector]       A selector for the resize handle.
 * @param {boolean} [resizable.resizeX=true]  Enable resizing in the X direction.
 * @param {boolean} [resizable.resizeY=true]  Enable resizing in the Y direction.
 * @param {boolean} [resizable.rtl]           Modify the resizing direction to be right-to-left.
 */
declare class Draggable {
  constructor(app: any, element: any, handle: any, resizable: any);
  app: any;
  element: any;
  handle: any;
  resizable: any;
  /**
   * Duplicate the application's starting position to track differences
   * @type {Object}
   */
  position: Object;
  /**
   * Remember event handlers associated with this Draggable class so they may be later unregistered
   * @type {Object}
   */
  handlers: Object;
  /**
   * Throttle mousemove event handling to 60fps
   * @type {number}
   */
  _moveTime: number;
  /**
   * Activate event handling for a Draggable application
   * Attach handlers for floating, dragging, and resizing
   */
  activateListeners(): void;
  /**
   * Attach handlers for dragging and floating.
   * @protected
   */
  protected _activateDragListeners(): void;
  /**
   * Attach handlers for resizing.
   * @protected
   */
  protected _activateResizeListeners(): void;
  /**
   * Handle the initial mouse click which activates dragging behavior for the application
   * @private
   */
  private _onDragMouseDown;
  _initial:
    | {
        x: any;
        y: any;
      }
    | {
        x: any;
        y: any;
      }
    | undefined;
  /**
   * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
   * @private
   */
  private _onDragMouseMove;
  /**
   * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
   * @private
   */
  private _onDragMouseUp;
  /**
   * Handle the initial mouse click which activates dragging behavior for the application
   * @private
   */
  private _onResizeMouseDown;
  /**
   * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
   * @private
   */
  private _onResizeMouseMove;
  /**
   * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
   * @private
   */
  private _onResizeMouseUp;
}
/**
 * A collection of helper functions and utility methods related to the rich text editor
 */
declare class TextEditor {
  /**
   * A singleton text area used for HTML decoding.
   * @type {HTMLTextAreaElement}
   */
  static "__#69@#decoder": HTMLTextAreaElement;
  /**
   * Create a Rich Text Editor. The current implementation uses TinyMCE
   * @param {object} options                   Configuration options provided to the Editor init
   * @param {string} [options.engine=tinymce]  Which rich text editor engine to use, "tinymce" or "prosemirror". TinyMCE
   *                                           is deprecated and will be removed in a later version.
   * @param {string} content                   Initial HTML or text content to populate the editor with
   * @returns {Promise<TinyMCE.Editor|ProseMirrorEditor>}  The editor instance.
   */
  static create(
    {
      engine,
      ...options
    }?: {
      engine?: string | undefined;
    },
    content?: string
  ): Promise<TinyMCE.Editor | ProseMirrorEditor>;
  /**
   * A list of elements that are retained when truncating HTML.
   * @type {Set<string>}
   * @private
   */
  private static _PARAGRAPH_ELEMENTS;
  /**
   * Create a TinyMCE editor instance.
   * @param {object} [options]           Configuration options passed to the editor.
   * @param {string} [content=""]        Initial HTML or text content to populate the editor with.
   * @returns {Promise<TinyMCE.Editor>}  The TinyMCE editor instance.
   * @protected
   */
  protected static _createTinyMCE(
    options?: object | undefined,
    content?: string | undefined
  ): Promise<TinyMCE.Editor>;
  /**
   * Safely decode an HTML string, removing invalid tags and converting entities back to unicode characters.
   * @param {string} html     The original encoded HTML string
   * @returns {string}        The decoded unicode string
   */
  static decodeHTML(html: string): string;
  /**
   * @typedef {object} EnrichmentOptions
   * @property {boolean} [secrets=false]      Include unrevealed secret tags in the final HTML? If false, unrevealed
   *                                          secret blocks will be removed.
   * @property {boolean} [documents=true]     Replace dynamic document links?
   * @property {boolean} [links=true]         Replace hyperlink content?
   * @property {boolean} [rolls=true]         Replace inline dice rolls?
   * @property {object|Function} [rollData]   The data object providing context for inline rolls, or a function that
   *                                          produces it.
   * @property {boolean} [async=false]        Perform the operation asynchronously, receiving a Promise as the returned
   *                                          value. This will become the default behaviour in v11.
   * @property {ClientDocument} [relativeTo]  A document to resolve relative UUIDs against.
   */
  /**
   * Enrich HTML content by replacing or augmenting components of it
   * @param {string} content        The original HTML content (as a string)
   * @param {EnrichmentOptions} [options={}]       Additional options which configure how HTML is enriched
   * @returns {string|Promise<string>}             The enriched HTML content
   */
  static enrichHTML(
    content: string,
    options?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ): string | Promise<string>;
  /**
   * Convert text of the form @UUID[uuid]{name} to anchor elements.
   * @param {Text[]} text                          The existing text content
   * @param {EnrichmentOptions} [options]          Options provided to customize text enrichment
   * @param {boolean} [options.async]              Whether to resolve UUIDs asynchronously
   * @param {ClientDocument} [options.relativeTo]  A document to resolve relative UUIDs against.
   * @returns {Promise<boolean>|boolean}           Whether any content links were replaced and the text nodes need to be
   *                                               updated.
   * @protected
   */
  protected static _enrichContentLinks(
    text: Text[],
    {
      async,
      relativeTo,
    }?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ): Promise<boolean> | boolean;
  /**
   * Convert URLs into anchor elements.
   * @param {Text[]} text                 The existing text content
   * @param {EnrichmentOptions} [options] Options provided to customize text enrichment
   * @returns {boolean}                   Whether any hyperlinks were replaced and the text nodes need to be updated
   * @protected
   */
  protected static _enrichHyperlinks(
    text: Text[],
    options?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ): boolean;
  /**
   * Convert text of the form [[roll]] to anchor elements.
   * @param {object|Function} rollData    The data object providing context for inline rolls.
   * @param {Text[]} text                 The existing text content.
   * @param {EnrichmentOptions} [options] Options provided to customize text enrichment
   * @param {boolean} [options.async]     Whether to resolve immediate inline rolls asynchronously.
   * @returns {Promise<boolean>|boolean}  Whether any inline rolls were replaced and the text nodes need to be updated.
   * @protected
   */
  protected static _enrichInlineRolls(
    rollData: object | Function,
    text: Text[],
    {
      async,
    }?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ): Promise<boolean> | boolean;
  /**
   * Match any custom registered regex patterns and apply their replacements.
   * @param {RegExp} pattern               The pattern to match against.
   * @param {TextEditorEnricher} enricher  The function that will be run for each match.
   * @param {Text[]} text                  The existing text content.
   * @param {EnrichmentOptions} [options]  Options provided to customize text enrichment
   * @returns {Promise<boolean>}           Whether any replacements were made, requiring the text nodes to be updated.
   * @protected
   */
  protected static _applyCustomEnrichers(
    pattern: RegExp,
    enricher: (
      match: RegExpMatchArray,
      options?:
        | {
            /**
             * Include unrevealed secret tags in the final HTML? If false, unrevealed
             *       secret blocks will be removed.
             */
            secrets?: boolean | undefined;
            /**
             * Replace dynamic document links?
             */
            documents?: boolean | undefined;
            /**
             * Replace hyperlink content?
             */
            links?: boolean | undefined;
            /**
             * Replace inline dice rolls?
             */
            rolls?: boolean | undefined;
            /**
             * The data object providing context for inline rolls, or a function that
             *    produces it.
             */
            rollData?: object | Function | undefined;
            /**
             * Perform the operation asynchronously, receiving a Promise as the returned
             *         value. This will become the default behaviour in v11.
             */
            async?: boolean | undefined;
            /**
             * A document to resolve relative UUIDs against.
             */
            relativeTo?: any;
          }
        | undefined
    ) => Promise<HTMLElement | null>,
    text: Text[],
    options?:
      | {
          /**
           * Include unrevealed secret tags in the final HTML? If false, unrevealed
           *       secret blocks will be removed.
           */
          secrets?: boolean | undefined;
          /**
           * Replace dynamic document links?
           */
          documents?: boolean | undefined;
          /**
           * Replace hyperlink content?
           */
          links?: boolean | undefined;
          /**
           * Replace inline dice rolls?
           */
          rolls?: boolean | undefined;
          /**
           * The data object providing context for inline rolls, or a function that
           *    produces it.
           */
          rollData?: object | Function | undefined;
          /**
           * Perform the operation asynchronously, receiving a Promise as the returned
           *         value. This will become the default behaviour in v11.
           */
          async?: boolean | undefined;
          /**
           * A document to resolve relative UUIDs against.
           */
          relativeTo?: any;
        }
      | undefined
  ): Promise<boolean>;
  /**
   * Preview an HTML fragment by constructing a substring of a given length from its inner text.
   * @param {string} content    The raw HTML to preview
   * @param {number} length     The desired length
   * @returns {string}          The previewed HTML
   */
  static previewHTML(content: string, length?: number): string;
  /**
   * Sanitises an HTML fragment and removes any non-paragraph-style text.
   * @param {HTMLElement} html       The root HTML element.
   * @returns {HTMLElement}
   */
  static truncateHTML(html: HTMLElement): HTMLElement;
  /**
   * Truncate a fragment of text to a maximum number of characters.
   * @param {string} text           The original text fragment that should be truncated to a maximum length
   * @param {object} [options]      Options which affect the behavior of text truncation
   * @param {number} [options.maxLength]    The maximum allowed length of the truncated string.
   * @param {boolean} [options.splitWords]  Whether to truncate by splitting on white space (if true) or breaking words.
   * @param {string|null} [options.suffix]  A suffix string to append to denote that the text was truncated.
   * @returns {string}              The truncated text string
   */
  static truncateText(
    text: string,
    {
      maxLength,
      splitWords,
      suffix,
    }?:
      | {
          maxLength?: number | undefined;
          splitWords?: boolean | undefined;
          suffix?: string | null | undefined;
        }
      | undefined
  ): string;
  /**
   * Recursively identify the text nodes within a parent HTML node for potential content replacement.
   * @param {HTMLElement} parent    The parent HTML Element
   * @returns {Text[]}              An array of contained Text nodes
   * @private
   */
  private static _getTextNodes;
  /**
   * Facilitate the replacement of text node content using a matching regex rule and a provided replacement function.
   * @param {Text} text             The target text to replace
   * @param {RegExp} rgx            The provided regular expression for matching and replacement
   * @param {function(RegExpMatchArray): HTMLElement|Promise<HTMLElement>} func   The replacement function
   * @private
   */
  private static _replaceTextContent;
  /**
   * Replace a matched portion of a Text node with a replacement Node
   * @param {Text} text
   * @param {RegExpMatchArray} match
   * @param {Node} replacement
   * @private
   */
  private static _replaceTextNode;
  /**
   * Create a dynamic document link from a regular expression match
   * @param {RegExpMatchArray} match                          The regular expression match
   * @param {object} [options]                                Additional options to configure enrichment behaviour
   * @param {boolean} [options.async=false]                   If asynchronous evaluation is enabled, fromUuid will be
   *                                                          called, allowing comprehensive UUID lookup, otherwise
   *                                                          fromUuidSync will be used.
   * @param {ClientDocument} [options.relativeTo]             A document to resolve relative UUIDs against.
   * @returns {HTMLAnchorElement|Promise<HTMLAnchorElement>}  An HTML element for the document link, returned as a
   *                                                          Promise if async was true and the message contained a
   *                                                          UUID link.
   * @protected
   */
  protected static _createContentLink(
    match: RegExpMatchArray,
    {
      async,
      relativeTo,
    }?:
      | {
          async?: boolean | undefined;
          relativeTo?: any;
        }
      | undefined
  ): HTMLAnchorElement | Promise<HTMLAnchorElement>;
  /**
   * Create a dynamic document link from an old-form document link expression.
   * @param {string} type    The matched document type, or "Compendium".
   * @param {string} target  The requested match target (_id or name).
   * @param {string} name    A customized or overridden display name for the link.
   * @param {object} data    Data containing the properties of the resulting link element.
   * @returns {boolean}      Whether the resulting link is broken or not.
   * @private
   */
  private static _createLegacyContentLink;
  /**
   * Replace a hyperlink-like string with an actual HTML &lt;a> tag
   * @param {RegExpMatchArray} match  The regular expression match
   * @param {object} [options]        Additional options to configure enrichment behaviour
   * @returns {HTMLAnchorElement}     An HTML element for the document link
   * @private
   */
  private static _createHyperlink;
  /**
   * Replace an inline roll formula with a rollable &lt;a> element or an eagerly evaluated roll result
   * @param {RegExpMatchArray} match      The regular expression match array
   * @param {object} rollData             Provided roll data for use in roll evaluation
   * @param {object} [options]            Additional options to configure enrichment behaviour
   * @returns {HTMLAnchorElement|null|Promise<HTMLAnchorElement|null>}  The replaced match, returned as a Promise if
   *                                                                    async was true and the message contained an
   *                                                                    immediate inline roll.
   */
  static _createInlineRoll(
    match: RegExpMatchArray,
    rollData: object,
    options?: object | undefined
  ): HTMLAnchorElement | null | Promise<HTMLAnchorElement | null>;
  /**
   * Activate interaction listeners for the interior content of the editor frame.
   */
  static activateListeners(): void;
  /**
   * Handle click events on Document Links
   * @param {Event} event
   * @private
   */
  private static _onClickContentLink;
  /**
   * Handle left-mouse clicks on an inline roll, dispatching the formula or displaying the tooltip
   * @param {MouseEvent} event    The initiating click event
   * @private
   */
  private static _onClickInlineRoll;
  /**
   * Begin a Drag+Drop workflow for a dynamic content link
   * @param {Event} event   The originating drag event
   * @private
   */
  private static _onDragContentLink;
  /**
   * Handle dropping of transferred data onto the active rich text editor
   * @param {DragEvent} event     The originating drop event which triggered the data transfer
   * @param {TinyMCE} editor      The TinyMCE editor instance being dropped on
   * @private
   */
  private static _onDropEditorData;
  /**
   * Extract JSON data from a drag/drop event.
   * @param {DragEvent} event       The drag event which contains JSON data.
   * @returns {object}              The extracted JSON data. The object will be empty if the DragEvent did not contain
   *                                JSON-parseable data.
   */
  static getDragEventData(event: DragEvent): object;
  /**
   * Given a Drop event, returns a Content link if possible such as @Actor[ABC123], else null
   * @param {object} eventData                     The parsed object of data provided by the transfer event
   * @param {object} [options]                     Additional options to configure link creation.
   * @param {ClientDocument} [options.relativeTo]  A document to generate the link relative to.
   * @param {string} [options.label]               A custom label to use instead of the document's name.
   * @returns {Promise<string|null>}
   */
  static getContentLink(
    eventData: object,
    options?:
      | {
          relativeTo?: any;
          label?: string | undefined;
        }
      | undefined
  ): Promise<string | null>;
  /**
   * Upload an image to a document's asset path.
   * @param {string} uuid        The document's UUID.
   * @param {File} file          The image file to upload.
   * @returns {Promise<string>}  The path to the uploaded image.
   * @internal
   */
  static _uploadImage(uuid: string, file: File): Promise<string>;
}
type EnrichmentOptions = {
  /**
   * Include unrevealed secret tags in the final HTML? If false, unrevealed
   *       secret blocks will be removed.
   */
  secrets?: boolean | undefined;
  /**
   * Replace dynamic document links?
   */
  documents?: boolean | undefined;
  /**
   * Replace hyperlink content?
   */
  links?: boolean | undefined;
  /**
   * Replace inline dice rolls?
   */
  rolls?: boolean | undefined;
  /**
   * The data object providing context for inline rolls, or a function that
   *    produces it.
   */
  rollData?: object | Function | undefined;
  /**
   * Perform the operation asynchronously, receiving a Promise as the returned
   *         value. This will become the default behaviour in v11.
   */
  async?: boolean | undefined;
  /**
   * A document to resolve relative UUIDs against.
   */
  relativeTo?: any;
};
/**
 * @typedef {ApplicationOptions} FilePickerOptions
 * @property {string} [type="any"]         A type of file to target, in "audio", "image", "video", "imagevideo",
 *                                         "folder", "font", "graphics", "text", or "any"
 * @property {string} [current]            The current file path being modified, if any
 * @property {string} [activeSource=data]  A current file source in "data", "public", or "s3"
 * @property {Function} [callback]         A callback function to trigger once a file has been selected
 * @property {boolean} [allowUpload=true]  A flag which permits explicitly disallowing upload, true by default
 * @property {HTMLElement} [field]         An HTML form field that the result of this selection is applied to
 * @property {HTMLButtonElement} [button]  An HTML button element which triggers the display of this picker
 * @property {string} [displayMode]        The picker display mode in FilePicker.DISPLAY_MODES
 * @property {boolean} [tileSize=false]    Display the tile size configuration.
 */
/**
 * The FilePicker application renders contents of the server-side public directory.
 * This app allows for navigating and uploading files to the public path.
 *
 * @param {FilePickerOptions} [options={}]  Options that configure the behavior of the FilePicker
 */
declare class FilePicker extends Application {
  /**
   * Record the last-browsed directory path so that re-opening a different FilePicker instance uses the same target
   * @type {string}
   */
  static LAST_BROWSED_DIRECTORY: string;
  /**
   * Record the last-configured tile size which can automatically be applied to new FilePicker instances
   * @type {number|null}
   */
  static LAST_TILE_SIZE: number | null;
  /**
   * Record the last-configured display mode so that re-opening a different FilePicker instance uses the same mode.
   * @type {string}
   */
  static LAST_DISPLAY_MODE: string;
  /**
   * Enumerate the allowed FilePicker display modes
   * @type {string[]}
   */
  static DISPLAY_MODES: string[];
  /**
   * Cache the names of S3 buckets which can be used
   * @type {Array|null}
   */
  static S3_BUCKETS: any[] | null;
  /**
   * Test a URL to see if it matches a well known s3 key pattern
   * @param {string} url          An input URL to test
   * @returns {RegExpMatchArray|null}  A regular expression match
   */
  static matchS3URL(url: string): RegExpMatchArray | null;
  /**
   * Return the upload URL to which the FilePicker should post uploaded files
   * @type {string}
   */
  static get uploadURL(): string;
  /**
   * Browse files for a certain directory location
   * @param {string} source     The source location in which to browse. See FilePicker#sources for details
   * @param {string} target     The target within the source location
   * @param {object} options                Optional arguments
   * @param {string} [options.bucket]       A bucket within which to search if using the S3 source
   * @param {string[]} [options.extensions] An Array of file extensions to filter on
   * @param {boolean} [options.wildcard]    The requested dir represents a wildcard path
   *
   * @returns {Promise}          A Promise which resolves to the directories and files contained in the location
   */
  static browse(
    source: string,
    target: string,
    options?: {
      bucket?: string | undefined;
      extensions?: string[] | undefined;
      wildcard?: boolean | undefined;
    }
  ): Promise<any>;
  /**
   * Configure metadata settings regarding a certain file system path
   * @param {string} source     The source location in which to browse. See FilePicker#sources for details
   * @param {string} target     The target within the source location
   * @param {object} options    Optional arguments which modify the request
   * @returns {Promise<object>}
   */
  static configurePath(
    source: string,
    target: string,
    options?: object
  ): Promise<object>;
  /**
   * Create a subdirectory within a given source. The requested subdirectory path must not already exist.
   * @param {string} source     The source location in which to browse. See FilePicker#sources for details
   * @param {string} target     The target within the source location
   * @param {object} options    Optional arguments which modify the request
   * @returns {Promise<object>}
   */
  static createDirectory(
    source: string,
    target: string,
    options?: object
  ): Promise<object>;
  /**
   * General dispatcher method to submit file management commands to the server
   * @param {object} data         Request data dispatched to the server
   * @param {object} options      Options dispatched to the server
   * @returns {Promise<object>}   The server response
   * @private
   */
  private static _manageFiles;
  /**
   * Dispatch a POST request to the server containing a directory path and a file to upload
   * @param {string} source   The data source to which the file should be uploaded
   * @param {string} path     The destination path
   * @param {File} file       The File object to upload
   * @param {object} [body={}]  Additional file upload options sent in the POST body
   * @param {object} [options]  Additional options to configure how the method behaves
   * @param {boolean} [options.notify=true] Display a UI notification when the upload is processed
   * @returns {Promise<object>}  The response object
   */
  static upload(
    source: string,
    path: string,
    file: File,
    body?: object | undefined,
    {
      notify,
    }?:
      | {
          notify?: boolean | undefined;
        }
      | undefined
  ): Promise<object>;
  /**
   * Bind the file picker to a new target field.
   * Assumes the user will provide a HTMLButtonElement which has the data-target and data-type attributes
   * The data-target attribute should provide the name of the input field which should receive the selected file
   * The data-type attribute is a string in ["image", "audio"] which sets the file extensions which will be accepted
   *
   * @param {HTMLButtonElement} button     The button element
   */
  static fromButton(button: HTMLButtonElement): FilePicker;
  /**
   * @deprecated since v10
   * @ignore
   */
  static parseS3URL(key: any): any;
  /**
   * The full requested path given by the user
   * @type {string}
   */
  request: string;
  /**
   * The file sources which are available for browsing
   * @type {object}
   */
  sources: object;
  /**
   * Track the active source tab which is being browsed
   * @type {string}
   */
  activeSource: string;
  /**
   * A callback function to trigger once a file has been selected
   * @type {Function}
   */
  callback: Function;
  /**
   * The latest set of results browsed from the server
   * @type {object}
   */
  results: object;
  /**
   * The general file type which controls the set of extensions which will be accepted
   * @type {string}
   */
  type: string;
  /**
   * The target HTML element this file picker is bound to
   * @type {HTMLElement}
   */
  field: HTMLElement;
  /**
   * A button which controls the display of the picker UI
   * @type {HTMLElement}
   */
  button: HTMLElement;
  /**
   * The display mode of the FilePicker UI
   * @type {string}
   */
  displayMode: string;
  /**
   * The current set of file extensions which are being filtered upon
   * @type {string[]}
   */
  extensions: string[];
  _loaded: boolean;
  /**
   * Given a current file path, determine the directory it belongs to
   * @param {string} target   The currently requested target path
   * @returns {string[]}      An array of the inferred source and target directory path
   */
  _inferCurrentDirectory(target: string): string[];
  /**
   * Get the valid file extensions for a given named file picker type
   * @param {string} type
   * @returns {string[]}
   * @private
   */
  private _getExtensions;
  /**
   * Return the source object for the currently active source
   * @type {object}
   */
  get source(): object;
  /**
   * Return the target directory for the currently active source
   * @type {string}
   */
  get target(): string;
  /**
   * Return a flag for whether the current user is able to upload file content
   * @type {boolean}
   */
  get canUpload(): boolean;
  /** @override */
  override getData(options?: {}): Promise<{
    bucket: any;
    canGoBack: boolean;
    canUpload: boolean;
    canSelect: boolean;
    cssClass: string;
    dirs: any;
    displayMode: string;
    extensions: string[];
    files: any;
    isS3: boolean;
    noResults: boolean;
    selected: string;
    source: object;
    sources: object;
    target: string;
    tileSize: any;
    user: any;
    submitText: string;
  }>;
  /**
   * Browse to a specific location for this FilePicker instance
   * @param {string} [target]   The target within the currently active source location.
   * @param {object} [options]  Browsing options
   */
  browse(
    target?: string | undefined,
    options?: object | undefined
  ): Promise<any>;
  result: any;
  /** @inheritDoc */
  render(force: any, options: any): Application | FilePicker;
  /** @inheritdoc */
  activateListeners(html: any): void;
  /**
   * Handle a click event to change the display mode of the File Picker
   * @param {MouseEvent} event    The triggering click event
   * @private
   */
  private _onChangeDisplayMode;
  /** @override */
  override _onChangeTab(event: any, tabs: any, active: any): void;
  /** @override */
  override _canDragStart(selector: any): any;
  /** @override */
  override _canDragDrop(selector: any): boolean;
  /** @override */
  override _onDragStart(event: any): void;
  /** @override */
  override _onDrop(event: any): Promise<any>;
  /**
   * Handle user submission of the address bar to request an explicit target
   * @param {KeyboardEvent} event     The originating keydown event
   * @private
   */
  private _onRequestTarget;
  /**
   * Handle requests from the IntersectionObserver to lazily load an image file
   * @param {...any} args
   * @private
   */
  private _onLazyLoadImages;
  /**
   * Handle file or folder selection within the file picker
   * @param {Event} event     The originating click event
   * @private
   */
  private _onPick;
  /**
   * Handle backwards navigation of the folder structure.
   * @param {PointerEvent} event    The triggering click event
   * @private
   */
  private _onClickDirectoryControl;
  /**
   * Present the user with a dialog to create a subdirectory within their currently browsed file storage location.
   * @param {object} source     The data source being browsed
   * @private
   */
  private _createDirectoryDialog;
  /**
   * Handle changes to the bucket selector
   * @param {Event} event     The S3 bucket select change event
   * @private
   */
  private _onChangeBucket;
  /** @override */
  override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
  /** @inheritdoc */
  _onSubmit(ev: any): any;
  /**
   * Handle file upload
   * @param {Event} ev      The file upload event
   * @private
   */
  private _onUpload;
}
type FilePickerOptions = ApplicationOptions;
/**
 * @typedef {object} SearchFilterConfiguration
 * @property {object} options          Options which customize the behavior of the filter
 * @property {string} options.inputSelector    The CSS selector used to target the text input element.
 * @property {string} options.contentSelector  The CSS selector used to target the content container for these tabs.
 * @property {Function} options.callback       A callback function which executes when the filter changes.
 * @property {string} [options.initial]        The initial value of the search query.
 * @property {number} [options.delay=200]      The number of milliseconds to wait for text input before processing.
 */
/**
 * A controller class for managing a text input widget that filters the contents of some other UI element
 * @see {@link Application}
 *
 * @param {SearchFilterConfiguration}
 */
declare class SearchFilter {
  /**
   * Clean a query term to standardize it for matching.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
   * @param {string} query    An input string which may contain leading/trailing spaces or diacritics
   * @returns {string}        A cleaned string of ASCII characters for comparison
   */
  static cleanQuery(query: string): string;
  constructor({
    inputSelector,
    contentSelector,
    initial,
    callback,
    delay,
  }?: {
    inputSelector: any;
    contentSelector: any;
    initial?: string | undefined;
    callback: any;
    delay?: number | undefined;
  });
  /**
   * The value of the current query string
   * @type {string}
   */
  query: string;
  /**
   * A callback function to trigger when the tab is changed
   * @type {Function|null}
   */
  callback: Function | null;
  /**
   * The regular expression corresponding to the query that should be matched against
   * @type {RegExp}
   */
  rgx: RegExp;
  /**
   * The CSS selector used to target the tab navigation element
   * @type {string}
   */
  _inputSelector: string;
  /**
   * A reference to the HTML navigation element the tab controller is bound to
   * @type {HTMLElement|null}
   */
  _input: HTMLElement | null;
  /**
   * The CSS selector used to target the tab content element
   * @type {string}
   */
  _contentSelector: string;
  /**
   * A reference to the HTML container element of the tab content
   * @type {HTMLElement|null}
   */
  _content: HTMLElement | null;
  /**
   * A debounced function which applies the search filtering
   * @type {Function}
   */
  _filter: Function;
  /**
   * Bind the SearchFilter controller to an HTML application
   * @param {HTMLElement} html
   */
  bind(html: HTMLElement): void;
  /**
   * Perform a filtering of the content by invoking the callback function
   * @param {KeyboardEvent} event   The triggering keyboard event
   * @param {string} query          The input search string
   */
  filter(event: KeyboardEvent, query: string): void;
}
type SearchFilterConfiguration = {
  /**
   * Options which customize the behavior of the filter
   */
  options: {
    inputSelector: string;
    contentSelector: string;
    callback: Function;
    initial?: string | undefined;
    delay?: number | undefined;
  };
};
/**
 * An extension of the native FormData implementation.
 *
 * This class functions the same way that the default FormData does, but it is more opinionated about how
 * input fields of certain types should be evaluated and handled.
 *
 * It also adds support for certain Foundry VTT specific concepts including:
 *  Support for defined data types and type conversion
 *  Support for TinyMCE editors
 *  Support for editable HTML elements
 *
 * @extends {FormData}
 *
 * @param {HTMLFormElement} form          The form being processed
 * @param {Object<object>} [editors]      A record of TinyMCE editor metadata objects, indexed by their update key
 * @param {Object<string>} [dtypes]       A mapping of data types for form fields
 */
declare class FormDataExtended extends FormData {
  constructor(
    form: any,
    {
      editors,
      dtypes,
    }?: {
      editors?: {} | undefined;
      dtypes?: {} | undefined;
    }
  );
  /**
   * A mapping of data types requested for each form field.
   * @type {{string, string}}
   */
  dtypes: {
    string: any;
  };
  /**
   * A record of TinyMCE editors which are linked to this form.
   * @type {Object<string, object>}
   */
  editors: {
    [x: string]: object;
  };
  /**
   * Process the HTML form element to populate the FormData instance.
   * @param {HTMLFormElement} form    The HTML form being processed
   */
  process(form: HTMLFormElement): void;
  /**
   * @deprecated since v10
   * @ignore
   */
  toObject(): any;
  #private;
}
/**
 * A common framework for displaying notifications to the client.
 * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
 * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
 *
 * @extends {Application}
 *
 * @example Displaying Notification Messages
 * ```js
 * ui.notifications.info("This is an info message");
 * ui.notifications.warn("This is a warning message");
 * ui.notifications.error("This is an error message");
 * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
 * ```
 */
declare class Notifications extends Application {
  /** @override */
  static override get defaultOptions(): any;
  constructor(options: any);
  /**
   * Submitted notifications which are queued for display
   * @type {object[]}
   */
  queue: object[];
  /**
   * Notifications which are currently displayed
   * @type {object[]}
   */
  active: object[];
  /**
   * Initialize the Notifications system by displaying any system-generated messages which were passed from the server.
   */
  initialize(): void;
  /** @override */
  override _renderInner(...args: any[]): Promise<any>;
  /** @override */
  override _render(...args: any[]): Promise<void>;
  /**
   * @typedef {Object} NotifyOptions
   * @property {boolean} [permanent=false]      Whether the notification should be permanently displayed unless otherwise dismissed
   * @property {boolean} [localize=false]       Whether to localize the message content before displaying it
   * @property {boolean} [console=true]         Whether to log the message to the console
   */
  /**
   * Push a new notification into the queue
   * @param {string} message                   The content of the notification message
   * @param {string} type                      The type of notification, currently "info", "warning", and "error" are supported
   * @param {NotifyOptions} [options={}]       Additional options which affect the notification
   */
  notify(
    message: string,
    type?: string,
    {
      localize,
      permanent,
      console,
    }?:
      | {
          /**
           * Whether the notification should be permanently displayed unless otherwise dismissed
           */
          permanent?: boolean | undefined;
          /**
           * Whether to localize the message content before displaying it
           */
          localize?: boolean | undefined;
          /**
           * Whether to log the message to the console
           */
          console?: boolean | undefined;
        }
      | undefined
  ): void;
  /**
   * Display a notification with the "info" type
   * @param {string} message           The content of the notification message
   * @param {NotifyOptions} options    Notification options passed to the notify function
   * @returns {void}
   */
  info(
    message: string,
    options: {
      /**
       * Whether the notification should be permanently displayed unless otherwise dismissed
       */
      permanent?: boolean | undefined;
      /**
       * Whether to localize the message content before displaying it
       */
      localize?: boolean | undefined;
      /**
       * Whether to log the message to the console
       */
      console?: boolean | undefined;
    }
  ): void;
  /**
   * Display a notification with the "warning" type
   * @param {string} message           The content of the notification message
   * @param {NotifyOptions} options    Notification options passed to the notify function
   * @returns {void}
   */
  warn(
    message: string,
    options: {
      /**
       * Whether the notification should be permanently displayed unless otherwise dismissed
       */
      permanent?: boolean | undefined;
      /**
       * Whether to localize the message content before displaying it
       */
      localize?: boolean | undefined;
      /**
       * Whether to log the message to the console
       */
      console?: boolean | undefined;
    }
  ): void;
  /**
   * Display a notification with the "error" type
   * @param {string} message           The content of the notification message
   * @param {NotifyOptions} options    Notification options passed to the notify function
   * @returns {void}
   */
  error(
    message: string,
    options: {
      /**
       * Whether the notification should be permanently displayed unless otherwise dismissed
       */
      permanent?: boolean | undefined;
      /**
       * Whether to localize the message content before displaying it
       */
      localize?: boolean | undefined;
      /**
       * Whether to log the message to the console
       */
      console?: boolean | undefined;
    }
  ): void;
  /**
   * Retrieve a pending notification from the queue and display it
   * @private
   * @returns {void}
   */
  private fetch;
}
type NotifyOptions = {
  /**
   * Whether the notification should be permanently displayed unless otherwise dismissed
   */
  permanent?: boolean | undefined;
  /**
   * Whether to localize the message content before displaying it
   */
  localize?: boolean | undefined;
  /**
   * Whether to log the message to the console
   */
  console?: boolean | undefined;
};
/**
 * @typedef {object} ProseMirrorHistory
 * @property {string} userId  The ID of the user who submitted the step.
 * @property {Step} step      The step that was submitted.
 */
/**
 * A class responsible for managing state and collaborative editing of a single ProseMirror instance.
 */
declare class ProseMirrorEditor {
  /**
   * A list of active editor instances by their UUIDs.
   * @type {Map<string, ProseMirrorEditor>}
   */
  static "__#71@#editors": Map<string, ProseMirrorEditor>;
  /**
   * Create a ProseMirror editor instance.
   * @param {HTMLElement} target                     An HTML element to mount the editor to.
   * @param {string} [content=""]                    Content to populate the editor with.
   * @param {object} [options]                       Additional options to configure the ProseMirror instance.
   * @param {string} [options.uuid]                  A string to uniquely identify this ProseMirror instance. Ignored
   *                                                 for a collaborative editor.
   * @param {ClientDocument} [options.document]      A Document whose content is being edited. Required for
   *                                                 collaborative editing and relative UUID generation.
   * @param {string} [options.fieldName]             The field within the Document that is being edited. Required for
   *                                                 collaborative editing.
   * @param {Object<Plugin>} [options.plugins]       Plugins to include with the editor.
   * @param {boolean} [options.relativeLinks=false]  Whether to generate relative UUID links to Documents that are
   *                                                 dropped on the editor.
   * @param {boolean} [options.collaborate=false]    Whether to enable collaborative editing for this editor.
   * @returns {Promise<ProseMirrorEditor>}
   */
  static create(
    target: HTMLElement,
    content?: string | undefined,
    {
      uuid,
      document,
      fieldName,
      plugins,
      collaborate,
      relativeLinks,
    }?:
      | {
          uuid?: string | undefined;
          document?: any;
          fieldName?: string | undefined;
          plugins?: any;
          relativeLinks?: boolean | undefined;
          collaborate?: boolean | undefined;
        }
      | undefined
  ): Promise<ProseMirrorEditor>;
  /**
   * Create an EditorView with collaborative editing enabled.
   * @param {string} uuid         The ProseMirror instance UUID.
   * @param {HTMLElement} target  An HTML element to mount the editor view to.
   * @param {EditorState} state   The ProseMirror editor state.
   * @param {Plugin[]} plugins    The editor plugins to load.
   * @returns {Promise<EditorView>}
   * @protected
   */
  protected static _createCollaborativeEditorView(
    uuid: string,
    target: HTMLElement,
    state: EditorState,
    plugins: Plugin[]
  ): Promise<EditorView>;
  /**
   * Create a plain EditorView without collaborative editing.
   * @param {HTMLElement} target  An HTML element to mount the editor view to.
   * @param {EditorState} state   The ProseMirror editor state.
   * @param {Plugin[]} plugins    The editor plugins to load.
   * @returns {EditorView}
   * @protected
   */
  protected static _createLocalEditorView(
    target: HTMLElement,
    state: EditorState,
    plugins: Plugin[]
  ): EditorView;
  /**
   * Handle new editing steps supplied by the server.
   * @param {string} uuid                   The UUID that uniquely identifies the ProseMirror instance.
   * @param {number} offset                 The offset into the history, representing the point at which it was last
   *                                        truncated.
   * @param {ProseMirrorHistory[]} history  The entire edit history.
   * @protected
   */
  protected static _onNewSteps(
    uuid: string,
    offset: number,
    history: ProseMirrorHistory[]
  ): void;
  /**
   * Our client is too far behind the central authority's state and must be re-synced.
   * @param {string} uuid  The UUID that uniquely identifies the ProseMirror instance.
   * @protected
   */
  protected static _onResync(uuid: string): void;
  /**
   * Handle users joining or leaving collaborative editing.
   * @param {string} uuid       The UUID that uniquely identifies the ProseMirror instance.
   * @param {string[]} users    The IDs of the users editing (including ourselves).
   * @protected
   */
  protected static _onUsersEditing(uuid: string, users: string[]): void;
  /**
   * Update client state when the editor contents are autosaved server-side.
   * @param {string} uuid  The UUID that uniquely identifies the ProseMirror instance.
   * @param {string} html  The updated editor contents.
   * @protected
   */
  protected static _onAutosave(uuid: string, html: string): Promise<void>;
  /**
   * Listen for ProseMirror collaboration events.
   * @param {Socket} socket  The open websocket.
   * @internal
   */
  static _activateSocketListeners(socket: Socket): void;
  /**
   * @param {string} uuid                        A string that uniquely identifies this ProseMirror instance.
   * @param {EditorView} view                    The ProseMirror EditorView.
   * @param {Plugin} isDirtyPlugin               The plugin to track the dirty state of the editor.
   * @param {boolean} collaborate                Whether this is a collaborative editor.
   * @param {object} [options]                   Additional options.
   * @param {ClientDocument} [options.document]  A document associated with this editor.
   */
  constructor(
    uuid: string,
    view: EditorView,
    isDirtyPlugin: Plugin,
    collaborate: boolean,
    options?:
      | {
          document?: any;
        }
      | undefined
  );
  options: {
    document?: any;
  };
  /**
   * Retire this editor instance and clean up.
   */
  destroy(): void;
  /**
   * Have the contents of the editor been edited by the user?
   * @returns {boolean}
   */
  isDirty(): boolean;
  /**
   * Handle new editing steps supplied by the server.
   * @param {string} offset                 The offset into the history, representing the point at which it was last
   *                                        truncated.
   * @param {ProseMirrorHistory[]} history  The entire edit history.
   * @protected
   */
  protected _onNewSteps(offset: string, history: ProseMirrorHistory[]): void;
  /**
   * Disable source code editing if the user was editing it when new steps arrived.
   * @protected
   */
  protected _disableSourceCodeEditing(): void;
  /**
   * The state of this ProseMirror editor has fallen too far behind the central authority's and must be re-synced.
   * @protected
   */
  protected _resync(): void;
  /**
   * Handle users joining or leaving collaborative editing.
   * @param {string[]} users  The IDs of users currently editing (including ourselves).
   * @protected
   */
  protected _updateUserDisplay(users: string[]): void;
  /**
   * Handle an autosave update for an already-open editor.
   * @param {string} html  The updated editor contents.
   * @protected
   */
  protected _handleAutosave(html: string): void;
  #private;
}
type ProseMirrorHistory = {
  /**
   * The ID of the user who submitted the step.
   */
  userId: string;
  /**
   * The step that was submitted.
   */
  step: Step;
};
/**
 * @callback HTMLSecretContentCallback
 * @param {HTMLElement} secret  The secret element whose surrounding content we wish to retrieve.
 * @returns {string}            The content where the secret is housed.
 */
/**
 * @callback HTMLSecretUpdateCallback
 * @param {HTMLElement} secret         The secret element that is being manipulated.
 * @param {string} content             The content block containing the updated secret element.
 * @returns {Promise<ClientDocument>}  The updated Document.
 */
/**
 * @typedef {object} HTMLSecretConfiguration
 * @property {string} parentSelector      The CSS selector used to target content that contains secret blocks.
 * @property {{
 *   content: HTMLSecretContentCallback,
 *   update: HTMLSecretUpdateCallback
 * }} callbacks                           An object of callback functions for each operation.
 */
/**
 * A composable class for managing functionality for secret blocks within DocumentSheets.
 * {@see DocumentSheet}
 * @example Activate secret revealing functionality within a certain block of content.
 * ```js
 * const secrets = new HTMLSecret({
 *   selector: "section.secret[id]",
 *   callbacks: {
 *     content: this._getSecretContent.bind(this),
 *     update: this._updateSecret.bind(this)
 *   }
 * });
 * secrets.bind(html);
 * ```
 */
declare class HTMLSecret {
  /**
   * @param {HTMLSecretConfiguration} config  Configuration options.
   */
  constructor({ parentSelector, callbacks }?: HTMLSecretConfiguration);
  /**
   * Add event listeners to the targeted secret blocks.
   * @param {HTMLElement} html  The HTML content to select secret blocks from.
   */
  bind(html: HTMLElement): void;
  /**
   * Handle toggling a secret's revealed state.
   * @param {MouseEvent} event           The triggering click event.
   * @returns {Promise<ClientDocument>}  The Document whose content was modified.
   * @protected
   */
  protected _onToggleSecret(event: MouseEvent): Promise<ClientDocument>;
}
type HTMLSecretContentCallback = (secret: HTMLElement) => string;
type HTMLSecretUpdateCallback = (
  secret: HTMLElement,
  content: string
) => Promise<ClientDocument>;
type HTMLSecretConfiguration = {
  /**
   * The CSS selector used to target content that contains secret blocks.
   */
  parentSelector: string;
  /**
   * An object of callback functions for each operation.
   */
  callbacks: {
    content: HTMLSecretContentCallback;
    update: HTMLSecretUpdateCallback;
  };
};
/**
 * @typedef {object} TabsConfiguration
 * @property {string} [group]            The name of the tabs group
 * @property {string} navSelector        The CSS selector used to target the navigation element for these tabs
 * @property {string} contentSelector    The CSS selector used to target the content container for these tabs
 * @property {string} initial            The tab name of the initially active tab
 * @property {Function|null} [callback]  An optional callback function that executes when the active tab is changed
 */
/**
 * A controller class for managing tabbed navigation within an Application instance.
 * @see {@link Application}
 * @param {TabsConfiguration} config    The Tabs Configuration to use for this tabbed container
 *
 * @example Configure tab-control for a set of HTML elements
 * ```html
 * <!-- Example HTML -->
 * <nav class="tabs" data-group="primary-tabs">
 *   <a class="item" data-tab="tab1" data-group="primary-tabs">Tab 1</li>
 *   <a class="item" data-tab="tab2" data-group="primary-tabs">Tab 2</li>
 * </nav>
 *
 * <section class="content">
 *   <div class="tab" data-tab="tab1" data-group="primary-tabs">Content 1</div>
 *   <div class="tab" data-tab="tab2" data-group="primary-tabs">Content 2</div>
 * </section>
 * ```
 * Activate tab control in JavaScript
 * ```js
 * const tabs = new Tabs({navSelector: ".tabs", contentSelector: ".content", initial: "tab1"});
 * tabs.bind(html);
 * ```
 */
declare class Tabs {
  constructor({
    group,
    navSelector,
    contentSelector,
    initial,
    callback,
  }?: {
    group: any;
    navSelector: any;
    contentSelector: any;
    initial: any;
    callback: any;
  });
  /**
   * The name of the tabs group
   * @type {string}
   */
  group: string;
  /**
   * The value of the active tab
   * @type {string}
   */
  active: string;
  /**
   * A callback function to trigger when the tab is changed
   * @type {Function|null}
   */
  callback: Function | null;
  /**
   * The CSS selector used to target the tab navigation element
   * @type {string}
   */
  _navSelector: string;
  /**
   * A reference to the HTML navigation element the tab controller is bound to
   * @type {HTMLElement|null}
   */
  _nav: HTMLElement | null;
  /**
   * The CSS selector used to target the tab content element
   * @type {string}
   */
  _contentSelector: string;
  /**
   * A reference to the HTML container element of the tab content
   * @type {HTMLElement|null}
   */
  _content: HTMLElement | null;
  /**
   * Bind the Tabs controller to an HTML application
   * @param {HTMLElement} html
   */
  bind(html: HTMLElement): void;
  /**
   * Activate a new tab by name
   * @param {string} tabName
   * @param {boolean} triggerCallback
   */
  activate(tabName: string, { triggerCallback }?: boolean): void;
  /**
   * Handle click events on the tab navigation entries
   * @param {MouseEvent} event    A left click event
   * @private
   */
  private _onClickNav;
}
declare const TabsV2: typeof Tabs;
type TabsConfiguration = {
  /**
   * The name of the tabs group
   */
  group?: string | undefined;
  /**
   * The CSS selector used to target the navigation element for these tabs
   */
  navSelector: string;
  /**
   * The CSS selector used to target the content container for these tabs
   */
  contentSelector: string;
  /**
   * The tab name of the initially active tab
   */
  initial: string;
  /**
   * An optional callback function that executes when the active tab is changed
   */
  callback?: Function | null | undefined;
};
